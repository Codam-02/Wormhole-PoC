"use strict";(self.webpackChunkmultichain_poc=self.webpackChunkmultichain_poc||[]).push([[5002],{6310:(t,e,n)=>{n.d(e,{C:()=>l,P:()=>u,r:()=>a});var r=n(7126),s=Object.defineProperty,i=(t,e,n)=>(((t,e,n)=>{e in t?s(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n})(t,"symbol"!=typeof e?e+"":e,n),n);const o={};function a(t,e,n){e in o||(o[e]={});if(t in o[e])throw new Error(`Protocol ${t} for protocol ${e} has already registered`);o[e][t]=n}function c(t,e){if(e in o){const n=o[e];if(n&&t in n){const e=n[t];if(e)return e}}throw new Error(`No protocols registered for ${t}:${e}. This may be because the platform specific protocol implementation is not registered (by installing and importing it) or no implementation exists for this platform`)}class u{constructor(t,e){i(this,"network"),i(this,"config"),this.network=t,this.config=e}utils(){return this.constructor}getProtocol(t,e){return((t,e,n,r)=>c(t,e).fromRpc(n,r))(this.utils()._platform,t,e,this.config)}getProtocolInitializer(t){return c(this.utils()._platform,t)}async parseWormholeMessages(t,e,n){return(await this.getProtocol("WormholeCore",e)).parseTransaction(n)}}class l{constructor(t,e,n){i(this,"network"),i(this,"chain"),i(this,"config"),i(this,"platform"),i(this,"rpc"),i(this,"protocols",new Map),i(this,"supportsWormholeCore",(()=>this.supportsProtocol("WormholeCore"))),i(this,"getWormholeCore",(()=>this.getProtocol("WormholeCore"))),i(this,"supportsTokenBridge",(()=>this.supportsProtocol("TokenBridge"))),i(this,"getTokenBridge",(()=>this.getProtocol("TokenBridge"))),i(this,"supportsAutomaticTokenBridge",(()=>this.supportsProtocol("AutomaticTokenBridge"))),i(this,"getAutomaticTokenBridge",(()=>this.getProtocol("AutomaticTokenBridge"))),i(this,"supportsCircleBridge",(()=>this.supportsProtocol("CircleBridge"))),i(this,"getCircleBridge",(()=>this.getProtocol("CircleBridge"))),i(this,"supportsAutomaticCircleBridge",(()=>this.supportsProtocol("AutomaticCircleBridge"))),i(this,"getAutomaticCircleBridge",(()=>this.getProtocol("AutomaticCircleBridge"))),i(this,"supportsIbcBridge",(()=>this.supportsProtocol("IbcBridge"))),i(this,"getIbcBridge",(()=>this.getProtocol("IbcBridge"))),i(this,"supportsPorticoBridge",(()=>this.supportsProtocol("PorticoBridge"))),i(this,"getPorticoBridge",(()=>this.getProtocol("PorticoBridge"))),this.config=e.config[t],this.platform=e,this.chain=this.config.key,this.network=this.config.network,this.rpc=n}getRpc(){return this.rpc=this.rpc?this.rpc:this.platform.getRpc(this.chain),this.rpc}async getDecimals(t){if((0,r.ax)(t))return this.config.nativeTokenDecimals;if(this.config.tokenMap){const e=(0,r.ch)({chain:this.chain,address:t}),n=(0,r.ci)(this.network,this.chain,e);if(n)return n.decimals}return this.platform.utils().getDecimals(this.chain,await this.getRpc(),t)}async getBalance(t,e){return this.platform.utils().getBalance(this.chain,await this.getRpc(),t,e)}async getLatestBlock(){return this.platform.utils().getLatestBlock(await this.getRpc())}async getLatestFinalizedBlock(){return this.platform.utils().getLatestFinalizedBlock(await this.getRpc())}async parseTransaction(t){return this.platform.parseWormholeMessages(this.chain,await this.getRpc(),t)}async sendWait(t){return this.platform.utils().sendWait(this.chain,await this.getRpc(),t)}getToken(t){if(this.config.tokenMap&&t in this.config.tokenMap)return this.config.tokenMap[t]}async getNativeWrappedTokenId(){if(this.config.wrappedNative){const{address:t}=this.config.wrappedNative;return{chain:this.chain,address:(0,r.cj)(this.chain,t)}}const t=await this.getTokenBridge();return{chain:this.chain,address:await t.getWrappedNative()}}async getTokenAccount(t,e){return{chain:this.chain,address:t}}supportsProtocol(t){return function(t,e){const n=(0,r.cg)(t)?r.aw.get(t):t;return e in o&&n in o[e]}(this.chain,t)}async getProtocol(t,e,n){if(!e&&this.protocols.has(t))return this.protocols.get(t);const r=e?{...this.config.contracts,...e}:this.config.contracts,s=n??await this.getRpc(),i=this.platform.getProtocolInitializer(t);let o;if(n){if(e)throw new Error("Custom contracts are currently not supported with custom rpc connection. Add the contracts to the base config.");o=await this.platform.getProtocol(t,s)}else if("getVersion"in i){const t=await i.getVersion(s,r);o=new i(this.network,this.chain,s,r,t)}else o=new i(this.network,this.chain,s,r);return e||this.protocols.set(t,o),o}}},5002:(t,e,n)=>{n.r(e),n.d(e,{A:()=>Ln,P:()=>U,S:()=>On,T:()=>Rn,_:()=>En,a:()=>Tn,b:()=>Nn,s:()=>Vn});var r=n(7126),s=n(6310),i=Object.defineProperty,o=(t,e,n)=>(((t,e,n)=>{e in t?i(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n})(t,"symbol"!=typeof e?e+"":e,n),n);class a extends TypeError{constructor(t,e){let n;const{message:r,...s}=t,{path:i}=t;super(0===i.length?r:"At path: "+i.join(".")+" -- "+r),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>{var r;return null!=(r=n)?r:n=[t,...e()]}}}function c(t){return"object"==typeof t&&null!=t}function u(t){return"string"==typeof t?JSON.stringify(t):""+t}function l(t,e,n,r){if(!0===t)return;!1===t?t={}:"string"==typeof t&&(t={message:t});const{path:s,branch:i}=e,{type:o}=n,{refinement:a,message:c="Expected a value of type `"+o+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+u(r)+"`"}=t;return{value:r,type:o,refinement:a,key:s[s.length-1],path:s,branch:i,...t,message:c}}function*h(t,e,n,r){(function(t){return c(t)&&"function"==typeof t[Symbol.iterator]})(t)||(t=[t]);for(const s of t){const t=l(s,e,n,r);t&&(yield t)}}function d(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return function*(){const{path:r=[],branch:s=[t],coerce:i=!1,mask:o=!1}=n,a={path:r,branch:s};if(i&&(t=e.coercer(t,a),o&&"type"!==e.type&&c(e.schema)&&c(t)&&!Array.isArray(t)))for(const n in t)void 0===e.schema[n]&&delete t[n];let u=!0;for(const n of e.validator(t,a))u=!1,yield[n,void 0];for(let[n,l,h]of e.entries(t,a)){const e=d(l,h,{path:void 0===n?r:[...r,n],branch:void 0===n?s:[...s,l],coerce:i,mask:o});for(const r of e)r[0]?(u=!1,yield[r[0],void 0]):i&&(l=r[1],void 0===n?t=l:t instanceof Map?t.set(n,l):t instanceof Set?t.add(l):c(t)&&(t[n]=l))}if(u)for(const n of e.refiner(t,a))u=!1,yield[n,void 0];u&&(yield[void 0,t])}()}let g=class{constructor(t){const{type:e,schema:n,validator:r,refiner:s,coercer:i=t=>t,entries:o=function*(){}}=t;this.type=e,this.schema=n,this.entries=o,this.coercer=i,this.validator=r?(t,e)=>h(r(t,e),e,this,t):()=>[],this.refiner=s?(t,e)=>h(s(t,e),e,this,t):()=>[]}assert(t){return function(t,e){const n=m(t,e);if(n[0])throw n[0]}(t,this)}create(t){return p(t,this)}is(t){return f(t,this)}mask(t){return function(t,e){const n=m(t,e,{coerce:!0,mask:!0});if(n[0])throw n[0];return n[1]}(t,this)}validate(t){return m(t,this,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{})}};function p(t,e){const n=m(t,e,{coerce:!0});if(n[0])throw n[0];return n[1]}function f(t,e){return!m(t,e)[0]}function m(t,e){const n=d(t,e,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}),r=function(t){const{done:e,value:n}=t.next();return e?void 0:n}(n);return r[0]?[new a(r[0],(function*(){for(const t of n)t[0]&&(yield t[0])})),void 0]:[void 0,r[1]]}function y(t,e){return new g({type:t,schema:null,validator:e})}function b(t){return new g({type:"array",schema:t,*entries(e){if(t&&Array.isArray(e))for(const[n,r]of e.entries())yield[n,r,t]},coercer:t=>Array.isArray(t)?t.slice():t,validator:t=>Array.isArray(t)||"Expected an array value, but received: "+u(t)})}function w(){return y("boolean",(t=>"boolean"==typeof t))}function k(t){return y("instance",(e=>e instanceof t||"Expected a `"+t.name+"` instance, but received: "+u(e)))}function S(t){const e=u(t),n=typeof t;return new g({type:"literal",schema:"string"===n||"number"===n||"boolean"===n?t:null,validator:n=>n===t||"Expected the literal `"+e+"`, but received: "+u(n)})}function v(t){return new g({...t,validator:(e,n)=>null===e||t.validator(e,n),refiner:(e,n)=>null===e||t.refiner(e,n)})}function _(){return y("number",(t=>"number"==typeof t&&!isNaN(t)||"Expected a number, but received: "+u(t)))}function A(t){return new g({...t,validator:(e,n)=>void 0===e||t.validator(e,n),refiner:(e,n)=>void 0===e||t.refiner(e,n)})}function B(t,e){return new g({type:"record",schema:null,*entries(n){if(c(n))for(const r in n){const s=n[r];yield[r,r,t],yield[r,s,e]}},validator:t=>c(t)||"Expected an object, but received: "+u(t)})}function I(){return y("string",(t=>"string"==typeof t||"Expected a string, but received: "+u(t)))}function x(t){const e=y("never",(()=>!1));return new g({type:"tuple",schema:null,*entries(n){if(Array.isArray(n)){const r=Math.max(t.length,n.length);for(let s=0;s<r;s++)yield[s,n[s],t[s]||e]}},validator:t=>Array.isArray(t)||"Expected an array, but received: "+u(t)})}function E(t){const e=Object.keys(t);return new g({type:"type",schema:t,*entries(n){if(c(n))for(const r of e)yield[r,n[r],t[r]]},validator:t=>c(t)||"Expected an object, but received: "+u(t)})}function C(t){const e=t.map((t=>t.type)).join(" | ");return new g({type:"union",schema:null,validator(n,r){const s=[];for(const e of t){const[...t]=d(n,e,r),[i]=t;if(!i[0])return[];for(const[e]of t)e&&s.push(e)}return["Expected the value to satisfy a union of `"+e+"`, but received: "+u(n),...s]}})}function T(){return y("unknown",(()=>!0))}function P(t,e,n){return new g({...t,coercer:(r,s)=>f(r,e)?t.coercer(n(r,s),s):t.coercer(r,s)})}const R=()=>{const t=r.aP.utils.randomPrivateKey(),e=L(t),n=new Uint8Array(64);return n.set(t),n.set(e,32),{publicKey:e,secretKey:n}},L=r.aP.getPublicKey;function K(t){try{return r.aP.ExtendedPoint.fromHex(t),!0}catch{return!1}}const O=r.aP.verify,N=t=>r.n.Buffer.isBuffer(t)?t:t instanceof Uint8Array?r.n.Buffer.from(t.buffer,t.byteOffset,t.byteLength):r.n.Buffer.from(t);class H{constructor(t){Object.assign(this,t)}encode(){return r.n.Buffer.from((0,r.aQ)(W,this))}static decode(t){return(0,r.aR)(W,this,t)}static decodeUnchecked(t){return(0,r.aS)(W,this,t)}}const W=new Map;var q;let F;const z=32;let M=1;F=Symbol.toStringTag;class U extends H{constructor(t){if(super({}),this._bn=void 0,void 0!==t._bn)this._bn=t._bn;else{if("string"==typeof t){const e=r.a3.decode(t);if(e.length!=z)throw new Error("Invalid public key input");this._bn=new r.aD(e)}else this._bn=new r.aD(t);if(this._bn.byteLength()>z)throw new Error("Invalid public key input")}}static unique(){const t=new U(M);return M+=1,new U(t.toBuffer())}equals(t){return this._bn.eq(t._bn)}toBase58(){return r.a3.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const t=this.toBuffer();return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}toBuffer(){const t=this._bn.toArrayLike(r.n.Buffer);if(t.length===z)return t;const e=r.n.Buffer.alloc(32);return t.copy(e,32-t.length),e}get[F](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(t,e,n){const s=r.n.Buffer.concat([t.toBuffer(),r.n.Buffer.from(e),n.toBuffer()]),i=(0,r.aE)(s);return new U(i)}static createProgramAddressSync(t,e){let n=r.n.Buffer.alloc(0);t.forEach((function(t){if(t.length>32)throw new TypeError("Max seed length exceeded");n=r.n.Buffer.concat([n,N(t)])})),n=r.n.Buffer.concat([n,e.toBuffer(),r.n.Buffer.from("ProgramDerivedAddress")]);const s=(0,r.aE)(n);if(K(s))throw new Error("Invalid seeds, address must fall off the curve");return new U(s)}static async createProgramAddress(t,e){return this.createProgramAddressSync(t,e)}static findProgramAddressSync(t,e){let n,s=255;for(;0!=s;){try{const i=t.concat(r.n.Buffer.from([s]));n=this.createProgramAddressSync(i,e)}catch(i){if(i instanceof TypeError)throw i;s--;continue}return[n,s]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(t,e){return this.findProgramAddressSync(t,e)}static isOnCurve(t){return K(new U(t).toBytes())}}q=U,U.default=new q("11111111111111111111111111111111"),W.set(U,{kind:"struct",fields:[["_bn","u256"]]}),new U("BPFLoader1111111111111111111111111111111111");const G=1232;class $ extends Error{constructor(t){super(`Signature ${t} has expired: block height exceeded.`),this.signature=void 0,this.signature=t}}Object.defineProperty($.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class D extends Error{constructor(t,e){super(`Transaction was not confirmed in ${e.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=t}}Object.defineProperty(D.prototype,"name",{value:"TransactionExpiredTimeoutError"});class j extends Error{constructor(t){super(`Signature ${t} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=t}}Object.defineProperty(j.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class J{constructor(t,e){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=t,this.accountKeysFromLookups=e}keySegments(){const t=[this.staticAccountKeys];return this.accountKeysFromLookups&&(t.push(this.accountKeysFromLookups.writable),t.push(this.accountKeysFromLookups.readonly)),t}get(t){for(const e of this.keySegments()){if(t<e.length)return e[t];t-=e.length}}get length(){return this.keySegments().flat().length}compileInstructions(t){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const e=new Map;this.keySegments().flat().forEach(((t,n)=>{e.set(t.toBase58(),n)}));const n=t=>{const n=e.get(t.toBase58());if(void 0===n)throw new Error("Encountered an unknown instruction account key during compilation");return n};return t.map((t=>({programIdIndex:n(t.programId),accountKeyIndexes:t.keys.map((t=>n(t.pubkey))),data:t.data})))}}const V=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"publicKey";return(0,r.aO)(32,t)},X=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"string";const e=(0,r.aG)([(0,r.aH)("length"),(0,r.aH)("lengthPadding"),(0,r.aO)((0,r.aL)((0,r.aH)(),-8),"chars")],t),n=e.decode.bind(e),s=e.encode.bind(e),i=e;return i.decode=(t,e)=>n(t,e).chars.toString(),i.encode=(t,e,n)=>{const i={chars:r.n.Buffer.from(t,"utf8")};return s(i,e,n)},i.alloc=t=>(0,r.aH)().span+(0,r.aH)().span+r.n.Buffer.from(t,"utf8").length,i};function Q(t,e){const n=t=>{if(t.span>=0)return t.span;if("function"==typeof t.alloc)return t.alloc(e[t.property]);if("count"in t&&"elementLayout"in t){const r=e[t.property];if(Array.isArray(r))return r.length*n(t.elementLayout)}else if("fields"in t)return Q({layout:t},e[t.property]);return 0};let r=0;return t.layout.fields.forEach((t=>{r+=n(t)})),r}function Y(t){let e=0,n=0;for(;;){let r=t.shift();if(e|=(127&r)<<7*n,n+=1,!(128&r))break}return e}function Z(t,e){let n=e;for(;;){let e=127&n;if(n>>=7,0==n){t.push(e);break}e|=128,t.push(e)}}function tt(t,e){if(!t)throw new Error(e||"Assertion failed")}class et{constructor(t,e){this.payer=void 0,this.keyMetaMap=void 0,this.payer=t,this.keyMetaMap=e}static compile(t,e){const n=new Map,r=t=>{const e=t.toBase58();let r=n.get(e);return void 0===r&&(r={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(e,r)),r},s=r(e);s.isSigner=!0,s.isWritable=!0;for(const i of t){r(i.programId).isInvoked=!0;for(const t of i.keys){const e=r(t.pubkey);e.isSigner||(e.isSigner=t.isSigner),e.isWritable||(e.isWritable=t.isWritable)}}return new et(e,n)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];tt(t.length<=256,"Max static account keys length exceeded");const e=t.filter((t=>{let[,e]=t;return e.isSigner&&e.isWritable})),n=t.filter((t=>{let[,e]=t;return e.isSigner&&!e.isWritable})),r=t.filter((t=>{let[,e]=t;return!e.isSigner&&e.isWritable})),s=t.filter((t=>{let[,e]=t;return!e.isSigner&&!e.isWritable})),i={numRequiredSignatures:e.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:s.length};{tt(e.length>0,"Expected at least one writable signer key");const[t]=e[0];tt(t===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}return[i,[...e.map((t=>{let[e]=t;return new U(e)})),...n.map((t=>{let[e]=t;return new U(e)})),...r.map((t=>{let[e]=t;return new U(e)})),...s.map((t=>{let[e]=t;return new U(e)}))]]}extractTableLookup(t){const[e,n]=this.drainKeysFoundInLookupTable(t.state.addresses,(t=>!t.isSigner&&!t.isInvoked&&t.isWritable)),[r,s]=this.drainKeysFoundInLookupTable(t.state.addresses,(t=>!t.isSigner&&!t.isInvoked&&!t.isWritable));if(0!==e.length||0!==r.length)return[{accountKey:t.key,writableIndexes:e,readonlyIndexes:r},{writable:n,readonly:s}]}drainKeysFoundInLookupTable(t,e){const n=new Array,r=new Array;for(const[s,i]of this.keyMetaMap.entries())if(e(i)){const e=new U(s),i=t.findIndex((t=>t.equals(e)));i>=0&&(tt(i<256,"Max lookup table index exceeded"),n.push(i),r.push(e),this.keyMetaMap.delete(s))}return[n,r]}}const nt="Reached end of buffer unexpectedly";function rt(t){if(0===t.length)throw new Error(nt);return t.shift()}function st(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];const[s]=n;if(2===n.length?s+(n[1]??0)>t.length:s>=t.length)throw new Error(nt);return t.splice(...n)}class it{constructor(t){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=t.header,this.accountKeys=t.accountKeys.map((t=>new U(t))),this.recentBlockhash=t.recentBlockhash,this.instructions=t.instructions,this.instructions.forEach((t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex])))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map((t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:r.a3.decode(t.data)})))}get addressTableLookups(){return[]}getAccountKeys(){return new J(this.staticAccountKeys)}static compile(t){const e=et.compile(t.instructions,t.payerKey),[n,s]=e.getMessageComponents(),i=new J(s).compileInstructions(t.instructions).map((t=>({programIdIndex:t.programIdIndex,accounts:t.accountKeyIndexes,data:r.a3.encode(t.data)})));return new it({header:n,accountKeys:s,recentBlockhash:t.recentBlockhash,instructions:i})}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures;if(t>=this.header.numRequiredSignatures){return t-e<this.accountKeys.length-e-this.header.numReadonlyUnsignedAccounts}return t<e-this.header.numReadonlySignedAccounts}isProgramId(t){return this.indexToProgramIds.has(t)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter(((t,e)=>!this.isProgramId(e)))}serialize(){const t=this.accountKeys.length;let e=[];Z(e,t);const n=this.instructions.map((t=>{const{accounts:e,programIdIndex:n}=t,s=Array.from(r.a3.decode(t.data));let i=[];Z(i,e.length);let o=[];return Z(o,s.length),{programIdIndex:n,keyIndicesCount:r.n.Buffer.from(i),keyIndices:e,dataLength:r.n.Buffer.from(o),data:s}}));let s=[];Z(s,n.length);let i=r.n.Buffer.alloc(G);r.n.Buffer.from(s).copy(i);let o=s.length;n.forEach((t=>{const e=(0,r.aG)([(0,r.aJ)("programIdIndex"),(0,r.aO)(t.keyIndicesCount.length,"keyIndicesCount"),(0,r.aK)((0,r.aJ)("keyIndex"),t.keyIndices.length,"keyIndices"),(0,r.aO)(t.dataLength.length,"dataLength"),(0,r.aK)((0,r.aJ)("userdatum"),t.data.length,"data")]).encode(t,i,o);o+=e})),i=i.slice(0,o);const a=(0,r.aG)([(0,r.aO)(1,"numRequiredSignatures"),(0,r.aO)(1,"numReadonlySignedAccounts"),(0,r.aO)(1,"numReadonlyUnsignedAccounts"),(0,r.aO)(e.length,"keyCount"),(0,r.aK)(V("key"),t,"keys"),V("recentBlockhash")]),c={numRequiredSignatures:r.n.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:r.n.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:r.n.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:r.n.Buffer.from(e),keys:this.accountKeys.map((t=>N(t.toBytes()))),recentBlockhash:r.a3.decode(this.recentBlockhash)};let u=r.n.Buffer.alloc(2048);const l=a.encode(c,u);return i.copy(u,l),u.slice(0,l+i.length)}static from(t){let e=[...t];const n=rt(e);if(n!==(127&n))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=rt(e),i=rt(e),o=Y(e);let a=[];for(let d=0;d<o;d++){const t=st(e,0,z);a.push(new U(r.n.Buffer.from(t)))}const c=st(e,0,z),u=Y(e);let l=[];for(let d=0;d<u;d++){const t=rt(e),n=st(e,0,Y(e)),s=st(e,0,Y(e)),i=r.a3.encode(r.n.Buffer.from(s));l.push({programIdIndex:t,accounts:n,data:i})}const h={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:i},recentBlockhash:r.a3.encode(r.n.Buffer.from(c)),accountKeys:a,instructions:l};return new it(h)}}class ot{constructor(t){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=t.header,this.staticAccountKeys=t.staticAccountKeys,this.recentBlockhash=t.recentBlockhash,this.compiledInstructions=t.compiledInstructions,this.addressTableLookups=t.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let t=0;for(const e of this.addressTableLookups)t+=e.readonlyIndexes.length+e.writableIndexes.length;return t}getAccountKeys(t){let e;if(t&&"accountKeysFromLookups"in t&&t.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=t.accountKeysFromLookups.writable.length+t.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");e=t.accountKeysFromLookups}else if(t&&"addressLookupTableAccounts"in t&&t.addressLookupTableAccounts)e=this.resolveAddressTableLookups(t.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new J(this.staticAccountKeys,e)}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(t>=n){return t-n<this.addressTableLookups.reduce(((t,e)=>t+e.writableIndexes.length),0)}if(t>=this.header.numRequiredSignatures){return t-e<n-e-this.header.numReadonlyUnsignedAccounts}return t<e-this.header.numReadonlySignedAccounts}resolveAddressTableLookups(t){const e={writable:[],readonly:[]};for(const n of this.addressTableLookups){const r=t.find((t=>t.key.equals(n.accountKey)));if(!r)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const t of n.writableIndexes){if(!(t<r.state.addresses.length))throw new Error(`Failed to find address for index ${t} in address lookup table ${n.accountKey.toBase58()}`);e.writable.push(r.state.addresses[t])}for(const t of n.readonlyIndexes){if(!(t<r.state.addresses.length))throw new Error(`Failed to find address for index ${t} in address lookup table ${n.accountKey.toBase58()}`);e.readonly.push(r.state.addresses[t])}}return e}static compile(t){const e=et.compile(t.instructions,t.payerKey),n=new Array,r={writable:new Array,readonly:new Array},s=t.addressLookupTableAccounts||[];for(const c of s){const t=e.extractTableLookup(c);if(void 0!==t){const[e,{writable:s,readonly:i}]=t;n.push(e),r.writable.push(...s),r.readonly.push(...i)}}const[i,o]=e.getMessageComponents(),a=new J(o,r).compileInstructions(t.instructions);return new ot({header:i,staticAccountKeys:o,recentBlockhash:t.recentBlockhash,compiledInstructions:a,addressTableLookups:n})}serialize(){const t=Array();Z(t,this.staticAccountKeys.length);const e=this.serializeInstructions(),n=Array();Z(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),i=Array();Z(i,this.addressTableLookups.length);const o=(0,r.aG)([(0,r.aJ)("prefix"),(0,r.aG)([(0,r.aJ)("numRequiredSignatures"),(0,r.aJ)("numReadonlySignedAccounts"),(0,r.aJ)("numReadonlyUnsignedAccounts")],"header"),(0,r.aO)(t.length,"staticAccountKeysLength"),(0,r.aK)(V(),this.staticAccountKeys.length,"staticAccountKeys"),V("recentBlockhash"),(0,r.aO)(n.length,"instructionsLength"),(0,r.aO)(e.length,"serializedInstructions"),(0,r.aO)(i.length,"addressTableLookupsLength"),(0,r.aO)(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(G),c=o.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(t),staticAccountKeys:this.staticAccountKeys.map((t=>t.toBytes())),recentBlockhash:r.a3.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:e,addressTableLookupsLength:new Uint8Array(i),serializedAddressTableLookups:s},a);return a.slice(0,c)}serializeInstructions(){let t=0;const e=new Uint8Array(G);for(const n of this.compiledInstructions){const s=Array();Z(s,n.accountKeyIndexes.length);const i=Array();Z(i,n.data.length);t+=(0,r.aG)([(0,r.aJ)("programIdIndex"),(0,r.aO)(s.length,"encodedAccountKeyIndexesLength"),(0,r.aK)((0,r.aJ)(),n.accountKeyIndexes.length,"accountKeyIndexes"),(0,r.aO)(i.length,"encodedDataLength"),(0,r.aO)(n.data.length,"data")]).encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(i),data:n.data},e,t)}return e.slice(0,t)}serializeAddressTableLookups(){let t=0;const e=new Uint8Array(G);for(const n of this.addressTableLookups){const s=Array();Z(s,n.writableIndexes.length);const i=Array();Z(i,n.readonlyIndexes.length);t+=(0,r.aG)([V("accountKey"),(0,r.aO)(s.length,"encodedWritableIndexesLength"),(0,r.aK)((0,r.aJ)(),n.writableIndexes.length,"writableIndexes"),(0,r.aO)(i.length,"encodedReadonlyIndexesLength"),(0,r.aK)((0,r.aJ)(),n.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(i),readonlyIndexes:n.readonlyIndexes},e,t)}return e.slice(0,t)}static deserialize(t){let e=[...t];const n=rt(e),s=127&n;tt(n!==s,"Expected versioned message but received legacy message");tt(0===s,`Expected versioned message with version 0 but found version ${s}`);const i={numRequiredSignatures:rt(e),numReadonlySignedAccounts:rt(e),numReadonlyUnsignedAccounts:rt(e)},o=[],a=Y(e);for(let r=0;r<a;r++)o.push(new U(st(e,0,z)));const c=r.a3.encode(st(e,0,z)),u=Y(e),l=[];for(let r=0;r<u;r++){const t=rt(e),n=st(e,0,Y(e)),r=Y(e),s=new Uint8Array(st(e,0,r));l.push({programIdIndex:t,accountKeyIndexes:n,data:s})}const h=Y(e),d=[];for(let r=0;r<h;r++){const t=new U(st(e,0,z)),n=st(e,0,Y(e)),r=st(e,0,Y(e));d.push({accountKey:t,writableIndexes:n,readonlyIndexes:r})}return new ot({header:i,staticAccountKeys:o,recentBlockhash:c,compiledInstructions:l,addressTableLookups:d})}}let at=function(t){return t[t.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",t[t.PROCESSED=1]="PROCESSED",t[t.TIMED_OUT=2]="TIMED_OUT",t[t.NONCE_INVALID=3]="NONCE_INVALID",t}({});const ct=r.n.Buffer.alloc(64).fill(0);class ut{constructor(t){this.keys=void 0,this.programId=void 0,this.data=r.n.Buffer.alloc(0),this.programId=t.programId,this.keys=t.keys,t.data&&(this.data=t.data)}toJSON(){return{keys:this.keys.map((t=>{let{pubkey:e,isSigner:n,isWritable:r}=t;return{pubkey:e.toJSON(),isSigner:n,isWritable:r}})),programId:this.programId.toJSON(),data:[...this.data]}}}class lt{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(t){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,t)if(t.feePayer&&(this.feePayer=t.feePayer),t.signatures&&(this.signatures=t.signatures),Object.prototype.hasOwnProperty.call(t,"nonceInfo")){const{minContextSlot:e,nonceInfo:n}=t;this.minNonceContextSlot=e,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")){const{blockhash:e,lastValidBlockHeight:n}=t;this.recentBlockhash=e,this.lastValidBlockHeight=n}else{const{recentBlockhash:e,nonceInfo:n}=t;n&&(this.nonceInfo=n),this.recentBlockhash=e}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map((t=>t.toJSON())),signers:this.signatures.map((t=>{let{publicKey:e}=t;return e.toJSON()}))}}add(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];if(0===e.length)throw new Error("No instructions");return e.forEach((t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new ut(t))})),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let t,e,n;if(this.nonceInfo?(t=this.nonceInfo.nonce,e=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(t=this.recentBlockhash,e=this.instructions),!t)throw new Error("Transaction recentBlockhash required");if(e.length<1&&console.warn("No instructions provided"),this.feePayer)n=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");n=this.signatures[0].publicKey}for(let r=0;r<e.length;r++)if(void 0===e[r].programId)throw new Error(`Transaction instruction index ${r} has undefined program id`);const s=[],i=[];e.forEach((t=>{t.keys.forEach((t=>{i.push({...t})}));const e=t.programId.toString();s.includes(e)||s.push(e)})),s.forEach((t=>{i.push({pubkey:new U(t),isSigner:!1,isWritable:!1})}));const o=[];i.forEach((t=>{const e=t.pubkey.toString(),n=o.findIndex((t=>t.pubkey.toString()===e));n>-1?(o[n].isWritable=o[n].isWritable||t.isWritable,o[n].isSigner=o[n].isSigner||t.isSigner):o.push(t)})),o.sort((function(t,e){if(t.isSigner!==e.isSigner)return t.isSigner?-1:1;if(t.isWritable!==e.isWritable)return t.isWritable?-1:1;return t.pubkey.toBase58().localeCompare(e.pubkey.toBase58(),"en",{localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"})}));const a=o.findIndex((t=>t.pubkey.equals(n)));if(a>-1){const[t]=o.splice(a,1);t.isSigner=!0,t.isWritable=!0,o.unshift(t)}else o.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const r of this.signatures){const t=o.findIndex((t=>t.pubkey.equals(r.publicKey)));if(!(t>-1))throw new Error(`unknown signer: ${r.publicKey.toString()}`);o[t].isSigner||(o[t].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))}let c=0,u=0,l=0;const h=[],d=[];o.forEach((t=>{let{pubkey:e,isSigner:n,isWritable:r}=t;n?(h.push(e.toString()),c+=1,r||(u+=1)):(d.push(e.toString()),r||(l+=1))}));const g=h.concat(d),p=e.map((t=>{const{data:e,programId:n}=t;return{programIdIndex:g.indexOf(n.toString()),accounts:t.keys.map((t=>g.indexOf(t.pubkey.toString()))),data:r.a3.encode(e)}}));return p.forEach((t=>{tt(t.programIdIndex>=0),t.accounts.forEach((t=>tt(t>=0)))})),new it({header:{numRequiredSignatures:c,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:l},accountKeys:g,recentBlockhash:t,instructions:p})}_compile(){const t=this.compileMessage(),e=t.accountKeys.slice(0,t.header.numRequiredSignatures);return this.signatures.length===e.length&&this.signatures.every(((t,n)=>e[n].equals(t.publicKey)))||(this.signatures=e.map((t=>({signature:null,publicKey:t})))),t}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(t){return(await t.getFeeForMessage(this.compileMessage())).value}setSigners(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];if(0===e.length)throw new Error("No signers");const r=new Set;this.signatures=e.filter((t=>{const e=t.toString();return!r.has(e)&&(r.add(e),!0)})).map((t=>({signature:null,publicKey:t})))}sign(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];if(0===e.length)throw new Error("No signers");const r=new Set,s=[];for(const o of e){const t=o.publicKey.toString();r.has(t)||(r.add(t),s.push(o))}this.signatures=s.map((t=>({signature:null,publicKey:t.publicKey})));const i=this._compile();this._partialSign(i,...s)}partialSign(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];if(0===e.length)throw new Error("No signers");const r=new Set,s=[];for(const o of e){const t=o.publicKey.toString();r.has(t)||(r.add(t),s.push(o))}const i=this._compile();this._partialSign(i,...s)}_partialSign(t){const e=t.serialize();for(var n=arguments.length,s=new Array(n>1?n-1:0),i=1;i<n;i++)s[i-1]=arguments[i];s.forEach((t=>{const n=((t,e)=>r.aP.sign(t,e.slice(0,32)))(e,t.secretKey);this._addSignature(t.publicKey,N(n))}))}addSignature(t,e){this._compile(),this._addSignature(t,e)}_addSignature(t,e){tt(64===e.length);const n=this.signatures.findIndex((e=>t.equals(e.publicKey)));if(n<0)throw new Error(`unknown signer: ${t.toString()}`);this.signatures[n].signature=r.n.Buffer.from(e)}verifySignatures(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return!this._getMessageSignednessErrors(this.serializeMessage(),t)}_getMessageSignednessErrors(t,e){const n={};for(const{signature:r,publicKey:s}of this.signatures)null===r?e&&(n.missing||(n.missing=[])).push(s):O(r,t,s.toBytes())||(n.invalid||(n.invalid=[])).push(s);return n.invalid||n.missing?n:void 0}serialize(t){const{requireAllSignatures:e,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},t),r=this.serializeMessage();if(n){const t=this._getMessageSignednessErrors(r,e);if(t){let e="Signature verification failed.";throw t.invalid&&(e+=`\nInvalid signature for public key${1===t.invalid.length?"":"(s)"} [\`${t.invalid.map((t=>t.toBase58())).join("`, `")}\`].`),t.missing&&(e+=`\nMissing signature for public key${1===t.missing.length?"":"(s)"} [\`${t.missing.map((t=>t.toBase58())).join("`, `")}\`].`),new Error(e)}}return this._serialize(r)}_serialize(t){const{signatures:e}=this,n=[];Z(n,e.length);const s=n.length+64*e.length+t.length,i=r.n.Buffer.alloc(s);return tt(e.length<256),r.n.Buffer.from(n).copy(i,0),e.forEach(((t,e)=>{let{signature:s}=t;null!==s&&(tt(64===s.length,"signature has invalid length"),r.n.Buffer.from(s).copy(i,n.length+64*e))})),t.copy(i,n.length+64*e.length),tt(i.length<=G,`Transaction too large: ${i.length} > 1232`),i}get keys(){return tt(1===this.instructions.length),this.instructions[0].keys.map((t=>t.pubkey))}get programId(){return tt(1===this.instructions.length),this.instructions[0].programId}get data(){return tt(1===this.instructions.length),this.instructions[0].data}static from(t){let e=[...t];const n=Y(e);let s=[];for(let i=0;i<n;i++){const t=st(e,0,64);s.push(r.a3.encode(r.n.Buffer.from(t)))}return lt.populate(it.from(e),s)}static populate(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const n=new lt;return n.recentBlockhash=t.recentBlockhash,t.header.numRequiredSignatures>0&&(n.feePayer=t.accountKeys[0]),e.forEach(((e,s)=>{const i={signature:e==r.a3.encode(ct)?null:r.a3.decode(e),publicKey:t.accountKeys[s]};n.signatures.push(i)})),t.instructions.forEach((e=>{const s=e.accounts.map((e=>{const r=t.accountKeys[e];return{pubkey:r,isSigner:n.signatures.some((t=>t.publicKey.toString()===r.toString()))||t.isAccountSigner(e),isWritable:t.isAccountWritable(e)}}));n.instructions.push(new ut({keys:s,programId:t.accountKeys[e.programIdIndex],data:r.a3.decode(e.data)}))})),n._message=t,n._json=n.toJSON(),n}}class ht{constructor(t){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=t.payerKey,this.instructions=t.instructions,this.recentBlockhash=t.recentBlockhash}static decompile(t,e){const{header:n,compiledInstructions:r,recentBlockhash:s}=t,{numRequiredSignatures:i,numReadonlySignedAccounts:o,numReadonlyUnsignedAccounts:a}=n,c=i-o;tt(c>0,"Message header is invalid");const u=t.staticAccountKeys.length-i-a;tt(u>=0,"Message header is invalid");const l=t.getAccountKeys(e),h=l.get(0);if(void 0===h)throw new Error("Failed to decompile message because no account keys were found");const d=[];for(const g of r){const t=[];for(const r of g.accountKeyIndexes){const e=l.get(r);if(void 0===e)throw new Error(`Failed to find key for account key index ${r}`);let s;s=r<i?r<c:r<l.staticAccountKeys.length?r-i<u:r-l.staticAccountKeys.length<l.accountKeysFromLookups.writable.length,t.push({pubkey:e,isSigner:r<n.numRequiredSignatures,isWritable:s})}const e=l.get(g.programIdIndex);if(void 0===e)throw new Error(`Failed to find program id for program id index ${g.programIdIndex}`);d.push(new ut({programId:e,data:N(g.data),keys:t}))}return new ht({payerKey:h,instructions:d,recentBlockhash:s})}compileToLegacyMessage(){return it.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(t){return ot.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:t})}}function dt(t){return new Promise((e=>setTimeout(e,t)))}function gt(t,e){const n=t.layout.span>=0?t.layout.span:Q(t,e),s=r.n.Buffer.alloc(n),i=Object.assign({instruction:t.index},e);return t.layout.encode(i,s),s}new U("SysvarC1ock11111111111111111111111111111111"),new U("SysvarEpochSchedu1e111111111111111111111111"),new U("Sysvar1nstructions1111111111111111111111111"),new U("SysvarRecentB1ockHashes11111111111111111111"),new U("SysvarRent111111111111111111111111111111111"),new U("SysvarRewards111111111111111111111111111111"),new U("SysvarS1otHashes111111111111111111111111111"),new U("SysvarS1otHistory11111111111111111111111111"),new U("SysvarStakeHistory1111111111111111111111111");const pt=(0,r.aF)("lamportsPerSignature"),ft=(0,r.aG)([(0,r.aH)("version"),(0,r.aH)("state"),V("authorizedPubkey"),V("nonce"),(0,r.aG)([pt],"feeCalculator")]);ft.span;class mt{constructor(t){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=t.authorizedPubkey,this.nonce=t.nonce,this.feeCalculator=t.feeCalculator}static fromAccountData(t){const e=ft.decode(N(t),0);return new mt({authorizedPubkey:new U(e.authorizedPubkey),nonce:new U(e.nonce).toString(),feeCalculator:e.feeCalculator})}}const yt=(bt=8,t=>{const e=(0,r.aO)(bt,t),{encode:n,decode:s}=(t=>({decode:t.decode.bind(t),encode:t.encode.bind(t)}))(e),i=e;return i.decode=(t,e)=>{const n=s(t,e);return(0,r.aT)(r.n.Buffer.from(n))},i.encode=(t,e,s)=>{const i=(0,r.aU)(t,bt);return n(i,e,s)},i});var bt;function wt(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}Object.freeze({Create:{index:0,layout:(0,r.aG)([(0,r.aH)("instruction"),(0,r.aI)("lamports"),(0,r.aI)("space"),V("programId")])},Assign:{index:1,layout:(0,r.aG)([(0,r.aH)("instruction"),V("programId")])},Transfer:{index:2,layout:(0,r.aG)([(0,r.aH)("instruction"),yt("lamports")])},CreateWithSeed:{index:3,layout:(0,r.aG)([(0,r.aH)("instruction"),V("base"),X("seed"),(0,r.aI)("lamports"),(0,r.aI)("space"),V("programId")])},AdvanceNonceAccount:{index:4,layout:(0,r.aG)([(0,r.aH)("instruction")])},WithdrawNonceAccount:{index:5,layout:(0,r.aG)([(0,r.aH)("instruction"),(0,r.aI)("lamports")])},InitializeNonceAccount:{index:6,layout:(0,r.aG)([(0,r.aH)("instruction"),V("authorized")])},AuthorizeNonceAccount:{index:7,layout:(0,r.aG)([(0,r.aH)("instruction"),V("authorized")])},Allocate:{index:8,layout:(0,r.aG)([(0,r.aH)("instruction"),(0,r.aI)("space")])},AllocateWithSeed:{index:9,layout:(0,r.aG)([(0,r.aH)("instruction"),V("base"),X("seed"),(0,r.aI)("space"),V("programId")])},AssignWithSeed:{index:10,layout:(0,r.aG)([(0,r.aH)("instruction"),V("base"),X("seed"),V("programId")])},TransferWithSeed:{index:11,layout:(0,r.aG)([(0,r.aH)("instruction"),yt("lamports"),X("seed"),V("programId")])},UpgradeNonceAccount:{index:12,layout:(0,r.aG)([(0,r.aH)("instruction")])}}),new U("11111111111111111111111111111111"),new U("BPFLoader2111111111111111111111111111111111");var kt=Object.prototype.toString,St=Object.keys||function(t){var e=[];for(var n in t)e.push(n);return e};function vt(t,e){var n,r,s,i,o,a,c;if(!0===t)return"true";if(!1===t)return"false";switch(typeof t){case"object":if(null===t)return null;if(t.toJSON&&"function"==typeof t.toJSON)return vt(t.toJSON(),e);if("[object Array]"===(c=kt.call(t))){for(s="[",r=t.length-1,n=0;n<r;n++)s+=vt(t[n],!0)+",";return r>-1&&(s+=vt(t[n],!0)),s+"]"}if("[object Object]"===c){for(r=(i=St(t).sort()).length,s="",n=0;n<r;)void 0!==(a=vt(t[o=i[n]],!1))&&(s&&(s+=","),s+=JSON.stringify(o)+":"+a),n++;return"{"+s+"}"}return JSON.stringify(t);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(t);default:return isFinite(t)?t:null}}var _t=function(t){var e=vt(t,!1);if(void 0!==e)return""+e},At=wt(_t);function Bt(t){let e=0;for(;t>1;)t/=2,e++;return e}class It{constructor(t,e,n,r,s){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=t,this.leaderScheduleSlotOffset=e,this.warmup=n,this.firstNormalEpoch=r,this.firstNormalSlot=s}getEpoch(t){return this.getEpochAndSlotIndex(t)[0]}getEpochAndSlotIndex(t){if(t<this.firstNormalSlot){const e=Bt(function(t){return 0===t?1:(t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,1+(t|=t>>32))}(t+32+1))-Bt(32)-1;return[e,t-(this.getSlotsInEpoch(e)-32)]}{const e=t-this.firstNormalSlot,n=Math.floor(e/this.slotsPerEpoch);return[this.firstNormalEpoch+n,e%this.slotsPerEpoch]}}getFirstSlotInEpoch(t){return t<=this.firstNormalEpoch?32*(Math.pow(2,t)-1):(t-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(t){return this.getFirstSlotInEpoch(t)+this.getSlotsInEpoch(t)-1}getSlotsInEpoch(t){return t<this.firstNormalEpoch?Math.pow(2,t+Bt(32)):this.slotsPerEpoch}}class xt extends Error{constructor(t,e){super(t),this.logs=void 0,this.logs=e}}class Et extends Error{constructor(t,e){let{code:n,message:r,data:s}=t;super(null!=e?`${e}: ${r}`:r),this.code=void 0,this.data=void 0,this.code=n,this.data=s,this.name="SolanaJSONRPCError"}}var Ct=globalThis.fetch;class Tt extends r.aV{constructor(t,e,n){super((t=>{const n=(0,r.aX)(t,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...e});return this.underlyingSocket="socket"in n?n.socket:n,n}),t,e,n),this.underlyingSocket=void 0}call(){var t;const e=null==(t=this.underlyingSocket)?void 0:t.readyState;return 1===e?super.call(...arguments):Promise.reject(new Error("Tried to call a JSON-RPC method `"+(arguments.length<=0?void 0:arguments[0])+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+e+")"))}notify(){var t;const e=null==(t=this.underlyingSocket)?void 0:t.readyState;return 1===e?super.notify(...arguments):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+(arguments.length<=0?void 0:arguments[0])+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+e+")"))}}class Pt{constructor(t){this.key=void 0,this.state=void 0,this.key=t.key,this.state=t.state}isActive(){const t=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===t}static deserialize(t){const e=function(t,e){let r;try{r=t.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(r.typeIndex!==t.index)throw new Error(`invalid account data; account type mismatch ${r.typeIndex} != ${t.index}`);return r}(Rt,t),n=t.length-56;tt(n>=0,"lookup table is invalid"),tt(n%32===0,"lookup table is invalid");const s=n/32,{addresses:i}=(0,r.aG)([(0,r.aK)(V(),s,"addresses")]).decode(t.slice(56));return{deactivationSlot:e.deactivationSlot,lastExtendedSlot:e.lastExtendedSlot,lastExtendedSlotStartIndex:e.lastExtendedStartIndex,authority:0!==e.authority.length?new U(e.authority[0]):void 0,addresses:i.map((t=>new U(t)))}}}const Rt={index:1,layout:(0,r.aG)([(0,r.aH)("typeIndex"),yt("deactivationSlot"),(0,r.aF)("lastExtendedSlot"),(0,r.aJ)("lastExtendedStartIndex"),(0,r.aJ)(),(0,r.aK)(V(),(0,r.aL)((0,r.aJ)(),-1),"authority")])},Lt=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;const Kt=P(k(U),I(),(t=>new U(t))),Ot=x([I(),S("base64")]),Nt=P(k(r.n.Buffer),Ot,(t=>r.n.Buffer.from(t[0],"base64")));function Ht(t){let e,n;if("string"==typeof t)e=t;else if(t){const{commitment:r,...s}=t;e=r,n=s}return{commitment:e,config:n}}function Wt(t){return C([E({jsonrpc:S("2.0"),id:I(),result:t}),E({jsonrpc:S("2.0"),id:I(),error:E({code:T(),message:I(),data:A(y("any",(()=>!0)))})})])}const qt=Wt(T());function Ft(t){return P(Wt(t),qt,(e=>"error"in e?e:{...e,result:p(e.result,t)}))}function zt(t){return Ft(E({context:E({slot:_()}),value:t}))}function Mt(t){return E({context:E({slot:_()}),value:t})}function Ut(t,e){return 0===t?new ot({header:e.header,staticAccountKeys:e.accountKeys.map((t=>new U(t))),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map((t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:r.a3.decode(t.data)}))),addressTableLookups:e.addressTableLookups}):new it(e)}const Gt=E({foundation:_(),foundationTerm:_(),initial:_(),taper:_(),terminal:_()}),$t=Ft(b(v(E({epoch:_(),effectiveSlot:_(),amount:_(),postBalance:_(),commission:A(v(_()))})))),Dt=b(E({slot:_(),prioritizationFee:_()})),jt=E({total:_(),validator:_(),foundation:_(),epoch:_()}),Jt=E({epoch:_(),slotIndex:_(),slotsInEpoch:_(),absoluteSlot:_(),blockHeight:A(_()),transactionCount:A(_())}),Vt=E({slotsPerEpoch:_(),leaderScheduleSlotOffset:_(),warmup:w(),firstNormalEpoch:_(),firstNormalSlot:_()}),Xt=B(I(),b(_())),Qt=v(C([E({}),I()])),Yt=E({err:Qt}),Zt=S("receivedSignature"),te=E({"solana-core":I(),"feature-set":A(_())}),ee=zt(E({err:v(C([E({}),I()])),logs:v(b(I())),accounts:A(v(b(v(E({executable:w(),owner:I(),lamports:_(),data:b(I()),rentEpoch:A(_())}))))),unitsConsumed:A(_()),returnData:A(v(E({programId:I(),data:x([I(),S("base64")])})))})),ne=zt(E({byIdentity:B(I(),b(_())),range:E({firstSlot:_(),lastSlot:_()})}));const re=Ft(Gt),se=Ft(jt),ie=Ft(Dt),oe=Ft(Jt),ae=Ft(Vt),ce=Ft(Xt),ue=Ft(_()),le=zt(E({total:_(),circulating:_(),nonCirculating:_(),nonCirculatingAccounts:b(Kt)})),he=E({amount:I(),uiAmount:v(_()),decimals:_(),uiAmountString:A(I())}),de=zt(b(E({address:Kt,amount:I(),uiAmount:v(_()),decimals:_(),uiAmountString:A(I())}))),ge=zt(b(E({pubkey:Kt,account:E({executable:w(),owner:Kt,lamports:_(),data:Nt,rentEpoch:_()})}))),pe=E({program:I(),parsed:T(),space:_()}),fe=zt(b(E({pubkey:Kt,account:E({executable:w(),owner:Kt,lamports:_(),data:pe,rentEpoch:_()})}))),me=zt(b(E({lamports:_(),address:Kt}))),ye=E({executable:w(),owner:Kt,lamports:_(),data:Nt,rentEpoch:_()}),be=E({pubkey:Kt,account:ye}),we=P(C([k(r.n.Buffer),pe]),C([Ot,pe]),(t=>Array.isArray(t)?p(t,Nt):t)),ke=E({executable:w(),owner:Kt,lamports:_(),data:we,rentEpoch:_()}),Se=E({pubkey:Kt,account:ke}),ve=E({state:C([S("active"),S("inactive"),S("activating"),S("deactivating")]),active:_(),inactive:_()}),_e=Ft(b(E({signature:I(),slot:_(),err:Qt,memo:v(I()),blockTime:A(v(_()))}))),Ae=Ft(b(E({signature:I(),slot:_(),err:Qt,memo:v(I()),blockTime:A(v(_()))}))),Be=E({subscription:_(),result:Mt(ye)}),Ie=E({pubkey:Kt,account:ye}),xe=E({subscription:_(),result:Mt(Ie)}),Ee=E({parent:_(),slot:_(),root:_()}),Ce=E({subscription:_(),result:Ee}),Te=C([E({type:C([S("firstShredReceived"),S("completed"),S("optimisticConfirmation"),S("root")]),slot:_(),timestamp:_()}),E({type:S("createdBank"),parent:_(),slot:_(),timestamp:_()}),E({type:S("frozen"),slot:_(),timestamp:_(),stats:E({numTransactionEntries:_(),numSuccessfulTransactions:_(),numFailedTransactions:_(),maxTransactionsPerEntry:_()})}),E({type:S("dead"),slot:_(),timestamp:_(),err:I()})]),Pe=E({subscription:_(),result:Te}),Re=E({subscription:_(),result:Mt(C([Yt,Zt]))}),Le=E({subscription:_(),result:_()}),Ke=E({pubkey:I(),gossip:v(I()),tpu:v(I()),rpc:v(I()),version:v(I())}),Oe=E({votePubkey:I(),nodePubkey:I(),activatedStake:_(),epochVoteAccount:w(),epochCredits:b(x([_(),_(),_()])),commission:_(),lastVote:_(),rootSlot:v(_())}),Ne=Ft(E({current:b(Oe),delinquent:b(Oe)})),He=C([S("processed"),S("confirmed"),S("finalized")]),We=E({slot:_(),confirmations:v(_()),err:Qt,confirmationStatus:A(He)}),qe=zt(b(v(We))),Fe=Ft(_()),ze=E({accountKey:Kt,writableIndexes:b(_()),readonlyIndexes:b(_())}),Me=E({signatures:b(I()),message:E({accountKeys:b(I()),header:E({numRequiredSignatures:_(),numReadonlySignedAccounts:_(),numReadonlyUnsignedAccounts:_()}),instructions:b(E({accounts:b(_()),data:I(),programIdIndex:_()})),recentBlockhash:I(),addressTableLookups:A(b(ze))})}),Ue=E({pubkey:Kt,signer:w(),writable:w(),source:A(C([S("transaction"),S("lookupTable")]))}),Ge=E({accountKeys:b(Ue),signatures:b(I())}),$e=E({parsed:T(),program:I(),programId:Kt}),De=E({accounts:b(Kt),data:I(),programId:Kt}),je=P(C([De,$e]),C([E({parsed:T(),program:I(),programId:I()}),E({accounts:b(I()),data:I(),programId:I()})]),(t=>p(t,"accounts"in t?De:$e))),Je=E({signatures:b(I()),message:E({accountKeys:b(Ue),instructions:b(je),recentBlockhash:I(),addressTableLookups:A(v(b(ze)))})}),Ve=E({accountIndex:_(),mint:I(),owner:A(I()),uiTokenAmount:he}),Xe=E({writable:b(Kt),readonly:b(Kt)}),Qe=E({err:Qt,fee:_(),innerInstructions:A(v(b(E({index:_(),instructions:b(E({accounts:b(_()),data:I(),programIdIndex:_()}))})))),preBalances:b(_()),postBalances:b(_()),logMessages:A(v(b(I()))),preTokenBalances:A(v(b(Ve))),postTokenBalances:A(v(b(Ve))),loadedAddresses:A(Xe),computeUnitsConsumed:A(_())}),Ye=E({err:Qt,fee:_(),innerInstructions:A(v(b(E({index:_(),instructions:b(je)})))),preBalances:b(_()),postBalances:b(_()),logMessages:A(v(b(I()))),preTokenBalances:A(v(b(Ve))),postTokenBalances:A(v(b(Ve))),loadedAddresses:A(Xe),computeUnitsConsumed:A(_())}),Ze=C([S(0),S("legacy")]),tn=E({pubkey:I(),lamports:_(),postBalance:v(_()),rewardType:v(I()),commission:A(v(_()))}),en=Ft(v(E({blockhash:I(),previousBlockhash:I(),parentSlot:_(),transactions:b(E({transaction:Me,meta:v(Qe),version:A(Ze)})),rewards:A(b(tn)),blockTime:v(_()),blockHeight:v(_())}))),nn=Ft(v(E({blockhash:I(),previousBlockhash:I(),parentSlot:_(),rewards:A(b(tn)),blockTime:v(_()),blockHeight:v(_())}))),rn=Ft(v(E({blockhash:I(),previousBlockhash:I(),parentSlot:_(),transactions:b(E({transaction:Ge,meta:v(Qe),version:A(Ze)})),rewards:A(b(tn)),blockTime:v(_()),blockHeight:v(_())}))),sn=Ft(v(E({blockhash:I(),previousBlockhash:I(),parentSlot:_(),transactions:b(E({transaction:Je,meta:v(Ye),version:A(Ze)})),rewards:A(b(tn)),blockTime:v(_()),blockHeight:v(_())}))),on=Ft(v(E({blockhash:I(),previousBlockhash:I(),parentSlot:_(),transactions:b(E({transaction:Ge,meta:v(Ye),version:A(Ze)})),rewards:A(b(tn)),blockTime:v(_()),blockHeight:v(_())}))),an=Ft(v(E({blockhash:I(),previousBlockhash:I(),parentSlot:_(),rewards:A(b(tn)),blockTime:v(_()),blockHeight:v(_())}))),cn=Ft(v(E({blockhash:I(),previousBlockhash:I(),parentSlot:_(),transactions:b(E({transaction:Me,meta:v(Qe)})),rewards:A(b(tn)),blockTime:v(_())}))),un=Ft(v(E({blockhash:I(),previousBlockhash:I(),parentSlot:_(),signatures:b(I()),blockTime:v(_())}))),ln=Ft(v(E({slot:_(),meta:v(Qe),blockTime:A(v(_())),transaction:Me,version:A(Ze)}))),hn=Ft(v(E({slot:_(),transaction:Je,meta:v(Ye),blockTime:A(v(_())),version:A(Ze)}))),dn=zt(E({blockhash:I(),feeCalculator:E({lamportsPerSignature:_()})})),gn=zt(E({blockhash:I(),lastValidBlockHeight:_()})),pn=zt(w()),fn=Ft(b(E({slot:_(),numTransactions:_(),numSlots:_(),samplePeriodSecs:_()}))),mn=zt(v(E({feeCalculator:E({lamportsPerSignature:_()})}))),yn=Ft(I()),bn=Ft(I()),wn=E({err:Qt,logs:b(I()),signature:I()}),kn=E({result:Mt(wn),subscription:_()}),Sn={"solana-client":"js/0.0.0-development"};class vn{constructor(t,e){let n,s,i,o,a,c;this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const t={};return async e=>{const{commitment:n,config:r}=Ht(e),s=this._buildArgs([],n,void 0,r),i=At(s);return t[i]=t[i]??(async()=>{try{const t=p(await this._rpcRequest("getBlockHeight",s),Ft(_()));if("error"in t)throw new Et(t.error,"failed to get block height information");return t.result}finally{delete t[i]}})(),await t[i]}})(),e&&"string"==typeof e?this._commitment=e:e&&(this._commitment=e.commitment,this._confirmTransactionInitialTimeout=e.confirmTransactionInitialTimeout,n=e.wsEndpoint,s=e.httpHeaders,i=e.fetch,o=e.fetchMiddleware,a=e.disableRetryOnRateLimit,c=e.httpAgent),this._rpcEndpoint=function(t){if(!1===/^https?:/.test(t))throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return t}(t),this._rpcWsEndpoint=n||function(t){const e=t.match(Lt);if(null==e)throw TypeError(`Failed to validate endpoint URL \`${t}\``);const[n,r,s,i]=e,o=t.startsWith("https:")?"wss:":"ws:",a=null==s?null:parseInt(s.slice(1),10);return`${o}//${r}${null==a?"":`:${a+1}`}${i}`}(t),this._rpcClient=function(t,e,n,s,i,o){const a=n||Ct;let c;return null!=o&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments."),s&&(c=async(t,e)=>{const n=await new Promise(((n,r)=>{try{s(t,e,((t,e)=>n([t,e])))}catch(i){r(i)}}));return await a(...n)}),new r.aW((async(n,r)=>{const s={method:"POST",body:n,agent:void 0,headers:Object.assign({"Content-Type":"application/json"},e||{},Sn)};try{let e,n=5,o=500;for(;e=c?await c(t,s):await a(t,s),429===e.status&&!0!==i&&(n-=1,0!==n);)console.error(`Server responded with ${e.status} ${e.statusText}.  Retrying after ${o}ms delay...`),await dt(o),o*=2;const u=await e.text();e.ok?r(null,u):r(new Error(`${e.status} ${e.statusText}: ${u}`))}catch(o){o instanceof Error&&r(o)}}),{})}(t,s,i,o,a,c),this._rpcRequest=function(t){return(e,n)=>new Promise(((r,s)=>{t.request(e,n,((t,e)=>{t?s(t):r(e)}))}))}(this._rpcClient),this._rpcBatchRequest=function(t){return e=>new Promise(((n,r)=>{0===e.length&&n([]);const s=e.map((e=>t.request(e.methodName,e.args)));t.request(s,((t,e)=>{t?r(t):n(e)}))}))}(this._rpcClient),this._rpcWebSocket=new Tt(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(t,e){const{commitment:n,config:r}=Ht(e),s=this._buildArgs([t.toBase58()],n,void 0,r),i=p(await this._rpcRequest("getBalance",s),zt(_()));if("error"in i)throw new Et(i.error,`failed to get balance for ${t.toBase58()}`);return i.result}async getBalance(t,e){return await this.getBalanceAndContext(t,e).then((t=>t.value)).catch((e=>{throw new Error("failed to get balance of account "+t.toBase58()+": "+e)}))}async getBlockTime(t){const e=p(await this._rpcRequest("getBlockTime",[t]),Ft(v(_())));if("error"in e)throw new Et(e.error,`failed to get block time for slot ${t}`);return e.result}async getMinimumLedgerSlot(){const t=p(await this._rpcRequest("minimumLedgerSlot",[]),Ft(_()));if("error"in t)throw new Et(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const t=p(await this._rpcRequest("getFirstAvailableBlock",[]),ue);if("error"in t)throw new Et(t.error,"failed to get first available block");return t.result}async getSupply(t){let e={};e="string"==typeof t?{commitment:t}:t?{...t,commitment:t&&t.commitment||this.commitment}:{commitment:this.commitment};const n=p(await this._rpcRequest("getSupply",[e]),le);if("error"in n)throw new Et(n.error,"failed to get supply");return n.result}async getTokenSupply(t,e){const n=this._buildArgs([t.toBase58()],e),r=p(await this._rpcRequest("getTokenSupply",n),zt(he));if("error"in r)throw new Et(r.error,"failed to get token supply");return r.result}async getTokenAccountBalance(t,e){const n=this._buildArgs([t.toBase58()],e),r=p(await this._rpcRequest("getTokenAccountBalance",n),zt(he));if("error"in r)throw new Et(r.error,"failed to get token account balance");return r.result}async getTokenAccountsByOwner(t,e,n){const{commitment:r,config:s}=Ht(n);let i=[t.toBase58()];"mint"in e?i.push({mint:e.mint.toBase58()}):i.push({programId:e.programId.toBase58()});const o=this._buildArgs(i,r,"base64",s),a=p(await this._rpcRequest("getTokenAccountsByOwner",o),ge);if("error"in a)throw new Et(a.error,`failed to get token accounts owned by account ${t.toBase58()}`);return a.result}async getParsedTokenAccountsByOwner(t,e,n){let r=[t.toBase58()];"mint"in e?r.push({mint:e.mint.toBase58()}):r.push({programId:e.programId.toBase58()});const s=this._buildArgs(r,n,"jsonParsed"),i=p(await this._rpcRequest("getTokenAccountsByOwner",s),fe);if("error"in i)throw new Et(i.error,`failed to get token accounts owned by account ${t.toBase58()}`);return i.result}async getLargestAccounts(t){const e={...t,commitment:t&&t.commitment||this.commitment},n=e.filter||e.commitment?[e]:[],r=p(await this._rpcRequest("getLargestAccounts",n),me);if("error"in r)throw new Et(r.error,"failed to get largest accounts");return r.result}async getTokenLargestAccounts(t,e){const n=this._buildArgs([t.toBase58()],e),r=p(await this._rpcRequest("getTokenLargestAccounts",n),de);if("error"in r)throw new Et(r.error,"failed to get token largest accounts");return r.result}async getAccountInfoAndContext(t,e){const{commitment:n,config:r}=Ht(e),s=this._buildArgs([t.toBase58()],n,"base64",r),i=p(await this._rpcRequest("getAccountInfo",s),zt(v(ye)));if("error"in i)throw new Et(i.error,`failed to get info about account ${t.toBase58()}`);return i.result}async getParsedAccountInfo(t,e){const{commitment:n,config:r}=Ht(e),s=this._buildArgs([t.toBase58()],n,"jsonParsed",r),i=p(await this._rpcRequest("getAccountInfo",s),zt(v(ke)));if("error"in i)throw new Et(i.error,`failed to get info about account ${t.toBase58()}`);return i.result}async getAccountInfo(t,e){try{return(await this.getAccountInfoAndContext(t,e)).value}catch(n){throw new Error("failed to get info about account "+t.toBase58()+": "+n)}}async getMultipleParsedAccounts(t,e){const{commitment:n,config:r}=Ht(e),s=t.map((t=>t.toBase58())),i=this._buildArgs([s],n,"jsonParsed",r),o=p(await this._rpcRequest("getMultipleAccounts",i),zt(b(v(ke))));if("error"in o)throw new Et(o.error,`failed to get info for accounts ${s}`);return o.result}async getMultipleAccountsInfoAndContext(t,e){const{commitment:n,config:r}=Ht(e),s=t.map((t=>t.toBase58())),i=this._buildArgs([s],n,"base64",r),o=p(await this._rpcRequest("getMultipleAccounts",i),zt(b(v(ye))));if("error"in o)throw new Et(o.error,`failed to get info for accounts ${s}`);return o.result}async getMultipleAccountsInfo(t,e){return(await this.getMultipleAccountsInfoAndContext(t,e)).value}async getStakeActivation(t,e,n){const{commitment:r,config:s}=Ht(e),i=this._buildArgs([t.toBase58()],r,void 0,{...s,epoch:n??(null==s?void 0:s.epoch)}),o=p(await this._rpcRequest("getStakeActivation",i),Ft(ve));if("error"in o)throw new Et(o.error,`failed to get Stake Activation ${t.toBase58()}`);return o.result}async getProgramAccounts(t,e){const{commitment:n,config:r}=Ht(e),{encoding:s,...i}=r||{},o=this._buildArgs([t.toBase58()],n,s||"base64",i),a=await this._rpcRequest("getProgramAccounts",o),c=b(be),u=!0===i.withContext?p(a,zt(c)):p(a,Ft(c));if("error"in u)throw new Et(u.error,`failed to get accounts owned by program ${t.toBase58()}`);return u.result}async getParsedProgramAccounts(t,e){const{commitment:n,config:r}=Ht(e),s=this._buildArgs([t.toBase58()],n,"jsonParsed",r),i=p(await this._rpcRequest("getProgramAccounts",s),Ft(b(Se)));if("error"in i)throw new Et(i.error,`failed to get accounts owned by program ${t.toBase58()}`);return i.result}async confirmTransaction(t,e){var n;let s,i;if("string"==typeof t)s=t;else{const e=t;if(null!=(n=e.abortSignal)&&n.aborted)return Promise.reject(e.abortSignal.reason);s=e.signature}try{i=r.a3.decode(s)}catch{throw new Error("signature must be base58 encoded: "+s)}return tt(64===i.length,"signature has invalid length"),"string"==typeof t?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:e||this.commitment,signature:s}):"lastValidBlockHeight"in t?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e||this.commitment,strategy:t}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:e||this.commitment,strategy:t})}getCancellationPromise(t){return new Promise(((e,n)=>{null!=t&&(t.aborted?n(t.reason):t.addEventListener("abort",(()=>{n(t.reason)})))}))}getTransactionConfirmationPromise(t){let e,n,{commitment:r,signature:s}=t,i=!1;return{abortConfirmation:()=>{n&&(n(),n=void 0),null!=e&&(this.removeSignatureListener(e),e=void 0)},confirmationPromise:new Promise(((t,o)=>{try{e=this.onSignature(s,((n,r)=>{e=void 0;const s={context:r,value:n};t({__type:at.PROCESSED,response:s})}),r);const a=new Promise((t=>{null==e?t():n=this._onSubscriptionStateChange(e,(e=>{"subscribed"===e&&t()}))}));(async()=>{if(await a,i)return;const e=await this.getSignatureStatus(s);if(i||null==e)return;const{context:n,value:c}=e;if(null!=c)if(null!=c&&c.err)o(c.err);else{switch(r){case"confirmed":case"single":case"singleGossip":if("processed"===c.confirmationStatus)return;break;case"finalized":case"max":case"root":if("processed"===c.confirmationStatus||"confirmed"===c.confirmationStatus)return}i=!0,t({__type:at.PROCESSED,response:{context:n,value:c}})}})()}catch(a){o(a)}}))}}async confirmTransactionUsingBlockHeightExceedanceStrategy(t){let{commitment:e,strategy:{abortSignal:n,lastValidBlockHeight:r,signature:s}}=t,i=!1;const o=new Promise((t=>{const n=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let e=await n();if(!i){for(;e<=r;)if(await dt(1e3),i||(e=await n(),i))return;t({__type:at.BLOCKHEIGHT_EXCEEDED})}})()})),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),u=this.getCancellationPromise(n);let l;try{const t=await Promise.race([u,c,o]);if(t.__type!==at.PROCESSED)throw new $(s);l=t.response}finally{i=!0,a()}return l}async confirmTransactionUsingDurableNonceStrategy(t){let{commitment:e,strategy:{abortSignal:n,minContextSlot:r,nonceAccountPubkey:s,nonceValue:i,signature:o}}=t,a=!1;const c=new Promise((t=>{let n=i,o=null;const c=async()=>{try{const{context:t,value:n}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:r});return o=t.slot,null==n?void 0:n.nonce}catch{return n}};(async()=>{if(n=await c(),!a)for(;;){if(i!==n)return void t({__type:at.NONCE_INVALID,slotInWhichNonceDidAdvance:o});if(await dt(2e3),a||(n=await c(),a))return}})()})),{abortConfirmation:u,confirmationPromise:l}=this.getTransactionConfirmationPromise({commitment:e,signature:o}),h=this.getCancellationPromise(n);let d;try{const t=await Promise.race([h,l,c]);if(t.__type===at.PROCESSED)d=t.response;else{let n;for(;;){const e=await this.getSignatureStatus(o);if(null==e)break;if(!(e.context.slot<(t.slotInWhichNonceDidAdvance??r))){n=e;break}await dt(400)}if(null==n||!n.value)throw new j(o);{const t=e||"finalized",{confirmationStatus:r}=n.value;switch(t){case"processed":case"recent":if("processed"!==r&&"confirmed"!==r&&"finalized"!==r)throw new j(o);break;case"confirmed":case"single":case"singleGossip":if("confirmed"!==r&&"finalized"!==r)throw new j(o);break;case"finalized":case"max":case"root":if("finalized"!==r)throw new j(o)}d={context:n.context,value:{err:n.value.err}}}}}finally{a=!0,u()}return d}async confirmTransactionUsingLegacyTimeoutStrategy(t){let e,{commitment:n,signature:r}=t;const s=new Promise((t=>{let r=this._confirmTransactionInitialTimeout||6e4;switch(n){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":r=this._confirmTransactionInitialTimeout||3e4}e=setTimeout((()=>t({__type:at.TIMED_OUT,timeoutMs:r})),r)})),{abortConfirmation:i,confirmationPromise:o}=this.getTransactionConfirmationPromise({commitment:n,signature:r});let a;try{const t=await Promise.race([o,s]);if(t.__type!==at.PROCESSED)throw new D(r,t.timeoutMs/1e3);a=t.response}finally{clearTimeout(e),i()}return a}async getClusterNodes(){const t=p(await this._rpcRequest("getClusterNodes",[]),Ft(b(Ke)));if("error"in t)throw new Et(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(t){const e=this._buildArgs([],t),n=p(await this._rpcRequest("getVoteAccounts",e),Ne);if("error"in n)throw new Et(n.error,"failed to get vote accounts");return n.result}async getSlot(t){const{commitment:e,config:n}=Ht(t),r=this._buildArgs([],e,void 0,n),s=p(await this._rpcRequest("getSlot",r),Ft(_()));if("error"in s)throw new Et(s.error,"failed to get slot");return s.result}async getSlotLeader(t){const{commitment:e,config:n}=Ht(t),r=this._buildArgs([],e,void 0,n),s=p(await this._rpcRequest("getSlotLeader",r),Ft(I()));if("error"in s)throw new Et(s.error,"failed to get slot leader");return s.result}async getSlotLeaders(t,e){const n=[t,e],r=p(await this._rpcRequest("getSlotLeaders",n),Ft(b(Kt)));if("error"in r)throw new Et(r.error,"failed to get slot leaders");return r.result}async getSignatureStatus(t,e){const{context:n,value:r}=await this.getSignatureStatuses([t],e);tt(1===r.length);return{context:n,value:r[0]}}async getSignatureStatuses(t,e){const n=[t];e&&n.push(e);const r=p(await this._rpcRequest("getSignatureStatuses",n),qe);if("error"in r)throw new Et(r.error,"failed to get signature status");return r.result}async getTransactionCount(t){const{commitment:e,config:n}=Ht(t),r=this._buildArgs([],e,void 0,n),s=p(await this._rpcRequest("getTransactionCount",r),Ft(_()));if("error"in s)throw new Et(s.error,"failed to get transaction count");return s.result}async getTotalSupply(t){return(await this.getSupply({commitment:t,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(t){const e=this._buildArgs([],t),n=p(await this._rpcRequest("getInflationGovernor",e),re);if("error"in n)throw new Et(n.error,"failed to get inflation");return n.result}async getInflationReward(t,e,n){const{commitment:r,config:s}=Ht(n),i=this._buildArgs([t.map((t=>t.toBase58()))],r,void 0,{...s,epoch:e??(null==s?void 0:s.epoch)}),o=p(await this._rpcRequest("getInflationReward",i),$t);if("error"in o)throw new Et(o.error,"failed to get inflation reward");return o.result}async getInflationRate(){const t=p(await this._rpcRequest("getInflationRate",[]),se);if("error"in t)throw new Et(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(t){const{commitment:e,config:n}=Ht(t),r=this._buildArgs([],e,void 0,n),s=p(await this._rpcRequest("getEpochInfo",r),oe);if("error"in s)throw new Et(s.error,"failed to get epoch info");return s.result}async getEpochSchedule(){const t=p(await this._rpcRequest("getEpochSchedule",[]),ae);if("error"in t)throw new Et(t.error,"failed to get epoch schedule");const e=t.result;return new It(e.slotsPerEpoch,e.leaderScheduleSlotOffset,e.warmup,e.firstNormalEpoch,e.firstNormalSlot)}async getLeaderSchedule(){const t=p(await this._rpcRequest("getLeaderSchedule",[]),ce);if("error"in t)throw new Et(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(t,e){const n=this._buildArgs([t],e),r=p(await this._rpcRequest("getMinimumBalanceForRentExemption",n),Fe);return"error"in r?(console.warn("Unable to fetch minimum balance for rent exemption"),0):r.result}async getRecentBlockhashAndContext(t){const e=this._buildArgs([],t),n=p(await this._rpcRequest("getRecentBlockhash",e),dn);if("error"in n)throw new Et(n.error,"failed to get recent blockhash");return n.result}async getRecentPerformanceSamples(t){const e=p(await this._rpcRequest("getRecentPerformanceSamples",t?[t]:[]),fn);if("error"in e)throw new Et(e.error,"failed to get recent performance samples");return e.result}async getFeeCalculatorForBlockhash(t,e){const n=this._buildArgs([t],e),r=p(await this._rpcRequest("getFeeCalculatorForBlockhash",n),mn);if("error"in r)throw new Et(r.error,"failed to get fee calculator");const{context:s,value:i}=r.result;return{context:s,value:null!==i?i.feeCalculator:null}}async getFeeForMessage(t,e){const n=N(t.serialize()).toString("base64"),r=this._buildArgs([n],e),s=p(await this._rpcRequest("getFeeForMessage",r),zt(v(_())));if("error"in s)throw new Et(s.error,"failed to get fee for message");if(null===s.result)throw new Error("invalid blockhash");return s.result}async getRecentPrioritizationFees(t){var e;const n=null==(e=null==t?void 0:t.lockedWritableAccounts)?void 0:e.map((t=>t.toBase58())),r=null!=n&&n.length?[n]:[],s=p(await this._rpcRequest("getRecentPrioritizationFees",r),ie);if("error"in s)throw new Et(s.error,"failed to get recent prioritization fees");return s.result}async getRecentBlockhash(t){try{return(await this.getRecentBlockhashAndContext(t)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhash(t){try{return(await this.getLatestBlockhashAndContext(t)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhashAndContext(t){const{commitment:e,config:n}=Ht(t),r=this._buildArgs([],e,void 0,n),s=p(await this._rpcRequest("getLatestBlockhash",r),gn);if("error"in s)throw new Et(s.error,"failed to get latest blockhash");return s.result}async isBlockhashValid(t,e){const{commitment:n,config:r}=Ht(e),s=this._buildArgs([t],n,void 0,r),i=p(await this._rpcRequest("isBlockhashValid",s),pn);if("error"in i)throw new Et(i.error,"failed to determine if the blockhash `"+t+"`is valid");return i.result}async getVersion(){const t=p(await this._rpcRequest("getVersion",[]),Ft(te));if("error"in t)throw new Et(t.error,"failed to get version");return t.result}async getGenesisHash(){const t=p(await this._rpcRequest("getGenesisHash",[]),Ft(I()));if("error"in t)throw new Et(t.error,"failed to get genesis hash");return t.result}async getBlock(t,e){const{commitment:n,config:r}=Ht(e),s=this._buildArgsAtLeastConfirmed([t],n,void 0,r),i=await this._rpcRequest("getBlock",s);try{switch(null==r?void 0:r.transactionDetails){case"accounts":{const t=p(i,rn);if("error"in t)throw t.error;return t.result}case"none":{const t=p(i,nn);if("error"in t)throw t.error;return t.result}default:{const t=p(i,en);if("error"in t)throw t.error;const{result:e}=t;return e?{...e,transactions:e.transactions.map((t=>{let{transaction:e,meta:n,version:r}=t;return{meta:n,transaction:{...e,message:Ut(r,e.message)},version:r}}))}:null}}}catch(o){throw new Et(o,"failed to get confirmed block")}}async getParsedBlock(t,e){const{commitment:n,config:r}=Ht(e),s=this._buildArgsAtLeastConfirmed([t],n,"jsonParsed",r),i=await this._rpcRequest("getBlock",s);try{switch(null==r?void 0:r.transactionDetails){case"accounts":{const t=p(i,on);if("error"in t)throw t.error;return t.result}case"none":{const t=p(i,an);if("error"in t)throw t.error;return t.result}default:{const t=p(i,sn);if("error"in t)throw t.error;return t.result}}}catch(o){throw new Et(o,"failed to get block")}}async getBlockProduction(t){let e,n;if("string"==typeof t)n=t;else if(t){const{commitment:r,...s}=t;n=r,e=s}const r=this._buildArgs([],n,"base64",e),s=p(await this._rpcRequest("getBlockProduction",r),ne);if("error"in s)throw new Et(s.error,"failed to get block production information");return s.result}async getTransaction(t,e){const{commitment:n,config:r}=Ht(e),s=this._buildArgsAtLeastConfirmed([t],n,void 0,r),i=p(await this._rpcRequest("getTransaction",s),ln);if("error"in i)throw new Et(i.error,"failed to get transaction");const o=i.result;return o&&{...o,transaction:{...o.transaction,message:Ut(o.version,o.transaction.message)}}}async getParsedTransaction(t,e){const{commitment:n,config:r}=Ht(e),s=this._buildArgsAtLeastConfirmed([t],n,"jsonParsed",r),i=p(await this._rpcRequest("getTransaction",s),hn);if("error"in i)throw new Et(i.error,"failed to get transaction");return i.result}async getParsedTransactions(t,e){const{commitment:n,config:r}=Ht(e),s=t.map((t=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([t],n,"jsonParsed",r)})));return(await this._rpcBatchRequest(s)).map((t=>{const e=p(t,hn);if("error"in e)throw new Et(e.error,"failed to get transactions");return e.result}))}async getTransactions(t,e){const{commitment:n,config:r}=Ht(e),s=t.map((t=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([t],n,void 0,r)})));return(await this._rpcBatchRequest(s)).map((t=>{const e=p(t,ln);if("error"in e)throw new Et(e.error,"failed to get transactions");const n=e.result;return n&&{...n,transaction:{...n.transaction,message:Ut(n.version,n.transaction.message)}}}))}async getConfirmedBlock(t,e){const n=this._buildArgsAtLeastConfirmed([t],e),r=p(await this._rpcRequest("getConfirmedBlock",n),cn);if("error"in r)throw new Et(r.error,"failed to get confirmed block");const s=r.result;if(!s)throw new Error("Confirmed block "+t+" not found");const i={...s,transactions:s.transactions.map((t=>{let{transaction:e,meta:n}=t;const r=new it(e.message);return{meta:n,transaction:{...e,message:r}}}))};return{...i,transactions:i.transactions.map((t=>{let{transaction:e,meta:n}=t;return{meta:n,transaction:lt.populate(e.message,e.signatures)}}))}}async getBlocks(t,e,n){const r=this._buildArgsAtLeastConfirmed(void 0!==e?[t,e]:[t],n),s=p(await this._rpcRequest("getBlocks",r),Ft(b(_())));if("error"in s)throw new Et(s.error,"failed to get blocks");return s.result}async getBlockSignatures(t,e){const n=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),r=p(await this._rpcRequest("getBlock",n),un);if("error"in r)throw new Et(r.error,"failed to get block");const s=r.result;if(!s)throw new Error("Block "+t+" not found");return s}async getConfirmedBlockSignatures(t,e){const n=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),r=p(await this._rpcRequest("getConfirmedBlock",n),un);if("error"in r)throw new Et(r.error,"failed to get confirmed block");const s=r.result;if(!s)throw new Error("Confirmed block "+t+" not found");return s}async getConfirmedTransaction(t,e){const n=this._buildArgsAtLeastConfirmed([t],e),r=p(await this._rpcRequest("getConfirmedTransaction",n),ln);if("error"in r)throw new Et(r.error,"failed to get transaction");const s=r.result;if(!s)return s;const i=new it(s.transaction.message),o=s.transaction.signatures;return{...s,transaction:lt.populate(i,o)}}async getParsedConfirmedTransaction(t,e){const n=this._buildArgsAtLeastConfirmed([t],e,"jsonParsed"),r=p(await this._rpcRequest("getConfirmedTransaction",n),hn);if("error"in r)throw new Et(r.error,"failed to get confirmed transaction");return r.result}async getParsedConfirmedTransactions(t,e){const n=t.map((t=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([t],e,"jsonParsed")})));return(await this._rpcBatchRequest(n)).map((t=>{const e=p(t,hn);if("error"in e)throw new Et(e.error,"failed to get confirmed transactions");return e.result}))}async getConfirmedSignaturesForAddress(t,e,n){let r={},s=await this.getFirstAvailableBlock();for(;!("until"in r)&&!(--e<=0||e<s);)try{const t=await this.getConfirmedBlockSignatures(e,"finalized");t.signatures.length>0&&(r.until=t.signatures[t.signatures.length-1].toString())}catch(o){if(o instanceof Error&&o.message.includes("skipped"))continue;throw o}let i=await this.getSlot("finalized");for(;!("before"in r)&&!(++n>i);)try{const t=await this.getConfirmedBlockSignatures(n);t.signatures.length>0&&(r.before=t.signatures[t.signatures.length-1].toString())}catch(o){if(o instanceof Error&&o.message.includes("skipped"))continue;throw o}return(await this.getConfirmedSignaturesForAddress2(t,r)).map((t=>t.signature))}async getConfirmedSignaturesForAddress2(t,e,n){const r=this._buildArgsAtLeastConfirmed([t.toBase58()],n,void 0,e),s=p(await this._rpcRequest("getConfirmedSignaturesForAddress2",r),_e);if("error"in s)throw new Et(s.error,"failed to get confirmed signatures for address");return s.result}async getSignaturesForAddress(t,e,n){const r=this._buildArgsAtLeastConfirmed([t.toBase58()],n,void 0,e),s=p(await this._rpcRequest("getSignaturesForAddress",r),Ae);if("error"in s)throw new Et(s.error,"failed to get signatures for address");return s.result}async getAddressLookupTable(t,e){const{context:n,value:r}=await this.getAccountInfoAndContext(t,e);let s=null;return null!==r&&(s=new Pt({key:t,state:Pt.deserialize(r.data)})),{context:n,value:s}}async getNonceAndContext(t,e){const{context:n,value:r}=await this.getAccountInfoAndContext(t,e);let s=null;return null!==r&&(s=mt.fromAccountData(r.data)),{context:n,value:s}}async getNonce(t,e){return await this.getNonceAndContext(t,e).then((t=>t.value)).catch((e=>{throw new Error("failed to get nonce for account "+t.toBase58()+": "+e)}))}async requestAirdrop(t,e){const n=p(await this._rpcRequest("requestAirdrop",[t.toBase58(),e]),yn);if("error"in n)throw new Et(n.error,`airdrop to ${t.toBase58()} failed`);return n.result}async _blockhashWithExpiryBlockHeight(t){if(!t){for(;this._pollingBlockhash;)await dt(100);const t=Date.now()-this._blockhashInfo.lastFetch>=3e4;if(null!==this._blockhashInfo.latestBlockhash&&!t)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const t=Date.now(),e=this._blockhashInfo.latestBlockhash,n=e?e.blockhash:null;for(let r=0;r<50;r++){const t=await this.getLatestBlockhash("finalized");if(n!==t.blockhash)return this._blockhashInfo={latestBlockhash:t,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},t;await dt(200)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-t}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(t){const{commitment:e,config:n}=Ht(t),r=this._buildArgs([],e,"base64",n),s=p(await this._rpcRequest("getStakeMinimumDelegation",r),zt(_()));if("error"in s)throw new Et(s.error,"failed to get stake minimum delegation");return s.result}async simulateTransaction(t,e,n){if("message"in t){const s=t.serialize(),i=r.n.Buffer.from(s).toString("base64");if(Array.isArray(e)||void 0!==n)throw new Error("Invalid arguments");const o=e||{};o.encoding="base64","commitment"in o||(o.commitment=this.commitment);const a=[i,o],c=p(await this._rpcRequest("simulateTransaction",a),ee);if("error"in c)throw new Error("failed to simulate transaction: "+c.error.message);return c.result}let s;if(t instanceof lt){let e=t;s=new lt,s.feePayer=e.feePayer,s.instructions=t.instructions,s.nonceInfo=e.nonceInfo,s.signatures=e.signatures}else s=lt.populate(t),s._message=s._json=void 0;if(void 0!==e&&!Array.isArray(e))throw new Error("Invalid arguments");const i=e;if(s.nonceInfo&&i)s.sign(...i);else{let t=this._disableBlockhashCaching;for(;;){const e=await this._blockhashWithExpiryBlockHeight(t);if(s.lastValidBlockHeight=e.lastValidBlockHeight,s.recentBlockhash=e.blockhash,!i)break;if(s.sign(...i),!s.signature)throw new Error("!signature");const n=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(n)&&!this._blockhashInfo.transactionSignatures.includes(n)){this._blockhashInfo.simulatedSignatures.push(n);break}t=!0}}const o=s._compile(),a=o.serialize(),c=s._serialize(a).toString("base64"),u={encoding:"base64",commitment:this.commitment};if(n){const t=(Array.isArray(n)?n:o.nonProgramIds()).map((t=>t.toBase58()));u.accounts={encoding:"base64",addresses:t}}i&&(u.sigVerify=!0);const l=[c,u],h=p(await this._rpcRequest("simulateTransaction",l),ee);if("error"in h){let t;if("data"in h.error&&(t=h.error.data.logs,t&&Array.isArray(t))){const e="\n    ",n=e+t.join(e);console.error(h.error.message,n)}throw new xt("failed to simulate transaction: "+h.error.message,t)}return h.result}async sendTransaction(t,e,n){if("version"in t){if(e&&Array.isArray(e))throw new Error("Invalid arguments");const n=t.serialize();return await this.sendRawTransaction(n,e)}if(void 0===e||!Array.isArray(e))throw new Error("Invalid arguments");const r=e;if(t.nonceInfo)t.sign(...r);else{let e=this._disableBlockhashCaching;for(;;){const n=await this._blockhashWithExpiryBlockHeight(e);if(t.lastValidBlockHeight=n.lastValidBlockHeight,t.recentBlockhash=n.blockhash,t.sign(...r),!t.signature)throw new Error("!signature");const s=t.signature.toString("base64");if(!this._blockhashInfo.transactionSignatures.includes(s)){this._blockhashInfo.transactionSignatures.push(s);break}e=!0}}const s=t.serialize();return await this.sendRawTransaction(s,n)}async sendRawTransaction(t,e){const n=N(t).toString("base64");return await this.sendEncodedTransaction(n,e)}async sendEncodedTransaction(t,e){const n={encoding:"base64"},r=e&&e.skipPreflight,s=!0===r?"processed":e&&e.preflightCommitment||this.commitment;e&&null!=e.maxRetries&&(n.maxRetries=e.maxRetries),e&&null!=e.minContextSlot&&(n.minContextSlot=e.minContextSlot),r&&(n.skipPreflight=r),s&&(n.preflightCommitment=s);const i=[t,n],o=p(await this._rpcRequest("sendTransaction",i),bn);if("error"in o){let t;throw"data"in o.error&&(t=o.error.data.logs),new xt("failed to send transaction: "+o.error.message,t)}return o.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval((()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()}),5e3),this._updateSubscriptions()}_wsOnError(t){this._rpcWebSocketConnected=!1,console.error("ws error:",t.message)}_wsOnClose(t){this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),1e3!==t?(this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach((t=>{let[e,n]=t;this._setSubscription(e,{...n,state:"pending"})}))):this._updateSubscriptions()}_setSubscription(t,e){var n;const r=null==(n=this._subscriptionsByHash[t])?void 0:n.state;if(this._subscriptionsByHash[t]=e,r!==e.state){const n=this._subscriptionStateChangeCallbacksByHash[t];n&&n.forEach((t=>{try{t(e.state)}catch{}}))}}_onSubscriptionStateChange(t,e){var n;const r=this._subscriptionHashByClientSubscriptionId[t];if(null==r)return()=>{};const s=(n=this._subscriptionStateChangeCallbacksByHash)[r]||(n[r]=new Set);return s.add(e),()=>{s.delete(e),0===s.size&&delete this._subscriptionStateChangeCallbacksByHash[r]}}async _updateSubscriptions(){if(0===Object.keys(this._subscriptionsByHash).length)return void(this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout((()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(t){t instanceof Error&&console.log(`Error when closing socket connection: ${t.message}`)}}),500)));if(null!==this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected)return void this._rpcWebSocket.connect();const t=this._rpcWebSocketGeneration,e=()=>t===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map((async t=>{const n=this._subscriptionsByHash[t];if(void 0!==n)switch(n.state){case"pending":case"unsubscribed":if(0===n.callbacks.size)return delete this._subscriptionsByHash[t],"unsubscribed"===n.state&&delete this._subscriptionCallbacksByServerSubscriptionId[n.serverSubscriptionId],void await this._updateSubscriptions();await(async()=>{const{args:r,method:s}=n;try{this._setSubscription(t,{...n,state:"subscribing"});const e=await this._rpcWebSocket.call(s,r);this._setSubscription(t,{...n,serverSubscriptionId:e,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[e]=n.callbacks,await this._updateSubscriptions()}catch(i){if(i instanceof Error&&console.error(`${s} error for argument`,r,i.message),!e())return;this._setSubscription(t,{...n,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":0===n.callbacks.size&&await(async()=>{const{serverSubscriptionId:r,unsubscribeMethod:s}=n;if(this._subscriptionsAutoDisposedByRpc.has(r))this._subscriptionsAutoDisposedByRpc.delete(r);else{this._setSubscription(t,{...n,state:"unsubscribing"}),this._setSubscription(t,{...n,state:"unsubscribing"});try{await this._rpcWebSocket.call(s,[r])}catch(i){if(i instanceof Error&&console.error(`${s} error:`,i.message),!e())return;return this._setSubscription(t,{...n,state:"subscribed"}),void await this._updateSubscriptions()}}this._setSubscription(t,{...n,state:"unsubscribed"}),await this._updateSubscriptions()})()}})))}_handleServerNotification(t,e){const n=this._subscriptionCallbacksByServerSubscriptionId[t];void 0!==n&&n.forEach((t=>{try{t(...e)}catch(n){console.error(n)}}))}_wsOnAccountNotification(t){const{result:e,subscription:n}=p(t,Be);this._handleServerNotification(n,[e.value,e.context])}_makeSubscription(t,e){const n=this._nextClientSubscriptionId++,r=At([t.method,e]),s=this._subscriptionsByHash[r];return void 0===s?this._subscriptionsByHash[r]={...t,args:e,callbacks:new Set([t.callback]),state:"pending"}:s.callbacks.add(t.callback),this._subscriptionHashByClientSubscriptionId[n]=r,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const e=this._subscriptionsByHash[r];tt(void 0!==e,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),e.callbacks.delete(t.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(t,e,n){const r=this._buildArgs([t.toBase58()],n||this._commitment||"finalized","base64");return this._makeSubscription({callback:e,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},r)}async removeAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"account change")}_wsOnProgramAccountNotification(t){const{result:e,subscription:n}=p(t,xe);this._handleServerNotification(n,[{accountId:e.value.pubkey,accountInfo:e.value.account},e.context])}onProgramAccountChange(t,e,n,r){const s=this._buildArgs([t.toBase58()],n||this._commitment||"finalized","base64",r?{filters:r}:void 0);return this._makeSubscription({callback:e,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},s)}async removeProgramAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"program account change")}onLogs(t,e,n){const r=this._buildArgs(["object"==typeof t?{mentions:[t.toString()]}:t],n||this._commitment||"finalized");return this._makeSubscription({callback:e,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},r)}async removeOnLogsListener(t){await this._unsubscribeClientSubscription(t,"logs")}_wsOnLogsNotification(t){const{result:e,subscription:n}=p(t,kn);this._handleServerNotification(n,[e.value,e.context])}_wsOnSlotNotification(t){const{result:e,subscription:n}=p(t,Ce);this._handleServerNotification(n,[e])}onSlotChange(t){return this._makeSubscription({callback:t,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(t){await this._unsubscribeClientSubscription(t,"slot change")}_wsOnSlotUpdatesNotification(t){const{result:e,subscription:n}=p(t,Pe);this._handleServerNotification(n,[e])}onSlotUpdate(t){return this._makeSubscription({callback:t,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(t){await this._unsubscribeClientSubscription(t,"slot update")}async _unsubscribeClientSubscription(t,e){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[t];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${t}\` for '${e}' events could not be found.`)}_buildArgs(t,e,n,r){const s=e||this._commitment;if(s||n||r){let e={};n&&(e.encoding=n),s&&(e.commitment=s),r&&(e=Object.assign(e,r)),t.push(e)}return t}_buildArgsAtLeastConfirmed(t,e,n,r){const s=e||this._commitment;if(s&&!["confirmed","finalized"].includes(s))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(t,e,n,r)}_wsOnSignatureNotification(t){const{result:e,subscription:n}=p(t,Re);"receivedSignature"!==e.value&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,"receivedSignature"===e.value?[{type:"received"},e.context]:[{type:"status",result:e.value},e.context])}onSignature(t,e,n){const r=this._buildArgs([t],n||this._commitment||"finalized"),s=this._makeSubscription({callback:(t,n)=>{if("status"===t.type){e(t.result,n);try{this.removeSignatureListener(s)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},r);return s}onSignatureWithOptions(t,e,n){const{commitment:r,...s}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},i=this._buildArgs([t],r,void 0,s),o=this._makeSubscription({callback:(t,n)=>{e(t,n);try{this.removeSignatureListener(o)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return o}async removeSignatureListener(t){await this._unsubscribeClientSubscription(t,"signature result")}_wsOnRootNotification(t){const{result:e,subscription:n}=p(t,Le);this._handleServerNotification(n,[e])}onRootChange(t){return this._makeSubscription({callback:t,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(t){await this._unsubscribeClientSubscription(t,"root change")}}class _n{constructor(t){this._keypair=void 0,this._keypair=t??R()}static generate(){return new _n(R())}static fromSecretKey(t,e){if(64!==t.byteLength)throw new Error("bad secret key size");const n=t.slice(32,64);if(!e||!e.skipValidation){const e=t.slice(0,32),r=L(e);for(let t=0;t<32;t++)if(n[t]!==r[t])throw new Error("provided secretKey is invalid")}return new _n({publicKey:n,secretKey:t})}static fromSeed(t){const e=L(t),n=new Uint8Array(64);return n.set(t),n.set(e,32),new _n({publicKey:e,secretKey:n})}get publicKey(){return new U(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:(0,r.aG)([(0,r.aH)("instruction"),yt("recentSlot"),(0,r.aJ)("bumpSeed")])},FreezeLookupTable:{index:1,layout:(0,r.aG)([(0,r.aH)("instruction")])},ExtendLookupTable:{index:2,layout:(0,r.aG)([(0,r.aH)("instruction"),yt(),(0,r.aK)(V(),(0,r.aL)((0,r.aH)(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:(0,r.aG)([(0,r.aH)("instruction")])},CloseLookupTable:{index:4,layout:(0,r.aG)([(0,r.aH)("instruction")])}}),new U("AddressLookupTab1e1111111111111111111111111");const An=Object.freeze({RequestUnits:{index:0,layout:(0,r.aG)([(0,r.aJ)("instruction"),(0,r.aH)("units"),(0,r.aH)("additionalFee")])},RequestHeapFrame:{index:1,layout:(0,r.aG)([(0,r.aJ)("instruction"),(0,r.aH)("bytes")])},SetComputeUnitLimit:{index:2,layout:(0,r.aG)([(0,r.aJ)("instruction"),(0,r.aH)("units")])},SetComputeUnitPrice:{index:3,layout:(0,r.aG)([(0,r.aJ)("instruction"),yt("microLamports")])}});class Bn{constructor(){}static requestUnits(t){const e=gt(An.RequestUnits,t);return new ut({keys:[],programId:this.programId,data:e})}static requestHeapFrame(t){const e=gt(An.RequestHeapFrame,t);return new ut({keys:[],programId:this.programId,data:e})}static setComputeUnitLimit(t){const e=gt(An.SetComputeUnitLimit,t);return new ut({keys:[],programId:this.programId,data:e})}static setComputeUnitPrice(t){const e=gt(An.SetComputeUnitPrice,{microLamports:BigInt(t.microLamports)});return new ut({keys:[],programId:this.programId,data:e})}}var In;Bn.programId=new U("ComputeBudget111111111111111111111111111111"),(0,r.aG)([(0,r.aJ)("numSignatures"),(0,r.aJ)("padding"),(0,r.aM)("signatureOffset"),(0,r.aM)("signatureInstructionIndex"),(0,r.aM)("publicKeyOffset"),(0,r.aM)("publicKeyInstructionIndex"),(0,r.aM)("messageDataOffset"),(0,r.aM)("messageDataSize"),(0,r.aM)("messageInstructionIndex")]),new U("Ed25519SigVerify111111111111111111111111111"),r.aN.utils.isValidPrivateKey,r.aN.getPublicKey,(0,r.aG)([(0,r.aJ)("numSignatures"),(0,r.aM)("signatureOffset"),(0,r.aJ)("signatureInstructionIndex"),(0,r.aM)("ethAddressOffset"),(0,r.aJ)("ethAddressInstructionIndex"),(0,r.aM)("messageDataOffset"),(0,r.aM)("messageDataSize"),(0,r.aJ)("messageInstructionIndex"),(0,r.aO)(20,"ethAddress"),(0,r.aO)(64,"signature"),(0,r.aJ)("recoveryId")]),new U("KeccakSecp256k11111111111111111111111111111"),new U("StakeConfig11111111111111111111111111111111");class xn{constructor(t,e,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=t,this.epoch=e,this.custodian=n}}In=xn,xn.default=new In(0,0,U.default),Object.freeze({Initialize:{index:0,layout:(0,r.aG)([(0,r.aH)("instruction"),function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"authorized";return(0,r.aG)([V("staker"),V("withdrawer")],t)}(),function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"lockup";return(0,r.aG)([(0,r.aI)("unixTimestamp"),(0,r.aI)("epoch"),V("custodian")],t)}()])},Authorize:{index:1,layout:(0,r.aG)([(0,r.aH)("instruction"),V("newAuthorized"),(0,r.aH)("stakeAuthorizationType")])},Delegate:{index:2,layout:(0,r.aG)([(0,r.aH)("instruction")])},Split:{index:3,layout:(0,r.aG)([(0,r.aH)("instruction"),(0,r.aI)("lamports")])},Withdraw:{index:4,layout:(0,r.aG)([(0,r.aH)("instruction"),(0,r.aI)("lamports")])},Deactivate:{index:5,layout:(0,r.aG)([(0,r.aH)("instruction")])},Merge:{index:7,layout:(0,r.aG)([(0,r.aH)("instruction")])},AuthorizeWithSeed:{index:8,layout:(0,r.aG)([(0,r.aH)("instruction"),V("newAuthorized"),(0,r.aH)("stakeAuthorizationType"),X("authoritySeed"),V("authorityOwner")])}}),new U("Stake11111111111111111111111111111111111111"),Object.freeze({InitializeAccount:{index:0,layout:(0,r.aG)([(0,r.aH)("instruction"),function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"voteInit";return(0,r.aG)([V("nodePubkey"),V("authorizedVoter"),V("authorizedWithdrawer"),(0,r.aJ)("commission")],t)}()])},Authorize:{index:1,layout:(0,r.aG)([(0,r.aH)("instruction"),V("newAuthorized"),(0,r.aH)("voteAuthorizationType")])},Withdraw:{index:3,layout:(0,r.aG)([(0,r.aH)("instruction"),(0,r.aI)("lamports")])},UpdateValidatorIdentity:{index:4,layout:(0,r.aG)([(0,r.aH)("instruction")])},AuthorizeWithSeed:{index:10,layout:(0,r.aG)([(0,r.aH)("instruction"),function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"voteAuthorizeWithSeedArgs";return(0,r.aG)([(0,r.aH)("voteAuthorizationType"),V("currentAuthorityDerivedKeyOwnerPubkey"),X("currentAuthorityDerivedKeySeed"),V("newAuthorized")],t)}()])}}),new U("Vote111111111111111111111111111111111111111"),new U("Va1idator1nfo111111111111111111111111111111"),E({name:I(),website:A(I()),details:A(I()),keybaseUsername:A(I())}),new U("Vote111111111111111111111111111111111111111"),(0,r.aG)([V("nodePubkey"),V("authorizedWithdrawer"),(0,r.aJ)("commission"),(0,r.aF)(),(0,r.aK)((0,r.aG)([(0,r.aF)("slot"),(0,r.aH)("confirmationCount")]),(0,r.aL)((0,r.aH)(),-8),"votes"),(0,r.aJ)("rootSlotValid"),(0,r.aF)("rootSlot"),(0,r.aF)(),(0,r.aK)((0,r.aG)([(0,r.aF)("epoch"),V("authorizedVoter")]),(0,r.aL)((0,r.aH)(),-8),"authorizedVoters"),(0,r.aG)([(0,r.aK)((0,r.aG)([V("authorizedPubkey"),(0,r.aF)("epochOfLastAuthorizedSwitch"),(0,r.aF)("targetEpoch")]),32,"buf"),(0,r.aF)("idx"),(0,r.aJ)("isEmpty")],"priorVoters"),(0,r.aF)(),(0,r.aK)((0,r.aG)([(0,r.aF)("epoch"),(0,r.aF)("credits"),(0,r.aF)("prevCredits")]),(0,r.aL)((0,r.aH)(),-8),"epochCredits"),(0,r.aG)([(0,r.aF)("slot"),(0,r.aF)("timestamp")],"lastTimestamp")]);const En="Solana",Cn=class t{constructor(e){o(this,"type","Native"),o(this,"address"),t.instanceof(e)?this.address=e.address:r.as.instanceof(e)?this.address=new U(e.toUint8Array()):"string"==typeof e&&r.ar.valid(e)?this.address=new U(r.ar.decode(e)):this.address=new U(e)}unwrap(){return this.address}toString(){return this.address.toBase58()}toUint8Array(){return new Uint8Array(this.address.toBytes())}toNative(){return this}toUniversalAddress(){return new r.as(this.toUint8Array())}static instanceof(e){return e.constructor.platform===t.platform}equals(e){return t.instanceof(e)?e.unwrap().equals(this.unwrap()):this.toUniversalAddress().equals(e)}};o(Cn,"byteSize",32),o(Cn,"platform",En);let Tn=Cn;(0,r.at)(En,Tn);class Pn extends s.C{async getTokenAccount(t,e){const{getAssociatedTokenAddress:r}=await n.e(7267).then(n.bind(n,7267)),s=new Tn(e).unwrap(),i=new Tn(t).unwrap(),o=await r(s,i);return{chain:this.chain,address:new Tn(o.toString())}}}const Rn=new U("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");new U("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");const Ln=new U("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new U("So11111111111111111111111111111111111111112"),new U("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");const Kn=class t extends s.P{constructor(e,n){super(e,n??(0,r.au)(e,t._platform))}getRpc(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{commitment:"confirmed",disableRetryOnRateLimit:!0};if(t in this.config)return new vn(this.config[t].rpc,e);throw new Error("No configuration available for chain: "+t)}getChain(t,e){if(t in this.config)return new Pn(t,this,e);throw new Error("No configuration available for chain: "+t)}static nativeTokenId(e,n){if(!t.isSupportedChain(n))throw new Error(`invalid chain: ${n}`);return r.av.chainAddress(n,"11111111111111111111111111111111")}static isNativeTokenId(t,e,n){return!(!this.isSupportedChain(e)||n.chain!==e)&&this.nativeTokenId(t,e)==n}static isSupportedChain(e){return(0,r.aw)(e)===t._platform}static async getDecimals(e,n,s){if((0,r.ax)(s))return(0,r.ay)(t._platform);let i=await n.getParsedAccountInfo(new Tn(s).unwrap());if(!i||!i.value)throw new Error("could not fetch token details");const{decimals:o}=i.value.data.parsed.info;return o}static async getBalance(t,e,n,s){const i=new U(n);if((0,r.ax)(s))return BigInt(await e.getBalance(i));const o=await e.getTokenAccountsByOwner(i,{mint:new Tn(s).unwrap()}),a=o.value.length>0?o.value[0].pubkey:i,c=await e.getTokenAccountBalance(a);return BigInt(c.value.amount)}static async getBalances(t,e,n,s){let i;s.includes("native")&&(i=BigInt(await e.getBalance(new U(n))));const o=await e.getParsedTokenAccountsByOwner(new U(n),{programId:new U(Rn)});return s.map((t=>{var e,n,s,a;if((0,r.ax)(t))return{native:i};const c=new Tn(t).toString(),u=null==(a=null==(s=null==(n=null==(e=o.value.find((e=>{var n,r;return(null==(r=null==(n=null==e?void 0:e.account.data.parsed)?void 0:n.info)?void 0:r.mint)===t})))?void 0:e.account.data.parsed)?void 0:n.info)?void 0:s.tokenAmount)?void 0:a.amount;return u?{[c]:BigInt(u)}:{[c]:null}})).reduce(((t,e)=>Object.assign(t,e)),{})}static async sendWait(t,e,n,r){const{blockhash:s,lastValidBlockHeight:i}=await this.latestBlock(e),o=await Promise.all(n.map((t=>e.sendRawTransaction(t,r??{preflightCommitment:e.commitment})))),a=(await Promise.all(o.map((t=>e.confirmTransaction({signature:t,blockhash:s,lastValidBlockHeight:i},e.commitment))))).filter((t=>t.value.err)).map((t=>t.value.err));if(a.length>0)throw new Error(`Failed to confirm transaction: ${a}`);return o}static async latestBlock(t,e){return t.getLatestBlockhash(e??t.commitment)}static async getLatestBlock(t){return await t.getSlot()}static async getLatestFinalizedBlock(t){const{lastValidBlockHeight:e}=await this.latestBlock(t,"finalized");return e}static chainFromChainId(e){const n=(0,r.az)(t._platform,e);if(!n)throw new Error(`No matching genesis hash to determine network and chain: ${e}`);const[s,i]=n;return[s,i]}static async chainFromRpc(e){try{const n=await e.getGenesisHash();return t.chainFromChainId(n)}catch(n){if(e.rpcEndpoint.includes("http://127")||e.rpcEndpoint.includes("http://localhost")||"http://solana-devnet:8899"===e.rpcEndpoint)return["Devnet","Solana"];throw n}}};o(Kn,"_platform",En);let On=Kn;class Nn{constructor(t,e,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];o(this,"transaction"),o(this,"network"),o(this,"chain"),o(this,"description"),o(this,"parallelizable"),this.transaction=t,this.network=e,this.chain=n,this.description=r,this.parallelizable=s}}function Hn(t){return void 0!==t.signatures&&void 0!==t.message}const Wn=.5,qn=1,Fn=1,zn=1e9,Mn=25e4;class Un{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4?arguments[4]:void 0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:5,a=arguments.length>6?arguments[6]:void 0;o(this,"_rpc"),o(this,"_chain"),o(this,"_keypair"),o(this,"_debug"),o(this,"_priorityFee"),o(this,"_maxResubmits"),o(this,"_sendOpts"),this._rpc=t,this._chain=e,this._keypair=n,this._debug=r,this._priorityFee=s,this._maxResubmits=i,this._sendOpts=a,this._sendOpts=this._sendOpts??{preflightCommitment:this._rpc.commitment}}chain(){return this._chain}address(){return this._keypair.publicKey.toBase58()}retryable(t){var e;if(t instanceof $)return!0;if(!(t instanceof xt)||!t.message.includes("Transaction simulation failed"))return!1;if(t.message.includes("Blockhash not found"))return!0;const n=null==(e=t.logs)?void 0:e.find((t=>t.startsWith("Program log: Error: ")));return!!n&&!(!n.includes("Not enough bytes")&&!n.includes("Unexpected length of input"))}async signAndSend(t){var e;let{blockhash:n,lastValidBlockHeight:r}=await On.latestBlock(this._rpc);const s=[];for(const a of t){const{description:t,transaction:{transaction:i,signers:c}}=a;let u;this._debug&&console.log(`Signing: ${t} for ${this.address()}`),null!=(e=this._priorityFee)&&e.percentile&&this._priorityFee.percentile>0&&(u=await $n(this._rpc,i,this._priorityFee.percentile,this._priorityFee.percentileMultiple,this._priorityFee.min,this._priorityFee.max)),this._debug&&Gn(i);for(let e=0;e<this._maxResubmits;e++)try{if(Hn(i)){if(u){const t=ht.decompile(i.message);t.instructions.push(...u),i.message=t.compileToV0Message()}i.message.recentBlockhash=n,i.sign([this._keypair,...c??[]])}else u&&i.add(...u),i.recentBlockhash=n,i.partialSign(this._keypair,...c??[]);this._debug&&console.log("Submitting transactions ");const t=await this._rpc.sendRawTransaction(i.serialize(),this._sendOpts);s.push(t);break}catch(o){if(e===this._maxResubmits-1||!this.retryable(o))throw o;this._debug&&console.log(`Failed to send transaction on attempt ${e}, retrying: `,o);const{blockhash:t,lastValidBlockHeight:s}=await On.latestBlock(this._rpc);r=s,n=t}}this._debug&&console.log("Waiting for confirmation for: ",s);const i=(await Promise.all(s.map((async t=>{try{return await this._rpc.confirmTransaction({signature:t,blockhash:n,lastValidBlockHeight:r},this._rpc.commitment)}catch(e){throw console.error("Failed to confirm transaction: ",e),e}})))).filter((t=>t.value.err)).map((t=>t.value.err));if(i.length>0)throw new Error(`Failed to confirm transaction: ${i}`);return s}}function Gn(t){if(Hn(t)){console.log(t.signatures);const e=t.message,n=e.getAccountKeys();e.compiledInstructions.forEach((t=>{console.log("Program",n.get(t.programIdIndex).toBase58()),console.log("Data: ",r.ar.encode(t.data)),console.log("Keys: ",t.accountKeyIndexes.map((t=>[t,n.get(t).toBase58()])))}))}else console.log(t.signatures),console.log(t.feePayer),t.instructions.forEach((t=>{console.log("Program",t.programId.toBase58()),console.log("Data: ",t.data.toString("hex")),console.log("Keys: ",t.keys.map((t=>[t,t.pubkey.toBase58()])))}))}async function $n(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Wn,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:qn,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Fn,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:zn;const[o,a]=await Promise.all([Dn(t,e),jn(t,e,n,r,s,i)]);return[Bn.setComputeUnitLimit({units:o}),Bn.setComputeUnitPrice({microLamports:a})]}async function Dn(t,e){var n;let r=Mn;try{const s=await(Hn(e),t.simulateTransaction(e));s.value.err&&console.error(`Error simulating Solana transaction: ${s.value.err}`),null!=(n=null==s?void 0:s.value)&&n.unitsConsumed&&(r=Math.round(1.2*s.value.unitsConsumed))}catch(s){console.error(`Failed to calculate compute unit limit for Solana transaction: ${s}`)}return r}async function jn(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Wn,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:qn,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Fn,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:zn,o=s,a=[];if(Hn(e)){const t=e.message,n=t.getAccountKeys();a=t.compiledInstructions.flatMap((t=>t.accountKeyIndexes)).map((e=>t.isAccountWritable(e)?n.get(e):null)).filter((t=>null!==t))}else a=e.instructions.flatMap((t=>t.keys)).map((t=>t.isWritable?t.pubkey:null)).filter((t=>null!==t));try{const e=await t.getRecentPrioritizationFees({lockedWritableAccounts:a});if(e){const t=e.map((t=>t.prioritizationFee)).sort(((t,e)=>t-e)),s=Math.ceil(t.length*n);if(t.length>s){let e=t[s];r>0&&(e*=r),o=Math.max(o,e)}}}catch(c){console.error("Error fetching Solana recent fees",c)}return Math.min(Math.max(o,s),i)}const Jn={Address:Tn,Platform:On,getSigner:async function(t,e,n){const[s,i]=await On.chainFromRpc(t),o="string"==typeof e?_n.fromSecretKey(r.aY.decode(e)):e;if(null!=n&&n.priorityFee&&n.priorityFee.percentile&&n.priorityFee.percentile>1)throw new Error("priorityFeePercentile must be a number between 0 and 1");return new Un(t,i,o,(null==n?void 0:n.debug)??!1,(null==n?void 0:n.priorityFee)??{},(null==n?void 0:n.retries)??5,null==n?void 0:n.sendOpts)},protocols:{WormholeCore:()=>n.e(4657).then(n.bind(n,4657)).then((t=>t.o)),TokenBridge:()=>Promise.all([n.e(4657),n.e(6344)]).then(n.bind(n,6344)),CircleBridge:()=>n.e(7026).then(n.bind(n,7026))},getChain:(t,e,n)=>new Pn(e,new On(t,(0,r.aC)(t,En,{[e]:n})))},Vn=Object.freeze(Object.defineProperty({__proto__:null,default:Jn},Symbol.toStringTag,{value:"Module"}))}}]);
//# sourceMappingURL=5002.1f5c9c94.chunk.js.map