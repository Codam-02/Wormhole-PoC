"use strict";(self.webpackChunkmultichain_poc=self.webpackChunkmultichain_poc||[]).push([[6446,8736],{9312:(e,t,r)=>{r.d(t,{c:()=>c});var n=r(7126);function i(e,t){switch(e.binary){case"bytes":if("layout"in e){const{custom:r}=e;return void 0===r||"function"!=typeof r.from?s(e.layout,r?r.from:t):t}case"int":case"uint":{const{custom:r}=e;return null!=e&&e.omit?void 0:(0,n.cX)(r)?r:(0,n.cY)(r)?r.to:t}case"array":return Array.isArray(t)?t.map((t=>s(e.layout,t))):void 0;case"switch":{const r=t[e.idTag??"id"],[n,i]=e.layouts.find((e=>{let[t]=e;return(Array.isArray(t)?t[1]:t)==r}));return{[e.idTag??"id"]:r,...s(i,t)}}}}function s(e,t){if(t=t??{},(0,n.cW)(e))return i(e,t);const r={};for(const n of e){const e=i(n,t[n.name]??{});void 0!==e&&(r[n.name]=e)}return r}function a(e,t){return s(e,t)}function o(e){return[...n.c_,(0,n.c$)(e)]}function c(e,t){const[r,i]=(0,n.cZ)(e),s=a(o(e),t);return{protocolName:r,payloadName:i,payloadLiteral:e,...a(n.d0,t),...s,hash:(0,n.cF)((0,n.cT)(o(e),s))}}},8736:(e,t,r)=>{r.r(t),r.d(t,{SuiWormholeCore:()=>u});var n=r(4051),i=r(7126),s=r(9312),a=r(6310),o=Object.defineProperty,c=(e,t,r)=>(((e,t,r)=>{t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r})(e,"symbol"!=typeof t?t+"":t,r),r);class u{constructor(e,t,r,n){c(this,"network"),c(this,"chain"),c(this,"provider"),c(this,"contracts"),c(this,"chainId"),c(this,"coreBridgePackageId"),this.network=e,this.chain=t,this.provider=r,this.contracts=n,this.chainId=(0,i.bW)(t);const s=n.coreBridge;if(!s)throw new Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridgePackageId=s}getGuardianSet(e){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[r,i]=await n.S.chainFromRpc(e),s=t[i];if(s.network!==r)throw new Error(`Network mismatch: ${s.network} !== ${r}`);return new u(r,i,e,s.contracts)}async*verifyMessage(e,t){throw new Error("Method not implemented.")}async*publishMessage(e,t){throw new Error("Method not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map((e=>({emitter:e.emitterAddress,sequence:e.sequence,chain:this.chain})))}async getGuardianSetIndex(){throw new Error("Method not implemented.")}async parseMessages(e){var t;const r=null==(t=(await this.provider.getTransactionBlock({digest:e,options:{showEvents:!0,showEffects:!0,showInput:!0}})).events)?void 0:t.filter((e=>e.type.endsWith("WormholeMessage")));if(!r||0==r.length)throw new Error("WormholeMessage not found");return r.map((e=>{const t=e.parsedJson;return(0,s.c)("Uint8Array",{emitterChain:this.chain,emitterAddress:new n.o(t.sender).toUniversalAddress(),sequence:BigInt(t.sequence),guardianSet:0,timestamp:Number(t.timestamp),consistencyLevel:t.consistency_level,nonce:t.nonce,signatures:[],payload:new Uint8Array(t.payload)})}))}}(0,a.r)(n._,"WormholeCore",u)},6446:(e,t,r)=>{r.r(t),r.d(t,{SuiTokenBridge:()=>Hr,getTokenCoinType:()=>Xr,getTokenFromTokenRegistry:()=>qr});var n=r(7126),i=r(4051),s=(r(8736),r(6310)),a=Object.defineProperty,o=(e,t,r)=>(((e,t,r)=>{t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r})(e,"symbol"!=typeof t?t+"":t,r),r);class c{constructor(e,t,r,n){let i=arguments.length>4&&void 0!==arguments[4]&&arguments[4];o(this,"transaction"),o(this,"network"),o(this,"chain"),o(this,"description"),o(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=r,this.description=n,this.parallelizable=i}}class u extends TypeError{constructor(e,t){let r;const{message:n,explanation:i,...s}=e,{path:a}=e,o=0===a.length?n:`At path: ${a.join(".")} -- ${n}`;super(i??o),null!=i&&(this.cause=o),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>r??(r=[e,...t()])}}function d(e){return"object"==typeof e&&null!=e}function l(e){return"symbol"==typeof e?e.toString():"string"==typeof e?JSON.stringify(e):`${e}`}function f(e,t,r,n){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:i,branch:s}=t,{type:a}=r,{refinement:o,message:c=`Expected a value of type \`${a}\`${o?` with refinement \`${o}\``:""}, but received: \`${l(n)}\``}=e;return{value:n,type:a,refinement:o,key:i[i.length-1],path:i,branch:s,...e,message:c}}function*h(e,t,r,n){(function(e){return d(e)&&"function"==typeof e[Symbol.iterator]})(e)||(e=[e]);for(const i of e){const e=f(i,t,r,n);e&&(yield e)}}function p(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return function*(){const{path:n=[],branch:i=[e],coerce:s=!1,mask:a=!1}=r,o={path:n,branch:i};if(s&&(e=t.coercer(e,o),a&&"type"!==t.type&&d(t.schema)&&d(e)&&!Array.isArray(e)))for(const r in e)void 0===t.schema[r]&&delete e[r];let c="valid";for(const u of t.validator(e,o))u.explanation=r.message,c="not_valid",yield[u,void 0];for(let[u,l,f]of t.entries(e,o)){const t=p(l,f,{path:void 0===u?n:[...n,u],branch:void 0===u?i:[...i,l],coerce:s,mask:a,message:r.message});for(const r of t)r[0]?(c=null!=r[0].refinement?"not_refined":"not_valid",yield[r[0],void 0]):s&&(l=r[1],void 0===u?e=l:e instanceof Map?e.set(u,l):e instanceof Set?e.add(l):d(e)&&(void 0!==l||u in e)&&(e[u]=l))}if("not_valid"!==c)for(const u of t.refiner(e,o))u.explanation=r.message,c="not_refined",yield[u,void 0];"valid"===c&&(yield[void 0,e])}()}class g{constructor(e){const{type:t,schema:r,validator:n,refiner:i,coercer:s=e=>e,entries:a=function*(){}}=e;this.type=t,this.schema=r,this.entries=a,this.coercer=s,this.validator=n?(e,t)=>h(n(e,t),t,this,e):()=>[],this.refiner=i?(e,t)=>h(i(e,t),t,this,e):()=>[]}assert(e,t){return m(e,this,t)}create(e,t){return y(e,this,t)}is(e){return b(e,this)}mask(e,t){return w(e,this,t)}validate(e){return v(e,this,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{})}}function m(e,t,r){const n=v(e,t,{message:r});if(n[0])throw n[0]}function y(e,t,r){const n=v(e,t,{coerce:!0,message:r});if(n[0])throw n[0];return n[1]}function w(e,t,r){const n=v(e,t,{coerce:!0,mask:!0,message:r});if(n[0])throw n[0];return n[1]}function b(e,t){return!v(e,t)[0]}function v(e,t){const r=p(e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}),n=function(e){const{done:t,value:r}=e.next();return t?void 0:r}(r);return n[0]?[new u(n[0],(function*(){for(const e of r)e[0]&&(yield e[0])})),void 0]:[void 0,n[1]]}function j(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];const n="type"===t[0].type,i=t.map((e=>e.schema)),s=Object.assign({},...i);return n?function(e){const t=Object.keys(e);return new g({type:"type",schema:e,*entries(r){if(d(r))for(const n of t)yield[n,r[n],e[n]]},validator:e=>d(e)||`Expected an object, but received: ${l(e)}`,coercer:e=>d(e)?{...e}:e})}(s):B(s)}function T(e,t){return new g({type:e,schema:null,validator:t})}function S(){return T("any",(()=>!0))}function E(e){return new g({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,n]of t.entries())yield[r,n,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${l(e)}`})}function k(){return T("boolean",(e=>"boolean"==typeof e))}function x(){return T("integer",(e=>"number"==typeof e&&!isNaN(e)&&Number.isInteger(e)||`Expected an integer, but received: ${l(e)}`))}function A(e){const t=l(e),r=typeof e;return new g({type:"literal",schema:"string"===r||"number"===r||"boolean"===r?e:null,validator:r=>r===e||`Expected the literal \`${t}\`, but received: ${l(r)}`})}function I(){return T("never",(()=>!1))}function O(e){return new g({...e,validator:(t,r)=>null===t||e.validator(t,r),refiner:(t,r)=>null===t||e.refiner(t,r)})}function $(){return T("number",(e=>"number"==typeof e&&!isNaN(e)||`Expected a number, but received: ${l(e)}`))}function B(e){const t=e?Object.keys(e):[],r=I();return new g({type:"object",schema:e||null,*entries(n){if(e&&d(n)){const i=new Set(Object.keys(n));for(const r of t)i.delete(r),yield[r,n[r],e[r]];for(const e of i)yield[e,n[e],r]}},validator:e=>d(e)||`Expected an object, but received: ${l(e)}`,coercer:e=>d(e)?{...e}:e})}function U(e){return new g({...e,validator:(t,r)=>void 0===t||e.validator(t,r),refiner:(t,r)=>void 0===t||e.refiner(t,r)})}function C(e,t){return new g({type:"record",schema:null,*entries(r){if(d(r))for(const n in r){const i=r[n];yield[n,n,e],yield[n,i,t]}},validator:e=>d(e)||`Expected an object, but received: ${l(e)}`})}function z(){return T("string",(e=>"string"==typeof e||`Expected a string, but received: ${l(e)}`))}function _(e){const t=I();return new g({type:"tuple",schema:null,*entries(r){if(Array.isArray(r)){const n=Math.max(e.length,r.length);for(let i=0;i<n;i++)yield[i,r[i],e[i]||t]}},validator:e=>Array.isArray(e)||`Expected an array, but received: ${l(e)}`})}function M(e){const t=e.map((e=>e.type)).join(" | ");return new g({type:"union",schema:null,coercer(t){for(const r of e){const[e,n]=r.validate(t,{coerce:!0});if(!e)return n}return t},validator(r,n){const i=[];for(const t of e){const[...e]=p(r,t,n),[s]=e;if(!s[0])return[];for(const[t]of e)t&&i.push(t)}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${l(r)}`,...i]}})}function P(){return T("unknown",(()=>!0))}const N=M([B({AddressOwner:z()}),B({ObjectOwner:z()}),B({Shared:B({initial_shared_version:O(z())})}),A("Immutable")]);T("SuiJsonValue",(()=>!0));const V=M([B({u32:z()}),B({u64:z()}),B({f64:z()})]);B({attributes:C(z(),O(V)),featureFlags:C(z(),k()),maxSupportedProtocolVersion:z(),minSupportedProtocolVersion:z(),protocolVersion:z()}),M([z(),A("package")]);const R=B({digest:z(),objectId:z(),version:M([$(),z(),T("bigint",(e=>"bigint"==typeof e))])});B({owner:N,reference:R}),B({objectId:z(),sequenceNumber:z()}),B({payment:E(R),owner:z(),price:z(),budget:z()});const D=j(R,B({type:z(),owner:N,previousTransaction:z()})),W=C(z(),S()),F=C(z(),P()),G=B({type:z(),fields:W,hasPublicTransfer:k()}),K=B({disassembled:F}),L=M([j(G,B({dataType:A("moveObject")})),j(K,B({dataType:A("package")}))]),J=B({type:z(),hasPublicTransfer:k(),version:z(),bcsBytes:z()}),q=B({id:z(),moduleMap:C(z(),z())}),X=M([j(J,B({dataType:A("moveObject")})),j(q,B({dataType:A("package")}))]);BigInt(1e9);const H=B({code:z(),error:U(z()),object_id:U(z()),parent_object_id:U(z()),version:U(z()),digest:U(z())}),Z=M([B({data:O(U(C(z(),z()))),error:O(U(H))}),U(C(z(),z()))]),Y=B({objectId:z(),version:z(),digest:z(),type:O(U(z())),content:O(U(L)),bcs:O(U(X)),owner:O(U(N)),previousTransaction:O(U(z())),storageRebate:O(U(z())),display:O(U(Z))});B({showType:O(U(k())),showContent:O(U(k())),showBcs:O(U(k())),showOwner:O(U(k())),showPreviousTransaction:O(U(k())),showStorageRebate:O(U(k())),showDisplay:O(U(k()))}),M([A("Exists"),A("notExists"),A("Deleted")]),E(D);const Q=B({data:O(U(Y)),error:O(U(H))});function ee(e){if("reference"in e)return e.reference;const t=function(e){return e.data}(e);return t?{objectId:t.objectId,version:t.version,digest:t.digest}:function(e){if(e.error&&"object_id"in e.error&&"version"in e.error&&"digest"in e.error){const t=e.error;return{objectId:t.object_id,version:t.version,digest:t.digest}}}(e)}B({objectId:z(),atCheckpoint:U($())}),B({data:E(Q),nextCursor:U(O(z())),hasNextPage:k()}),M([B({details:Y,status:A("VersionFound")}),B({details:z(),status:A("ObjectNotExists")}),B({details:R,status:A("ObjectDeleted")}),B({details:_([z(),$()]),status:A("VersionNotFound")}),B({details:B({asked_version:$(),latest_version:$(),object_id:z()}),status:A("VersionTooHigh")})]);E(M([z(),B({Object:z()})]));const te=B({address:z(),name:z()}),re=M([A("Private"),A("Public"),A("Friend")]),ne=B({abilities:E(z())}),ie=B({constraints:ne,isPhantom:k()}),se=B({TypeParameter:$()}),ae=_([B({module:z(),package:z(),function:z()}),z()]);function oe(e){if(!e)return!1;if("string"==typeof e||b(e,se)||ue(e))return!0;if("object"!=typeof e)return!1;const t=e;return!!(b(t.Reference,ce)||b(t.MutableReference,ce)||b(t.Vector,ce))}B({rank3Days:E(ae),rank7Days:E(ae),rank30Days:E(ae)});const ce=T("SuiMoveNormalizedType",oe);function ue(e){if(!e||"object"!=typeof e)return!1;const t=e;if(!t.Struct||"object"!=typeof t.Struct)return!1;const r=t.Struct;return!("string"!=typeof r.address||"string"!=typeof r.module||"string"!=typeof r.name||!Array.isArray(r.typeArguments)||!r.typeArguments.every((e=>oe(e))))}T("SuiMoveNormalizedStructType",ue);const de=B({visibility:re,isEntry:k(),typeParameters:E(ne),parameters:E(ce),return:E(ce)}),le=B({name:z(),type:ce}),fe=B({abilities:ne,typeParameters:E(ie),fields:E(le)}),he=B({fileFormatVersion:$(),address:z(),name:z(),friends:E(te),structs:C(z(),fe),exposedFunctions:C(z(),de)});function pe(e){return"object"==typeof e&&"MutableReference"in e?e.MutableReference:void 0}function ge(e){return"object"==typeof e&&"Reference"in e?e.Reference:void 0}function me(e){if("object"==typeof e&&"Struct"in e)return e;const t=ge(e),r=pe(e);return"object"==typeof t&&"Struct"in t?t:"object"==typeof r&&"Struct"in r?r:void 0}C(z(),he);var ye=function(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<e.length;n++){var i=e.charAt(n),s=i.charCodeAt(0);if(255!==t[s])throw new TypeError(i+" is ambiguous");t[s]=n}var a=e.length,o=e.charAt(0),c=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function d(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;for(var r=0,n=0,i=0;e[r]===o;)n++,r++;for(var s=(e.length-r)*c+1>>>0,u=new Uint8Array(s);e[r];){var d=t[e.charCodeAt(r)];if(255===d)return;for(var l=0,f=s-1;(0!==d||l<i)&&-1!==f;f--,l++)d+=a*u[f]>>>0,u[f]=d%256>>>0,d=d/256>>>0;if(0!==d)throw new Error("Non-zero carry");i=l,r++}for(var h=s-i;h!==s&&0===u[h];)h++;for(var p=new Uint8Array(n+(s-h)),g=n;h!==s;)p[g++]=u[h++];return p}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,i=0,s=t.length;i!==s&&0===t[i];)i++,r++;for(var c=(s-i)*u+1>>>0,d=new Uint8Array(c);i!==s;){for(var l=t[i],f=0,h=c-1;(0!==l||f<n)&&-1!==h;h--,f++)l+=256*d[h]>>>0,d[h]=l%a>>>0,l=l/a>>>0;if(0!==l)throw new Error("Non-zero carry");n=f,i++}for(var p=c-n;p!==c&&0===d[p];)p++;for(var g=o.repeat(r);p<c;++p)g+=e.charAt(d[p]);return g},decodeUnsafe:d,decode:function(e){var t=d(e);if(t)return t;throw new Error("Non-base"+a+" character")}}};var we=ye("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");const be=(0,n.g)(we),ve=e=>be.encode(e),je=e=>be.decode(e);function Te(e){return Uint8Array.from(atob(e),(e=>e.charCodeAt(0)))}const Se=8192;function Ee(e){if(e.length<Se)return btoa(String.fromCharCode(...e));let t="";for(var r=0;r<e.length;r+=Se){const n=e.slice(r,r+Se);t+=String.fromCharCode(...n)}return btoa(t)}function ke(e){var t;const r=e.startsWith("0x")?e.slice(2):e,n=(null==(t=(r.length%2===0?r:`0${r}}`).match(/.{2}/g))?void 0:t.map((e=>parseInt(e,16))))??[];return Uint8Array.from(n)}function xe(e){return e.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),"")}function Ae(e){let t=[],r=0;if(0===e)return[0];for(;e>0;)t[r]=127&e,(e>>=7)&&(t[r]|=128),r+=1;return t}class Ie{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer)}shift(e){return this.bytePosition+=e,this}read8(){let e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){let e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){let e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){let e=this.read32(),t=this.read32().toString(16)+e.toString(16).padStart(8,"0");return BigInt("0x"+t).toString(10)}read128(){let e=BigInt(this.read64()),t=BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0");return BigInt("0x"+t).toString(10)}read256(){let e=BigInt(this.read128()),t=BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0");return BigInt("0x"+t).toString(10)}readBytes(e){let t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t,e);return this.shift(e),r}readULEB(){let e=this.bytePosition+this.dataView.byteOffset,t=new Uint8Array(this.dataView.buffer,e),{value:r,length:n}=function(e){let t=0,r=0,n=0;for(;;){let i=e[n];if(n+=1,t|=(127&i)<<r,!(128&i))break;r+=7}return{value:t,length:n}}(t);return this.shift(n),r}readVec(e){let t=this.readULEB(),r=[];for(let n=0;n<t;n++)r.push(e(this,n,t));return r}}function Oe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:["<",">"];const[r,n]=t,i=[];let s="",a=0;for(let o=0;o<e.length;o++){const t=e[o];(t===r&&a++,t===n&&a--,0!==a||","!==t)?s+=t:(i.push(s.trim()),s="")}return i.push(s.trim()),i}class $e{constructor(){let{size:e=1024,maxSize:t,allocateSize:r=1024}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.bytePosition=0,this.size=e,this.maxSize=t||e,this.allocateSize=r,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){const t=this.bytePosition+e;if(t>this.size){const e=Math.min(this.maxSize,this.size+this.allocateSize);if(t>e)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`);this.size=e;const r=new ArrayBuffer(this.size);new Uint8Array(r).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(r)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return Be(BigInt(e),8).forEach((e=>this.write8(e))),this}write128(e){return Be(BigInt(e),16).forEach((e=>this.write8(e))),this}write256(e){return Be(BigInt(e),32).forEach((e=>this.write8(e))),this}writeULEB(e){return Ae(e).forEach((e=>this.write8(e))),this}writeVec(e,t){return this.writeULEB(e.length),Array.from(e).forEach(((r,n)=>t(this,r,n,e.length))),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return function(e,t){switch(t){case"base58":return ve(e);case"base64":return Ee(e);case"hex":return xe(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}(this.toBytes(),e)}}function Be(e,t){let r=new Uint8Array(t),n=0;for(;e>0;)r[n]=Number(e%BigInt(256)),e/=BigInt(256),n+=1;return r}var Ue,Ce,ze,_e,Me=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},Pe=(e,t,r)=>(Me(e,t,"read from private field"),r?r.call(e):t.get(e)),Ne=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},Ve=(e,t,r,n)=>(Me(e,t,"write to private field"),t.set(e,r),r);const Re=class{constructor(e){Ne(this,Ue,void 0),Ne(this,Ce,void 0),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),Ve(this,Ue,e.write),Ve(this,Ce,e.serialize??((e,t)=>{const r=new $e({size:this.serializedSize(e)??void 0,...t});return Pe(this,Ue).call(this,e,r),r.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),Pe(this,Ue).call(this,e,t)}serialize(e,t){return this.validate(e),new Ge(this,Pe(this,Ce).call(this,e,t))}parse(e){const t=new Ie(e);return this.read(t)}transform(e){let{name:t,input:r,output:n}=e;return new Re({name:t??this.name,read:e=>n(this.read(e)),write:(e,t)=>Pe(this,Ue).call(this,r(e),t),serializedSize:e=>this.serializedSize(r(e)),serialize:(e,t)=>Pe(this,Ce).call(this,r(e),t),validate:e=>this.validate(r(e))})}};let De=Re;Ue=new WeakMap,Ce=new WeakMap;const We=Symbol.for("@mysten/serialized-bcs");function Fe(e){return!!e&&"object"==typeof e&&!0===e[We]}class Ge{constructor(e,t){Ne(this,ze,void 0),Ne(this,_e,void 0),Ve(this,ze,e),Ve(this,_e,t)}get[We](){return!0}toBytes(){return Pe(this,_e)}toHex(){return xe(Pe(this,_e))}toBase64(){return Ee(Pe(this,_e))}toBase58(){return ve(Pe(this,_e))}parse(){return Pe(this,ze).parse(Pe(this,_e))}}function Ke(e){let{size:t,...r}=e;return new De({...r,serializedSize:()=>t})}function Le(e){let{readMethod:t,writeMethod:r,...n}=e;return Ke({...n,read:e=>e[t](),write:(e,t)=>t[r](e),validate:e=>{var t;if(e<0||e>n.maxValue)throw new TypeError(`Invalid ${n.name} value: ${e}. Expected value in range 0-${n.maxValue}`);null==(t=n.validate)||t.call(n,e)}})}function Je(e){let{readMethod:t,writeMethod:r,...n}=e;return Ke({...n,read:e=>e[t](),write:(e,t)=>t[r](BigInt(e)),validate:e=>{var t;const r=BigInt(e);if(r<0||r>n.maxValue)throw new TypeError(`Invalid ${n.name} value: ${r}. Expected value in range 0-${n.maxValue}`);null==(t=n.validate)||t.call(n,r)}})}ze=new WeakMap,_e=new WeakMap;const qe={u8:e=>Le({name:"u8",readMethod:"read8",writeMethod:"write8",size:1,maxValue:255,...e}),u16:e=>Le({name:"u16",readMethod:"read16",writeMethod:"write16",size:2,maxValue:65535,...e}),u32:e=>Le({name:"u32",readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...e}),u64:e=>Je({name:"u64",readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...e}),u128:e=>Je({name:"u128",readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...e}),u256:e=>Je({name:"u256",readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...e}),bool:e=>Ke({name:"bool",size:1,read:e=>1===e.read8(),write:(e,t)=>t.write8(e?1:0),...e,validate:t=>{var r;if(null==(r=null==e?void 0:e.validate)||r.call(e,t),"boolean"!=typeof t)throw new TypeError("Expected boolean, found "+typeof t)}}),uleb128:e=>function(e){let{serialize:t,...r}=e;const n=new De({...r,serialize:t,write:(e,t)=>{for(const r of n.serialize(e).toBytes())t.write8(r)}});return n}({name:"uleb128",read:e=>e.readULEB(),serialize:e=>Uint8Array.from(Ae(e)),...e}),bytes:(e,t)=>Ke({name:`bytes[${e}]`,size:e,read:t=>t.readBytes(e),write:(t,r)=>{for(let n=0;n<e;n++)r.write8(t[n]??0)},...t,validate:r=>{var n;if(null==(n=null==t?void 0:t.validate)||n.call(t,r),!("length"in r))throw new TypeError("Expected array, found "+typeof r);if(r.length!==e)throw new TypeError(`Expected array of length ${e}, found ${r.length}`)}}),string:e=>function(e){let{toBytes:t,fromBytes:r,...n}=e;return new De({...n,read:e=>{const t=e.readULEB(),n=e.readBytes(t);return r(n)},write:(e,r)=>{const n=t(e);r.writeULEB(n.length);for(let t=0;t<n.length;t++)r.write8(n[t])},serialize:e=>{const r=t(e),n=Ae(r.length),i=new Uint8Array(n.length+r.length);return i.set(n,0),i.set(r,n.length),i},validate:e=>{var t;if("string"!=typeof e)throw new TypeError(`Invalid ${n.name} value: ${e}. Expected string`);null==(t=n.validate)||t.call(n,e)}})}({name:"string",toBytes:e=>(new TextEncoder).encode(e),fromBytes:e=>(new TextDecoder).decode(e),...e}),fixedArray:(e,t,r)=>new De({name:`${t.name}[${e}]`,read:r=>{const n=new Array(e);for(let i=0;i<e;i++)n[i]=t.read(r);return n},write:(e,r)=>{for(const n of e)t.write(n,r)},...r,validate:t=>{var n;if(null==(n=null==r?void 0:r.validate)||n.call(r,t),!("length"in t))throw new TypeError("Expected array, found "+typeof t);if(t.length!==e)throw new TypeError(`Expected array of length ${e}, found ${t.length}`)}}),option:e=>qe.enum(`Option<${e.name}>`,{None:null,Some:e}).transform({input:e=>null==e?{None:!0}:{Some:e},output:e=>"Some"in e?e.Some:null}),vector:(e,t)=>new De({name:`vector<${e.name}>`,read:t=>{const r=t.readULEB(),n=new Array(r);for(let i=0;i<r;i++)n[i]=e.read(t);return n},write:(t,r)=>{r.writeULEB(t.length);for(const n of t)e.write(n,r)},...t,validate:e=>{var r;if(null==(r=null==t?void 0:t.validate)||r.call(t,e),!("length"in e))throw new TypeError("Expected array, found "+typeof e)}}),tuple:(e,t)=>new De({name:`(${e.map((e=>e.name)).join(", ")})`,serializedSize:t=>{let r=0;for(let n=0;n<e.length;n++){const i=e[n].serializedSize(t[n]);if(null==i)return null;r+=i}return r},read:t=>{const r=[];for(const n of e)r.push(n.read(t));return r},write:(t,r)=>{for(let n=0;n<e.length;n++)e[n].write(t[n],r)},...t,validate:r=>{var n;if(null==(n=null==t?void 0:t.validate)||n.call(t,r),!Array.isArray(r))throw new TypeError("Expected array, found "+typeof r);if(r.length!==e.length)throw new TypeError(`Expected array of length ${e.length}, found ${r.length}`)}}),struct(e,t,r){const n=Object.entries(t);return new De({name:e,serializedSize:e=>{let t=0;for(const[r,i]of n){const n=i.serializedSize(e[r]);if(null==n)return null;t+=n}return t},read:e=>{const t={};for(const[r,i]of n)t[r]=i.read(e);return t},write:(e,t)=>{for(const[r,i]of n)i.write(e[r],t)},...r,validate:e=>{var t;if(null==(t=null==r?void 0:r.validate)||t.call(r,e),"object"!=typeof e||null==e)throw new TypeError("Expected object, found "+typeof e)}})},enum(e,t,r){const n=Object.entries(t);return new De({name:e,read:e=>{const t=e.readULEB(),[r,i]=n[t];return{[r]:(null==i?void 0:i.read(e))??!0}},write:(e,t)=>{const[r,i]=Object.entries(e)[0];for(let s=0;s<n.length;s++){const[e,a]=n[s];if(e===r)return t.writeULEB(s),void(null==a||a.write(i,t))}},...r,validate:e=>{var n;if(null==(n=null==r?void 0:r.validate)||n.call(r,e),"object"!=typeof e||null==e)throw new TypeError("Expected object, found "+typeof e);const i=Object.keys(e);if(1!==i.length)throw new TypeError(`Expected object with one key, found ${i.length}`);const[s]=i;if(!Object.hasOwn(t,s))throw new TypeError(`Invalid enum variant ${s}`)}})},map:(e,t)=>qe.vector(qe.tuple([e,t])).transform({name:`Map<${e.name}, ${t.name}>`,input:e=>[...e.entries()],output:e=>{const t=new Map;for(const[r,n]of e)t.set(r,n);return t}}),generic:(e,t)=>function(){for(var e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];return t(...r).transform({name:`${t.name}<${r.map((e=>e.name)).join(", ")}>`,input:e=>e,output:e=>e})},lazy:e=>function(e){let t=null;function r(){return t||(t=e()),t}return new De({name:"lazy",read:e=>r().read(e),serializedSize:e=>r().serializedSize(e),write:(e,t)=>r().write(e,t),serialize:(e,t)=>r().serialize(e,t).toBytes()})}(e)},Xe=class{constructor(e){if(this.types=new Map,this.counter=0,e instanceof Xe)return this.schema=e.schema,void(this.types=new Map(e.types));if(this.schema=e,this.registerAddressType(Xe.ADDRESS,e.addressLength,e.addressEncoding),this.registerVectorType(e.vectorType),e.types&&e.types.structs)for(let t of Object.keys(e.types.structs))this.registerStructType(t,e.types.structs[t]);if(e.types&&e.types.enums)for(let t of Object.keys(e.types.enums))this.registerEnumType(t,e.types.enums[t]);if(e.types&&e.types.aliases)for(let t of Object.keys(e.types.aliases))this.registerAlias(t,e.types.aliases[t]);!1!==e.withPrimitives&&function(e){e.registerType(He.U8,(function(e,t){return e.write8(t)}),(function(e){return e.read8()}),(e=>e<256)),e.registerType(He.U16,(function(e,t){return e.write16(t)}),(function(e){return e.read16()}),(e=>e<65536)),e.registerType(He.U32,(function(e,t){return e.write32(t)}),(function(e){return e.read32()}),(e=>e<=4294967296n)),e.registerType(He.U64,(function(e,t){return e.write64(t)}),(function(e){return e.read64()})),e.registerType(He.U128,(function(e,t){return e.write128(t)}),(function(e){return e.read128()})),e.registerType(He.U256,(function(e,t){return e.write256(t)}),(function(e){return e.read256()})),e.registerType(He.BOOL,(function(e,t){return e.write8(t)}),(function(e){return"1"===e.read8().toString(10)})),e.registerType(He.STRING,(function(e,t){return e.writeVec(Array.from(t),((e,t)=>e.write8(t.charCodeAt(0))))}),(function(e){return e.readVec((e=>e.read8())).map((e=>String.fromCharCode(Number(e)))).join("")}),(e=>!0)),e.registerType(He.HEX,(function(e,t){return e.writeVec(Array.from(ke(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return xe(new Uint8Array(t))})),e.registerType(He.BASE58,(function(e,t){return e.writeVec(Array.from(je(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return ve(new Uint8Array(t))})),e.registerType(He.BASE64,(function(e,t){return e.writeVec(Array.from(Te(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return Ee(new Uint8Array(t))}))}(this)}tempKey(){return"bcs-struct-"+ ++this.counter}ser(e,t,r){if("string"==typeof e||Array.isArray(e)){const{name:n,params:i}=this.parseTypeName(e);return this.getTypeInterface(n).encode(this,t,r,i)}if("object"==typeof e){const n=this.tempKey();return new Xe(this).registerStructType(n,e).ser(n,t,r)}throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(e)}`)}de(e,t,r){if("string"==typeof t){if(!r)throw new Error("To pass a string to `bcs.de`, specify encoding");t=function(e,t){switch(t){case"base58":return je(e);case"base64":return Te(e);case"hex":return ke(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}(t,r)}if("string"==typeof e||Array.isArray(e)){const{name:r,params:n}=this.parseTypeName(e);return this.getTypeInterface(r).decode(this,t,n)}if("object"==typeof e){const n=new Xe(this),i=this.tempKey();return n.registerStructType(i,e).de(i,t,r)}throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(e)}`)}hasType(e){return this.types.has(e)}registerAlias(e,t){return this.types.set(e,t),this}registerType(e,t,r){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:()=>!0;const{name:i,params:s}=this.parseTypeName(e);return this.types.set(i,{encode(e,t,r,n){const i=s.reduce(((e,t,r)=>Object.assign(e,{[t]:n[r]})),{});return this._encodeRaw.call(e,new $e(r),t,n,i)},decode(e,t,r){const n=s.reduce(((e,t,n)=>Object.assign(e,{[t]:r[n]})),{});return this._decodeRaw.call(e,new Ie(t),r,n)},_encodeRaw(e,r,s,a){if(n(r))return t.call(this,e,r,s,a);throw new Error(`Validation failed for type ${i}, data: ${r}`)},_decodeRaw(e,t,n){return r.call(this,e,t,n)}}),this}registerBcsType(e,t){return this.registerType(e,((e,r,n)=>{const i=n.map((e=>new De({name:String(e),write:(t,r)=>{const{name:i,params:s}=this.parseTypeName(e),a=this.getTypeInterface(i),o=s.reduce(((e,t,r)=>Object.assign(e,{[t]:n[r]})),{});return a._encodeRaw.call(this,r,t,s,o)},read:()=>{throw new Error("Not implemented")}})));return t(...i).write(r,e),e}),((e,r)=>{const n=r.map((e=>new De({name:String(e),write:(e,t)=>{throw new Error("Not implemented")},read:t=>{const{name:n,params:i}=this.parseTypeName(e),s=this.getTypeInterface(n),a=i.reduce(((e,t,n)=>Object.assign(e,{[t]:r[n]})),{});return s._decodeRaw.call(this,t,i,a)}})));return t(...n).read(e)})),this}registerAddressType(e,t){switch(arguments.length>2&&void 0!==arguments[2]?arguments[2]:"hex"){case"base64":return this.registerType(e,(function(e,t){return Te(t).reduce(((e,t)=>e.write8(t)),e)}),(function(e){return Ee(e.readBytes(t))}));case"hex":return this.registerType(e,(function(e,t){return ke(t).reduce(((e,t)=>e.write8(t)),e)}),(function(e){return xe(e.readBytes(t))}));default:throw new Error("Unsupported encoding! Use either hex or base64")}}registerVectorType(e){let{name:t,params:r}=this.parseTypeName(e);if(r.length>1)throw new Error("Vector can have only one type parameter; got "+t);return this.registerType(e,(function(t,r,n,i){return t.writeVec(r,((t,r)=>{let s=n[0];if(!s)throw new Error(`Incorrect number of type parameters passed a to vector '${e}'`);let{name:a,params:o}=this.parseTypeName(s);if(this.hasType(a))return this.getTypeInterface(a)._encodeRaw.call(this,t,r,o,i);if(!(a in i))throw new Error(`Unable to find a matching type definition for ${a} in vector; make sure you passed a generic`);let{name:c,params:u}=this.parseTypeName(i[a]);return this.getTypeInterface(c)._encodeRaw.call(this,t,r,u,i)}))}),(function(t,r,n){return t.readVec((t=>{let i=r[0];if(!i)throw new Error(`Incorrect number of type parameters passed to a vector '${e}'`);let{name:s,params:a}=this.parseTypeName(i);if(this.hasType(s))return this.getTypeInterface(s)._decodeRaw.call(this,t,a,n);if(!(s in n))throw new Error(`Unable to find a matching type definition for ${s} in vector; make sure you passed a generic`);let{name:o,params:c}=this.parseTypeName(n[s]);return this.getTypeInterface(o)._decodeRaw.call(this,t,c,n)}))}))}registerStructType(e,t){for(let a in t){let e=this.tempKey(),r=t[a];!Array.isArray(r)&&"string"!=typeof r&&(t[a]=e,this.registerStructType(e,r))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,a,o){if(!t||t.constructor!==Object)throw new Error(`Expected ${i} to be an Object, got: ${t}`);if(a.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${a.length}`);for(let c of n){if(!(c in t))throw new Error(`Struct ${i} requires field ${c}:${r[c]}`);const{name:n,params:u}=this.parseTypeName(r[c]);if(s.includes(n)){const r=s.indexOf(n);let{name:u,params:d}=this.parseTypeName(a[r]);if(this.hasType(u)){this.getTypeInterface(u)._encodeRaw.call(this,e,t[c],d,o);continue}if(!(u in o))throw new Error(`Unable to find a matching type definition for ${u} in ${i}; make sure you passed a generic`);let{name:l,params:f}=this.parseTypeName(o[u]);this.getTypeInterface(l)._encodeRaw.call(this,e,t[c],f,o)}else this.getTypeInterface(n)._encodeRaw.call(this,e,t[c],u,o)}return e}),(function(e,t,a){if(t.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${t.length}`);let o={};for(let c of n){const{name:n,params:u}=this.parseTypeName(r[c]);if(s.includes(n)){const r=s.indexOf(n);let{name:u,params:d}=this.parseTypeName(t[r]);if(this.hasType(u)){o[c]=this.getTypeInterface(u)._decodeRaw.call(this,e,d,a);continue}if(!(u in a))throw new Error(`Unable to find a matching type definition for ${u} in ${i}; make sure you passed a generic`);let{name:l,params:f}=this.parseTypeName(a[u]);o[c]=this.getTypeInterface(l)._decodeRaw.call(this,e,f,a)}else o[c]=this.getTypeInterface(n)._decodeRaw.call(this,e,u,a)}return o}))}registerEnumType(e,t){for(let a in t){let e=this.tempKey(),r=t[a];null!==r&&!Array.isArray(r)&&"string"!=typeof r&&(t[a]=e,this.registerStructType(e,r))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,a,o){if(!t)throw new Error(`Unable to write enum "${i}", missing data.\nReceived: "${t}"`);if("object"!=typeof t)throw new Error(`Incorrect data passed into enum "${i}", expected object with properties: "${n.join(" | ")}".\nReceived: "${JSON.stringify(t)}"`);let c=Object.keys(t)[0];if(void 0===c)throw new Error(`Empty object passed as invariant of the enum "${i}"`);let u=n.indexOf(c);if(-1===u)throw new Error(`Unknown invariant of the enum "${i}", allowed values: "${n.join(" | ")}"; received "${c}"`);let d=n[u],l=r[d];if(e.write8(u),null===l)return e;let f=s.indexOf(l),h=-1===f?l:a[f];{let{name:r,params:n}=this.parseTypeName(h);return this.getTypeInterface(r)._encodeRaw.call(this,e,t[c],n,o)}}),(function(e,t,a){let o=e.readULEB(),c=n[o],u=r[c];if(-1===o)throw new Error(`Decoding type mismatch, expected enum "${i}" invariant index, received "${o}"`);if(null===u)return{[c]:!0};let d=s.indexOf(u),l=-1===d?u:t[d];{let{name:t,params:r}=this.parseTypeName(l);return{[c]:this.getTypeInterface(t)._decodeRaw.call(this,e,r,a)}}}))}getTypeInterface(e){let t=this.types.get(e);if("string"==typeof t){let e=[];for(;"string"==typeof t;){if(e.includes(t))throw new Error(`Recursive definition found: ${e.join(" -> ")} -> ${t}`);e.push(t),t=this.types.get(t)}}if(void 0===t)throw new Error(`Type ${e} is not registered`);return t}parseTypeName(e){if(Array.isArray(e)){let[t,...r]=e;return{name:t,params:r}}if("string"!=typeof e)throw new Error(`Illegal type passed as a name of the type: ${e}`);let[t,r]=this.schema.genericSeparators||["<",">"],n=e.indexOf(t),i=Array.from(e).reverse().indexOf(r);if(-1===n&&-1===i)return{name:e,params:[]};if(-1===n||-1===i)throw new Error(`Unclosed generic in name '${e}'`);return{name:e.slice(0,n),params:Oe(e.slice(n+1,e.length-i-1),this.schema.genericSeparators)}}};let He=Xe;He.U8="u8",He.U16="u16",He.U32="u32",He.U64="u64",He.U128="u128",He.U256="u256",He.BOOL="bool",He.VECTOR="vector",He.ADDRESS="address",He.STRING="string",He.HEX="hex-string",He.BASE58="base58-string",He.BASE64="base64-string";const Ze=32;function Ye(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=e.toLowerCase();return!t&&r.startsWith("0x")&&(r=r.slice(2)),`0x${r.padStart(2*Ze,"0")}`}function Qe(e){return Ye(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1])}BigInt(1e9);const et="0x1",tt=Qe("0x6"),rt="0x2::sui::SUI";Qe("0x5");const nt={address:"0x2",module:"object",name:"ID"},it={address:et,module:"ascii",name:"String"},st={address:et,module:"string",name:"String"},at={address:et,module:"option",name:"Option"},ot=(e,t)=>e.address===t.address&&e.module===t.module&&e.name===t.name;function ct(e,t){if(!(typeof t>"u")&&typeof t!==e)throw new Error(`Expect ${t} to be ${e}, received ${typeof t}`)}const ut=["Address","Bool","U8","U16","U32","U64","U128","U256"];function dt(e,t){if("string"==typeof e&&ut.includes(e)){if(e in["U8","U16","U32","U64","U128","U256"])ct("number",t);else if("Bool"===e)ct("boolean",t);else if("Address"===e&&(ct("string",t),t&&!function(e){return function(e){return/^(0x|0X)?[a-fA-F0-9]+$/.test(e)&&e.length%2===0}(e)&&function(e){return/^(0x|0X)/.test(e)?(e.length-2)/2:e.length/2}(e)===Ze}(t)))throw new Error("Invalid Sui Address");return e.toLowerCase()}if("string"==typeof e)throw new Error(`Unknown pure normalized type ${JSON.stringify(e,null,2)}`);if("Vector"in e){if((void 0===t||"string"==typeof t)&&"U8"===e.Vector)return"string";if(void 0!==t&&!Array.isArray(t))throw new Error(`Expect ${t} to be a array, received ${typeof t}`);const r=dt(e.Vector,t?t[0]:void 0);return void 0===r?void 0:`vector<${r}>`}if("Struct"in e){if(ot(e.Struct,it))return"string";if(ot(e.Struct,st))return"utf8string";if(ot(e.Struct,nt))return"address";if(ot(e.Struct,at)){return dt({Vector:e.Struct.typeArguments[0]},t)}}}const lt=/^vector<(.+)>$/,ft=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class ht{static parseFromStr(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("address"===e)return{address:null};if("bool"===e)return{bool:null};if("u8"===e)return{u8:null};if("u16"===e)return{u16:null};if("u32"===e)return{u32:null};if("u64"===e)return{u64:null};if("u128"===e)return{u128:null};if("u256"===e)return{u256:null};if("signer"===e)return{signer:null};const r=e.match(lt);if(r)return{vector:ht.parseFromStr(r[1],t)};const n=e.match(ft);if(n)return{struct:{address:t?Ye(n[1]):n[1],module:n[2],name:n[3],typeParams:void 0===n[5]?[]:ht.parseStructTypeArgs(n[5],t)}};throw new Error(`Encountered unexpected token when parsing type args for ${e}`)}static parseStructTypeArgs(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Oe(e).map((e=>ht.parseFromStr(e,t)))}static tagToString(e){if("bool"in e)return"bool";if("u8"in e)return"u8";if("u16"in e)return"u16";if("u32"in e)return"u32";if("u64"in e)return"u64";if("u128"in e)return"u128";if("u256"in e)return"u256";if("address"in e)return"address";if("signer"in e)return"signer";if("vector"in e)return`vector<${ht.tagToString(e.vector)}>`;if("struct"in e){const t=e.struct,r=t.typeParams.map(ht.tagToString).join(", ");return`${t.address}::${t.module}::${t.name}${r?`<${r}>`:""}`}throw new Error("Invalid TypeTag")}}const pt=new He({genericSeparators:["<",">"],vectorType:"vector",addressLength:32,addressEncoding:"hex",types:{enums:{"Option<T>":{None:null,Some:"T"}}}});function gt(e){return qe.u64({name:"unsafe_u64",...e}).transform({input:e=>e,output:e=>Number(e)})}function mt(e){return e.transform({input:e=>({[e.kind]:e}),output:e=>{const t=Object.keys(e)[0];return{kind:t,...e[t]}}})}const yt=qe.bytes(Ze).transform({input:e=>"string"==typeof e?ke(Ye(e)):e,output:e=>Ye(xe(e))}),wt=qe.vector(qe.u8()).transform({name:"ObjectDigest",input:e=>je(e),output:e=>ve(new Uint8Array(e))}),bt=qe.struct("SuiObjectRef",{objectId:yt,version:qe.u64(),digest:wt}),vt=qe.struct("SharedObjectRef",{objectId:yt,initialSharedVersion:qe.u64(),mutable:qe.bool()}),jt=qe.enum("ObjectArg",{ImmOrOwned:bt,Shared:vt,Receiving:bt}),Tt=qe.enum("CallArg",{Pure:qe.vector(qe.u8()),Object:jt,ObjVec:qe.vector(jt)}),St=qe.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:qe.lazy((()=>St)),struct:qe.lazy((()=>$t)),u16:null,u32:null,u256:null}),Et=mt(qe.enum("Argument",{GasCoin:null,Input:qe.struct("Input",{index:qe.u16()}),Result:qe.struct("Result",{index:qe.u16()}),NestedResult:qe.struct("NestedResult",{index:qe.u16(),resultIndex:qe.u16()})})),kt=qe.struct("ProgrammableMoveCall",{package:yt,module:qe.string(),function:qe.string(),type_arguments:qe.vector(St),arguments:qe.vector(Et)}).transform({input:e=>{const[t,r,n]=e.target.split("::"),i=e.typeArguments.map((e=>ht.parseFromStr(e,!0)));return{package:Ye(t),module:r,function:n,type_arguments:i,arguments:e.arguments}},output:e=>({target:[e.package,e.module,e.function].join("::"),arguments:e.arguments,typeArguments:e.type_arguments.map(ht.tagToString)})}),xt=mt(qe.enum("Transaction",{MoveCall:kt,TransferObjects:qe.struct("TransferObjects",{objects:qe.vector(Et),address:Et}),SplitCoins:qe.struct("SplitCoins",{coin:Et,amounts:qe.vector(Et)}),MergeCoins:qe.struct("MergeCoins",{destination:Et,sources:qe.vector(Et)}),Publish:qe.struct("Publish",{modules:qe.vector(qe.vector(qe.u8())),dependencies:qe.vector(yt)}),MakeMoveVec:qe.struct("MakeMoveVec",{type:(qt=St,qe.enum("Option",{None:null,Some:qt})),objects:qe.vector(Et)}),Upgrade:qe.struct("Upgrade",{modules:qe.vector(qe.vector(qe.u8())),dependencies:qe.vector(yt),packageId:yt,ticket:Et})})),At=qe.struct("ProgrammableTransaction",{inputs:qe.vector(Tt),transactions:qe.vector(xt)}),It=qe.enum("TransactionKind",{ProgrammableTransaction:At,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),Ot=qe.enum("TransactionExpiration",{None:null,Epoch:gt()}),$t=qe.struct("StructTag",{address:yt,module:qe.string(),name:qe.string(),typeParams:qe.vector(St)}),Bt=qe.struct("GasData",{payment:qe.vector(bt),owner:yt,price:qe.u64(),budget:qe.u64()}),Ut=qe.struct("TransactionDataV1",{kind:It,sender:yt,gasData:Bt,expiration:Ot}),Ct=qe.enum("TransactionData",{V1:Ut}),zt=qe.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),_t=qe.enum("IntentVersion",{V0:null}),Mt=qe.enum("AppId",{Sui:null}),Pt=qe.struct("Intent",{scope:zt,version:_t,appId:Mt}),Nt=qe.generic(["T"],(e=>qe.struct("IntentMessage<T>",{intent:Pt,value:e}))),Vt=qe.enum("CompressedSignature",{ED25519:qe.fixedArray(64,qe.u8()),Secp256k1:qe.fixedArray(64,qe.u8()),Secp256r1:qe.fixedArray(64,qe.u8()),ZkLogin:qe.vector(qe.u8())}),Rt=qe.enum("PublicKey",{ED25519:qe.fixedArray(32,qe.u8()),Secp256k1:qe.fixedArray(33,qe.u8()),Secp256r1:qe.fixedArray(33,qe.u8()),ZkLogin:qe.vector(qe.u8())}),Dt=qe.struct("MultiSigPkMap",{pubKey:Rt,weight:qe.u8()}),Wt=qe.struct("MultiSigPublicKey",{pk_map:qe.vector(Dt),threshold:qe.u16()}),Ft=qe.struct("MultiSig",{sigs:qe.vector(Vt),bitmap:qe.u16(),multisig_pk:Wt}),Gt=qe.vector(qe.u8()).transform({input:e=>"string"==typeof e?Te(e):e,output:e=>Ee(new Uint8Array(e))}),Kt=qe.struct("SenderSignedTransaction",{intentMessage:Nt(Ct),txSignatures:qe.vector(Gt)}),Lt=qe.vector(Kt,{name:"SenderSignedData"}),Jt={...qe,U8:qe.u8(),U16:qe.u16(),U32:qe.u32(),U64:qe.u64(),U128:qe.u128(),U256:qe.u256(),ULEB128:qe.uleb128(),Bool:qe.bool(),String:qe.string(),Address:yt,Argument:Et,CallArg:Tt,CompressedSignature:Vt,GasData:Bt,MultiSig:Ft,MultiSigPkMap:Dt,MultiSigPublicKey:Wt,ObjectArg:jt,ObjectDigest:wt,ProgrammableMoveCall:kt,ProgrammableTransaction:At,PublicKey:Rt,SenderSignedData:Lt,SenderSignedTransaction:Kt,SharedObjectRef:vt,StructTag:$t,SuiObjectRef:bt,Transaction:xt,TransactionData:Ct,TransactionDataV1:Ut,TransactionExpiration:Ot,TransactionKind:It,TypeTag:St,ser:pt.ser.bind(pt),de:pt.de.bind(pt),getTypeInterface:pt.getTypeInterface.bind(pt),hasType:pt.hasType.bind(pt),parseTypeName:pt.parseTypeName.bind(pt),registerAddressType:pt.registerAddressType.bind(pt),registerAlias:pt.registerAlias.bind(pt),registerBcsType:pt.registerBcsType.bind(pt),registerEnumType:pt.registerEnumType.bind(pt),registerStructType:pt.registerStructType.bind(pt),registerType:pt.registerType.bind(pt),types:pt.types};var qt;pt.registerBcsType("utf8string",(()=>qe.string({name:"utf8string"}))),pt.registerBcsType("unsafe_u64",(()=>gt())),pt.registerBcsType("enumKind",(e=>mt(e))),[yt,Et,Tt,Vt,Bt,Ft,Dt,Wt,jt,wt,kt,At,Rt,Lt,vt,$t,bt,xt,Ct,Ut,Ot,It,St].forEach((e=>{pt.registerBcsType(e.name,(()=>e))}));const Xt=M([B({ImmOrOwned:R}),B({Shared:B({objectId:z(),initialSharedVersion:M([x(),z()]),mutable:k()})}),B({Receiving:R})]),Ht=B({Pure:E(x())}),Zt=B({Object:Xt}),Yt=M([Ht,Zt]);const Qt={Pure:function(e,t){return{Pure:Array.from(e instanceof Uint8Array?e:Fe(e)?e.toBytes():Jt.ser(t,e,{maxSize:1/0}).toBytes())}},ObjectRef(e){let{objectId:t,digest:r,version:n}=e;return{Object:{ImmOrOwned:{digest:r,version:n,objectId:Ye(t)}}}},SharedObjectRef(e){let{objectId:t,mutable:r,initialSharedVersion:n}=e;return{Object:{Shared:{mutable:r,initialSharedVersion:n,objectId:Ye(t)}}}},ReceivingRef(e){let{objectId:t,digest:r,version:n}=e;return{Object:{Receiving:{digest:r,version:n,objectId:Ye(t)}}}}};function er(e){return"string"==typeof e?Ye(e):"ImmOrOwned"in e.Object?Ye(e.Object.ImmOrOwned.objectId):"Receiving"in e.Object?Ye(e.Object.Receiving.objectId):Ye(e.Object.Shared.objectId)}function tr(e,t){return y(e,t)}const rr=M([B({kind:A("Input"),index:x(),value:U(S()),type:U(A("object"))}),B({kind:A("Input"),index:x(),value:U(S()),type:A("pure")})]),nr=M([...[rr,B({kind:A("GasCoin")}),B({kind:A("Result"),index:x()}),B({kind:A("NestedResult"),index:x(),resultIndex:x()})]]),ir=B({kind:A("MoveCall"),target:T("target",z().validator),typeArguments:E(z()),arguments:E(nr)}),sr=B({kind:A("TransferObjects"),objects:E(nr),address:nr}),ar=B({kind:A("SplitCoins"),coin:nr,amounts:E(nr)}),or=B({kind:A("MergeCoins"),destination:nr,sources:E(nr)}),cr=B({kind:A("MakeMoveVec"),type:U((e=>M([B({None:M([A(!0),A(null)])}),B({Some:e})]))(C(z(),P()))),objects:E(nr)}),ur=B({kind:A("Publish"),modules:E(E(x())),dependencies:E(z())}),dr=B({kind:A("Upgrade"),modules:E(E(x())),dependencies:E(z()),packageId:z(),ticket:nr}),lr=M([...[ir,sr,ar,or,ur,dr,cr]]),fr={MoveCall:e=>tr({kind:"MoveCall",target:e.target,arguments:e.arguments??[],typeArguments:e.typeArguments??[]},ir),TransferObjects:(e,t)=>("Input"===t.kind&&"pure"===t.type&&"object"!=typeof t.value&&(t.value=Qt.Pure(Jt.Address.serialize(t.value))),tr({kind:"TransferObjects",objects:e,address:t},sr)),SplitCoins:(e,t)=>(t.forEach((e=>{"Input"===e.kind&&"pure"===e.type&&"object"!=typeof e.value&&(e.value=Qt.Pure(Jt.U64.serialize(e.value)))})),tr({kind:"SplitCoins",coin:e,amounts:t},ar)),MergeCoins:(e,t)=>tr({kind:"MergeCoins",destination:e,sources:t},or),Publish(e){let{modules:t,dependencies:r}=e;return tr({kind:"Publish",modules:t.map((e=>"string"==typeof e?Array.from(Te(e)):e)),dependencies:r.map((e=>Qe(e)))},ur)},Upgrade(e){let{modules:t,dependencies:r,packageId:n,ticket:i}=e;return tr({kind:"Upgrade",modules:t.map((e=>"string"==typeof e?Array.from(Te(e)):e)),dependencies:r.map((e=>Qe(e))),packageId:n,ticket:i},dr)},MakeMoveVec(e){let{type:t,objects:r}=e;return tr({kind:"MakeMoveVec",type:t?{Some:ht.parseFromStr(t)}:{None:null},objects:r},cr)}};function hr(e){function t(t,r){return e(t,r)}return t.u8=t=>e(Jt.U8.serialize(t)),t.u16=t=>e(Jt.U16.serialize(t)),t.u32=t=>e(Jt.U32.serialize(t)),t.u64=t=>e(Jt.U64.serialize(t)),t.u128=t=>e(Jt.U128.serialize(t)),t.u256=t=>e(Jt.U256.serialize(t)),t.bool=t=>e(Jt.Bool.serialize(t)),t.string=t=>e(Jt.String.serialize(t)),t.address=t=>e(Jt.Address.serialize(t)),t.id=t.address,t}const pr=U(O(M([B({Epoch:x()}),B({None:M([A(!0),A(null)])})]))),gr=T("StringEncodedBigint",(e=>{if(!["string","number","bigint"].includes(typeof e))return!1;try{return BigInt(e),!0}catch{return!1}})),mr=B({budget:U(gr),price:U(gr),payment:U(E(R)),owner:U(z())}),yr=B({version:A(1),sender:U(z()),expiration:pr,gasConfig:mr,inputs:E(rr),transactions:E(lr)});function wr(e){return Ye(e).replace("0x","")}class br{constructor(e){this.version=1,this.sender=null==e?void 0:e.sender,this.expiration=null==e?void 0:e.expiration,this.gasConfig=(null==e?void 0:e.gasConfig)??{},this.inputs=(null==e?void 0:e.inputs)??[],this.transactions=(null==e?void 0:e.transactions)??[]}static fromKindBytes(e){const t=Jt.TransactionKind.parse(e),r="ProgrammableTransaction"in t?t.ProgrammableTransaction:null;if(!r)throw new Error("Unable to deserialize from bytes.");const n=tr({version:1,gasConfig:{},inputs:r.inputs.map(((e,t)=>tr({kind:"Input",value:e,index:t,type:b(e,Ht)?"pure":"object"},rr))),transactions:r.transactions},yr);return br.restore(n)}static fromBytes(e){var t;const r=Jt.TransactionData.parse(e),n=null==r?void 0:r.V1,i="ProgrammableTransaction"in n.kind?null==(t=null==n?void 0:n.kind)?void 0:t.ProgrammableTransaction:null;if(!n||!i)throw new Error("Unable to deserialize from bytes.");const s=tr({version:1,sender:n.sender,expiration:n.expiration,gasConfig:n.gasData,inputs:i.inputs.map(((e,t)=>tr({kind:"Input",value:e,index:t,type:b(e,Ht)?"pure":"object"},rr))),transactions:i.transactions},yr);return br.restore(s)}static restore(e){m(e,yr);const t=new br;return Object.assign(t,e),t}static getDigestFromBytes(e){const t=function(e,t){const r=Array.from(`${e}::`).map((e=>e.charCodeAt(0))),i=new Uint8Array(r.length+t.length);return i.set(r),i.set(t,r.length),(0,n.b1)(i,{dkLen:32})}("TransactionData",e);return ve(t)}build(){let{maxSizeBytes:e=1/0,overrides:t,onlyTransactionKind:r}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=this.inputs.map((e=>(m(e.value,Yt),e.value))),i={ProgrammableTransaction:{inputs:n,transactions:this.transactions}};if(r)return Jt.TransactionKind.serialize(i,{maxSize:e}).toBytes();const s=(null==t?void 0:t.expiration)??this.expiration,a=(null==t?void 0:t.sender)??this.sender,o={...this.gasConfig,...null==t?void 0:t.gasConfig};if(!a)throw new Error("Missing transaction sender");if(!o.budget)throw new Error("Missing gas budget");if(!o.payment)throw new Error("Missing gas payment");if(!o.price)throw new Error("Missing gas price");const c={sender:wr(a),expiration:s||{None:!0},gasData:{payment:o.payment,owner:wr(this.gasConfig.owner??a),price:BigInt(o.price),budget:BigInt(o.budget)},kind:{ProgrammableTransaction:{inputs:n,transactions:this.transactions}}};return Jt.TransactionData.serialize({V1:c},{maxSize:e}).toBytes()}getDigest(){const e=this.build({onlyTransactionKind:!1});return br.getDigestFromBytes(e)}snapshot(){return tr(this,yr)}}var vr,jr,Tr,Sr,Er,kr,xr,Ar,Ir,Or,$r,Br,Ur,Cr,zr,_r,Mr,Pr=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},Nr=(e,t,r)=>(Pr(e,t,"read from private field"),r?r.call(e):t.get(e)),Vr=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},Rr=(e,t,r,n)=>(Pr(e,t,"write to private field"),t.set(e,r),r),Dr=(e,t,r)=>(Pr(e,t,"access private method"),r);const Wr={maxPureArgumentSize:16384,maxTxGas:5e10,maxGasObjects:256,maxTxSizeBytes:131072};function Fr(e){if(!e.client)throw new Error("No provider passed to Transaction#build, but transaction data was not sufficient to build offline.");return e.client}const Gr=Symbol.for("@mysten/transaction"),Kr={maxTxGas:"max_tx_gas",maxGasObjects:"max_gas_payment_objects",maxTxSizeBytes:"max_tx_size_bytes",maxPureArgumentSize:"max_pure_argument_size"},Lr=class{constructor(e){Vr(this,jr),Vr(this,Sr),Vr(this,kr),Vr(this,Ar),Vr(this,Or),Vr(this,Br),Vr(this,Cr),Vr(this,_r),Vr(this,vr,void 0),Rr(this,vr,new br(e?e.blockData:void 0))}static fromKind(e){const t=new Lr;return Rr(t,vr,br.fromKindBytes("string"==typeof e?Te(e):e)),t}static from(e){const t=new Lr;return"string"==typeof e&&e.startsWith("{")?Rr(t,vr,br.restore(JSON.parse(e))):Rr(t,vr,br.fromBytes("string"==typeof e?Te(e):e)),t}setSender(e){Nr(this,vr).sender=e}setSenderIfNotSet(e){Nr(this,vr).sender||(Nr(this,vr).sender=e)}setExpiration(e){Nr(this,vr).expiration=e}setGasPrice(e){Nr(this,vr).gasConfig.price=String(e)}setGasBudget(e){Nr(this,vr).gasConfig.budget=String(e)}setGasOwner(e){Nr(this,vr).gasConfig.owner=e}setGasPayment(e){Nr(this,vr).gasConfig.payment=e.map((e=>w(e,R)))}get blockData(){return Nr(this,vr).snapshot()}get[Gr](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:hr(((e,t)=>Fe(e)?Dr(this,jr,Tr).call(this,"pure",{Pure:Array.from(e.toBytes())}):Dr(this,jr,Tr).call(this,"pure",e instanceof Uint8Array?Qt.Pure(e):t?Qt.Pure(e,t):e)))}),this.pure}get gas(){return{kind:"GasCoin"}}object(e){if("object"==typeof e&&"kind"in e)return e;const t=er(e),r=Nr(this,vr).inputs.find((e=>"object"===e.type&&t===er(e.value)));return r&&b(r.value,Zt)&&"Shared"in r.value.Object&&b(e,Zt)&&"Shared"in e.Object&&(r.value.Object.Shared.mutable=r.value.Object.Shared.mutable||e.Object.Shared.mutable),r??Dr(this,jr,Tr).call(this,"object","string"==typeof e?Ye(e):e)}objectRef(){return this.object(Qt.ObjectRef(...arguments))}receivingRef(){return this.object(Qt.ReceivingRef(...arguments))}sharedObjectRef(){return this.object(Qt.SharedObjectRef(...arguments))}add(e){return function(e){const t=[],r=r=>t[r]??(t[r]={kind:"NestedResult",index:e,resultIndex:r});return new Proxy({kind:"Result",index:e},{set(){throw new Error("The transaction result is a proxy, and does not support setting properties directly")},get(e,t){if(t in e)return Reflect.get(e,t);if(t===Symbol.iterator)return function*(){let e=0;for(;;)yield r(e),e++};if("symbol"==typeof t)return;const n=parseInt(t,10);return Number.isNaN(n)||n<0?void 0:r(n)}})}(Nr(this,vr).transactions.push(e)-1)}splitCoins(e,t){return this.add(fr.SplitCoins("string"==typeof e?this.object(e):e,t.map((e=>"number"==typeof e||"bigint"==typeof e||"string"==typeof e?this.pure.u64(e):Dr(this,Sr,Er).call(this,e)))))}mergeCoins(e,t){return this.add(fr.MergeCoins("string"==typeof e?this.object(e):e,t.map((e=>"string"==typeof e?this.object(e):e))))}publish(e){let{modules:t,dependencies:r}=e;return this.add(fr.Publish({modules:t,dependencies:r}))}upgrade(e){let{modules:t,dependencies:r,packageId:n,ticket:i}=e;return this.add(fr.Upgrade({modules:t,dependencies:r,packageId:n,ticket:"string"==typeof i?this.object(i):i}))}moveCall(e){let{arguments:t,typeArguments:r,target:n}=e;return this.add(fr.MoveCall({arguments:null==t?void 0:t.map((e=>Dr(this,Sr,Er).call(this,e))),typeArguments:r,target:n}))}transferObjects(e,t){return this.add(fr.TransferObjects(e.map((e=>"string"==typeof e?this.object(e):e)),"string"==typeof t?this.pure.address(t):Dr(this,Sr,Er).call(this,t)))}makeMoveVec(e){let{type:t,objects:r}=e;return this.add(fr.MakeMoveVec({type:t,objects:r.map((e=>"string"==typeof e?this.object(e):e))}))}serialize(){return JSON.stringify(Nr(this,vr).snapshot())}async sign(e){const{signer:t,...r}=e,n=await this.build(r);return t.signTransactionBlock(n)}async build(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return await Dr(this,_r,Mr).call(this,e),Nr(this,vr).build({maxSizeBytes:Dr(this,kr,xr).call(this,"maxTxSizeBytes",e),onlyTransactionKind:e.onlyTransactionKind})}async getDigest(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return await Dr(this,_r,Mr).call(this,e),Nr(this,vr).getDigest()}};let Jr=Lr;vr=new WeakMap,jr=new WeakSet,Tr=function(e,t){const r=Nr(this,vr).inputs.length,n=tr({kind:"Input",value:"bigint"==typeof t?String(t):t,index:r,type:e},rr);return Nr(this,vr).inputs.push(n),n},Sr=new WeakSet,Er=function(e){return Fe(e)?this.pure(e):e},kr=new WeakSet,xr=function(e,t){let{protocolConfig:r,limits:n}=t;if(n&&"number"==typeof n[e])return n[e];if(!r)return Wr[e];const i=null==r?void 0:r.attributes[Kr[e]];if(!i)throw new Error(`Missing expected protocol config: "${Kr[e]}"`);const s="u64"in i?i.u64:"u32"in i?i.u32:i.f64;if(!s)throw new Error(`Unexpected protocol config value found for: "${Kr[e]}"`);return Number(s)},Ar=new WeakSet,Ir=function(e){const t=Dr(this,kr,xr).call(this,"maxPureArgumentSize",e);Nr(this,vr).inputs.forEach(((e,r)=>{if(b(e.value,Ht)&&e.value.Pure.length>t)throw new Error(`Input at index ${r} is too large, max pure input size is ${t} bytes, got ${e.value.Pure.length} bytes`)}))},Or=new WeakSet,$r=async function(e){if(Nr(this,vr).gasConfig.payment){const t=Dr(this,kr,xr).call(this,"maxGasObjects",e);if(Nr(this,vr).gasConfig.payment.length>t)throw new Error(`Payment objects exceed maximum amount: ${t}`)}if(e.onlyTransactionKind||Nr(this,vr).gasConfig.payment)return;const t=Nr(this,vr).gasConfig.owner??Nr(this,vr).sender,r=(await Fr(e).getCoins({owner:t,coinType:rt})).data.filter((e=>!Nr(this,vr).inputs.find((t=>!!(b(t.value,Yt)&&"Object"in t.value&&"ImmOrOwned"in t.value.Object)&&e.coinObjectId===t.value.Object.ImmOrOwned.objectId)))).slice(0,Dr(this,kr,xr).call(this,"maxGasObjects",e)-1).map((e=>({objectId:e.coinObjectId,digest:e.digest,version:e.version})));if(!r.length)throw new Error("No valid gas coins found for the transaction.");this.setGasPayment(r)},Br=new WeakSet,Ur=async function(e){e.onlyTransactionKind||Nr(this,vr).gasConfig.price||this.setGasPrice(await Fr(e).getReferenceGasPrice())},Cr=new WeakSet,zr=async function(e){const{inputs:t,transactions:r}=Nr(this,vr),n=[],i=[];if(t.forEach((e=>{"object"!==e.type||"string"!=typeof e.value||i.push({id:Ye(e.value),input:e})})),r.forEach((e=>{if("MoveCall"===e.kind&&e.arguments.some((e=>"Input"===e.kind&&!b(t[e.index].value,Yt)))&&n.push(e),"SplitCoins"===e.kind&&e.amounts.forEach((e=>{if("Input"===e.kind){const r=t[e.index];"object"!=typeof r.value&&(r.value=Qt.Pure(Jt.U64.serialize(r.value)))}})),"TransferObjects"===e.kind&&"Input"===e.address.kind){const r=t[e.address.index];"object"!=typeof r.value&&(r.value=Qt.Pure(Jt.Address.serialize(r.value)))}})),n.length&&await Promise.all(n.map((async r=>{const[n,s,a]=r.target.split("::"),o=await Fr(e).getNormalizedMoveFunction({package:Qe(n),module:s,function:a}),c=o.parameters.length>0&&function(e){var t;const r=null==(t=me(e))?void 0:t.Struct;return"0x2"===(null==r?void 0:r.address)&&"tx_context"===(null==r?void 0:r.module)&&"TxContext"===(null==r?void 0:r.name)}(o.parameters.at(-1))?o.parameters.slice(0,o.parameters.length-1):o.parameters;if(c.length!==r.arguments.length)throw new Error("Incorrect number of arguments.");c.forEach(((e,n)=>{const s=r.arguments[n];if("Input"!==s.kind)return;const a=t[s.index];if(b(a.value,Yt))return;const o=a.value,c=dt(e,o);if(c)a.value=Qt.Pure(o,c);else{if(!(null!=me(e)||"object"==typeof e&&"TypeParameter"in e))throw new Error(`Unknown call arg type ${JSON.stringify(e,null,2)} for value ${JSON.stringify(o,null,2)}`);if("string"!=typeof o)throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(o,null,2)}`);i.push({id:o,input:a,normalizedType:e})}}))}))),i.length){const t=[...new Set(i.map((e=>{let{id:t}=e;return t})))],r=((e,t)=>Array.from({length:Math.ceil(e.length/t)},((r,n)=>e.slice(n*t,n*t+t))))(t,50),n=(await Promise.all(r.map((t=>Fr(e).multiGetObjects({ids:t,options:{showOwner:!0}}))))).flat();let s=new Map(t.map(((e,t)=>[e,n[t]])));const a=Array.from(s).filter((e=>{let[t,r]=e;return r.error})).map((e=>{let[t,r]=e;return t}));if(a.length)throw new Error(`The following input objects are invalid: ${a.join(", ")}`);i.forEach((e=>{let{id:t,input:r,normalizedType:n}=e;var i;const a=s.get(t),o=null==(i=a.data)?void 0:i.owner,c=o&&"object"==typeof o&&"Shared"in o?o.Shared.initial_shared_version:void 0;if(c){const e=null!=n&&null==pe(n)&&null==ge(n),i=function(e){var t;return(null==(t=function(e){return"object"==typeof e&&"Object"in e&&"Shared"in e.Object?e.Object.Shared:void 0}(e))?void 0:t.mutable)??!1}(r.value)||e||null!=n&&null!=pe(n);r.value=Qt.SharedObjectRef({objectId:t,initialSharedVersion:c,mutable:i})}else n&&function(e){const t=me(e);return!!t&&"0x2"===t.Struct.address&&"transfer"===t.Struct.module&&"Receiving"===t.Struct.name}(n)?r.value=Qt.ReceivingRef(ee(a)):r.value=Qt.ObjectRef(ee(a))}))}},_r=new WeakSet,Mr=async function(e){if(!e.onlyTransactionKind&&!Nr(this,vr).sender)throw new Error("Missing transaction sender");if(!e.protocolConfig&&!e.limits&&e.client&&(e.protocolConfig=await e.client.getProtocolConfig()),await Promise.all([Dr(this,Br,Ur).call(this,e),Dr(this,Cr,zr).call(this,e)]),!e.onlyTransactionKind&&(await Dr(this,Or,$r).call(this,e),!Nr(this,vr).gasConfig.budget)){const t=await Fr(e).dryRunTransactionBlock({transactionBlock:Nr(this,vr).build({maxSizeBytes:Dr(this,kr,xr).call(this,"maxTxSizeBytes",e),overrides:{gasConfig:{budget:String(Dr(this,kr,xr).call(this,"maxTxGas",e)),payment:[]}}})});if("success"!==t.effects.status.status)throw new Error(`Dry run failed, could not automatically determine a budget: ${t.effects.status.error}`,{cause:t});const r=1000n*BigInt(this.blockData.gasConfig.price||1n),n=BigInt(t.effects.gasUsed.computationCost)+r,i=n+BigInt(t.effects.gasUsed.storageCost)-BigInt(t.effects.gasUsed.storageRebate);this.setGasBudget(i>n?i:n)}Dr(this,Ar,Ir).call(this,e)};const qr=async(e,t,r)=>{var n,s,a;if(!(0,i.i)(r))throw new Error(`Invalid Sui type: ${r}`);const o=await(0,i.g)(e,t);if(!o)throw new Error(`Unable to fetch object fields from token bridge state. Object ID: ${t}`);const c=null==(s=null==(n=o.token_registry.fields)?void 0:n.id)?void 0:s.id;if(!c)throw new Error("Unable to fetch token registry object ID");const u=(0,i.a)(null==(a=o.token_registry)?void 0:a.type);if(!u)throw new Error("Unable to fetch token registry package ID");return e.getDynamicFieldObject({parentId:c,name:{type:`${u}::token_registry::Key<${r}>`,value:{dummy_field:!1}}})},Xr=async(e,t,r,n)=>{var s,a,o,c;const u=await(0,i.g)(e,t);if(!u)throw new Error("Unable to fetch object fields from token bridge state");const d=null==(a=null==(s=u.token_registry)?void 0:s.fields)?void 0:a.coin_types,l=null==(c=null==(o=null==d?void 0:d.fields)?void 0:o.id)?void 0:c.id;if(!l)throw new Error("Unable to fetch coin types");const f=(0,i.b)(null==d?void 0:d.type);if(!f)throw new Error("Unable to get key type");const h=await e.getDynamicFieldObject({parentId:l,name:{type:f,value:{addr:[...r],chain:n}}});if(h.error){if("dynamicFieldNotFound"===h.error.code)return null;throw new Error(`Unexpected getDynamicFieldObject response ${h.error}`)}const p=(0,i.c)(h);if(!p)return null;if(!(0,i.d)(p))throw new Error("What?");return"value"in p?(0,i.t)(p.value):null};class Hr{constructor(e,t,r,i){o(this,"network"),o(this,"chain"),o(this,"provider"),o(this,"contracts"),o(this,"coreBridgeObjectId"),o(this,"tokenBridgeObjectId"),o(this,"chainId"),this.network=e,this.chain=t,this.provider=r,this.contracts=i,this.chainId=n.c3.get(e,t);const s=this.contracts.tokenBridge;if(!s)throw new Error(`Wormhole Token Bridge contract for domain ${t} not found`);const a=this.contracts.coreBridge;if(!a)throw new Error(`Wormhole Token Bridge contract for domain ${t} not found`);this.tokenBridgeObjectId=s,this.coreBridgeObjectId=a}static async fromRpc(e,t){const[r,n]=await i.S.chainFromRpc(e),s=t[n];if(s.network!==r)throw new Error(`Network mismatch: ${s.network} != ${r}`);return new Hr(r,n,e,s.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){let t=e.getCoinType();if(!(0,i.i)(t))throw new Error(`Invalid Sui type: ${t}`);const r=await qr(this.provider,this.tokenBridgeObjectId,t),s=(0,i.c)(r);if(!s)throw(0,n.cD)(t);if(!(0,i.d)(s))throw new Error("Expected fields to be a MoveStruct");if(!("value"in s))throw new Error("Expected a `value` key in fields of MoveStruct");const a=s.value;if(!(0,i.e)(a))throw new Error("Expected fields to be a MoveStruct");const o=(0,i.t)(a.type);if(t=(0,i.t)(t),o.includes(`wrapped_asset::WrappedAsset<${t}>`)){const e=a.fields.info;if(!(0,i.e)(e))throw new Error("Expected fields to be a MoveStruct");const t=e.fields.token_address;if(!(0,i.e)(t))throw new Error("Expected fields to be a MoveStruct");if(!(0,i.d)(t.fields))throw new Error("Expected address data to be a MoveObject");if(!("value"in t.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const r=t.fields.value;if(!(0,i.e)(r))throw new Error("Expected fields to be a MoveStruct");return{chain:(0,n.cE)(Number(e.fields.token_chain)),address:new n.as(r.fields.data)}}throw(0,n.cD)(t)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){if((0,n.ax)(e.address))throw new Error("Token Address required, 'native' literal not supported");const t=await Xr(this.provider,this.tokenBridgeObjectId,e.address.toUniversalAddress().toUint8Array(),(0,n.bW)(e.chain));if(!t)throw(0,n.cD)((0,n.ch)(e));return(0,n.cj)(this.chain,t)}async isTransferCompleted(e){var t,r,s,a,o,c,u,d;const l=await(0,i.g)(this.provider,this.tokenBridgeObjectId);if(!l)throw new Error("Unable to fetch object fields from token bridge state");const f=null==(r=null==(t=l.consumed_vaas)?void 0:t.fields)?void 0:r.hashes,h=(0,i.b)(null==(a=null==(s=null==f?void 0:f.fields)?void 0:s.items)?void 0:a.type);if(!h)throw new Error("Unable to get key type");const p=null==(d=null==(u=null==(c=null==(o=null==f?void 0:f.fields)?void 0:o.items)?void 0:c.fields)?void 0:u.id)?void 0:d.id;if(!p)throw new Error("Unable to fetch consumed VAAs table");const g=await this.provider.getDynamicFieldObject({parentId:p,name:{type:h,value:{data:[...(0,n.cF)(e.hash)]}}});if(!g.error)return!0;if("dynamicFieldNotFound"===g.error.code)return!1;throw new Error(`Unexpected getDynamicFieldObject response ${g.error}`)}async*createAttestation(e){const t=e.toString(),r=await this.provider.getCoinMetadata({coinType:t});if(null===r||null===r.id)throw new Error(`Coin metadata ID for type ${t} not found`);const[n,i]=await this.getPackageIds(),s=new Jr,[a]=s.splitCoins(s.gas,[s.pure(0n)]),[o]=s.moveCall({target:`${i}::attest_token::attest_token`,arguments:[s.object(this.tokenBridgeObjectId),s.object(r.id),s.pure(0n)],typeArguments:[t]});s.moveCall({target:`${n}::publish_message::publish_message`,arguments:[s.object(this.coreBridgeObjectId),a,o,s.object(tt)]}),yield this.createUnsignedTx(s,"Sui.TokenBridge.CreateAttestation")}async*submitAttestation(e,t){const[r,s]=await this.getPackageIds(),a=t.toString(),o=Math.min(e.payload.decimals,8),c=await this.getCoinBuildOutput(r,s,o),u=await(0,i.p)(c,a);yield this.createUnsignedTx(u,"Sui.TokenBridge.PrepareCreateWrapped");let d="",l="",f="",h="",p="",g=!1;for(;!g;){await new Promise((e=>setTimeout(e,500)));const e=await this.provider.queryTransactionBlocks({filter:{FromAddress:a},options:{showObjectChanges:!0},limit:3});for(const t of e.data)if("objectChanges"in t){for(const e of t.objectChanges)(0,i.f)(e)&&void 0!==e.packageId?d=e.packageId:(0,i.h)(e)&&e.objectType.includes("WrappedAssetSetup")?(l=e.objectId,p=e.objectType.split(", ")[1].replace(">","")):(0,i.h)(e)&&e.objectType.includes("UpgradeCap")?f=e.objectId:(0,i.h)(e)&&e.objectType.includes("CoinMetadata")&&(h=e.objectId);if(""!==d&&""!==l&&""!==f&&""!==h){g=!0;break}d="",l="",f="",h=""}}const m=(0,i.j)(d),y=new Jr,[w]=y.moveCall({target:`${r}::vaa::parse_and_verify`,arguments:[y.object(this.coreBridgeObjectId),y.pure((0,i.u)((0,n.cw)(e))),y.object(tt)]}),[b]=y.moveCall({target:`${s}::vaa::verify_only_once`,arguments:[y.object(this.tokenBridgeObjectId),w]});y.moveCall({target:`${s}::create_wrapped::complete_registration`,arguments:[y.object(this.tokenBridgeObjectId),y.object(h),y.object(l),y.object(f),b],typeArguments:[m,p]}),yield this.createUnsignedTx(y,"Sui.TokenBridge.SubmitAttestation")}async*transfer(e,t,r,s,a){const o=e.toString(),c=((0,n.ax)(r)?rt:r).toString(),u=(await this.provider.getCoins({owner:o,coinType:c})).data,[d,...l]=u.filter((e=>(0,i.k)(e.coinType,c)));if(void 0===d)throw new Error(`Coins array doesn't contain any coins of type ${c}`);const[f,h]=await this.getPackageIds(),p=new Jr,[g]=(()=>{if(c===rt)return p.splitCoins(p.gas,[p.pure(s)]);{const e=p.object(d.coinObjectId);return l.length&&p.mergeCoins(e,l.map((e=>p.object(e.coinObjectId)))),p.splitCoins(e,[p.pure(s)])}})(),[m]=p.splitCoins(p.gas,[p.pure(0n)]),[y]=p.moveCall({target:`${h}::state::verified_asset`,arguments:[p.object(this.tokenBridgeObjectId)],typeArguments:[c]});if(a){if(!o)throw new Error("senderAddress is required for transfer with payload");let e=!1;const r=await(async()=>{const t=await(0,i.l)(this.provider,f,o);if(null!==t)return p.object(t);{const[t]=p.moveCall({target:`${f}::emitter::new`,arguments:[p.object(this.coreBridgeObjectId)]});return e=!0,t}})(),[s,u]=p.moveCall({target:`${h}::transfer_tokens_with_payload::prepare_transfer`,arguments:[r,y,g,p.pure((0,n.bW)(t.chain)),p.pure(t.address.toUint8Array()),p.pure([...a]),p.pure(0)],typeArguments:[c]});p.moveCall({target:`${h}::coin_utils::return_nonzero`,arguments:[u],typeArguments:[c]});const[d]=p.moveCall({target:`${h}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[p.object(this.tokenBridgeObjectId),s],typeArguments:[c]});p.moveCall({target:`${f}::publish_message::publish_message`,arguments:[p.object(this.coreBridgeObjectId),m,d,p.object(tt)]}),e&&p.transferObjects([r],p.pure(o)),yield this.createUnsignedTx(p,"Sui.TokenBridge.TransferWithPayload")}else{const[e,r]=p.moveCall({target:`${h}::transfer_tokens::prepare_transfer`,arguments:[y,g,p.pure((0,n.bW)(t.chain)),p.pure((0,i.u)(t.address.toUint8Array())),p.pure(0n),p.pure(0)],typeArguments:[c]});p.moveCall({target:`${h}::coin_utils::return_nonzero`,arguments:[r],typeArguments:[c]});const[s]=p.moveCall({target:`${h}::transfer_tokens::transfer_tokens`,arguments:[p.object(this.tokenBridgeObjectId),e],typeArguments:[c]});p.moveCall({target:`${f}::publish_message::publish_message`,arguments:[p.object(this.coreBridgeObjectId),m,s,p.object(tt)]}),yield this.createUnsignedTx(p,"Sui.TokenBridge.Transfer")}}redeem(e,t){try{var r=this;return async function*(){const e=await Xr(r.provider,r.tokenBridgeObjectId,t.payload.token.address.toUint8Array(),(0,n.bW)(t.payload.token.chain));if(!e)throw new Error("Unable to fetch token coinType");const[s,a]=await r.getPackageIds(),o=new Jr,[c]=o.moveCall({target:`${s}::vaa::parse_and_verify`,arguments:[o.object(r.coreBridgeObjectId),o.pure((0,i.u)((0,n.cw)(t))),o.object(tt)]}),[u]=o.moveCall({target:`${a}::vaa::verify_only_once`,arguments:[o.object(r.tokenBridgeObjectId),c]}),[d]=o.moveCall({target:`${a}::complete_transfer::authorize_transfer`,arguments:[o.object(r.tokenBridgeObjectId),u],typeArguments:[e]}),[l]=o.moveCall({target:`${a}::complete_transfer::redeem_relayer_payout`,arguments:[d],typeArguments:[e]});o.moveCall({target:`${a}::coin_utils::return_nonzero`,arguments:[l],typeArguments:[e]}),yield r.createUnsignedTx(o,"Sui.TokenBridge.Redeem")}()}catch(qt){return Promise.reject(qt)}}async getWrappedNative(){const e=await this.provider.getCoinMetadata({coinType:rt});if(!e)throw new Error("Coin metadata not found");return(0,n.cj)(this.chain,e.id)}async getPackageIds(){return Promise.all([(0,i.m)(this.provider,this.coreBridgeObjectId),(0,i.m)(this.provider,this.tokenBridgeObjectId)])}async getCoinBuildOutput(e,t,r){var s;if(r>8)throw new Error("Decimals is capped at 8");const a=null==(s=await(0,i.n)(this.provider,this.tokenBridgeObjectId))?void 0:s.replace("0x","");if(!a)throw new Error(`Original token bridge package ID not found for object ID ${this.tokenBridgeObjectId}`);const o="a11ceb0b060000000901000a020a14031e1704350405392d07669f01088502600ae502050cea02160004010b010c0205020d000002000201020003030c020001000104020700000700010001090801010c020a050600030803040202000302010702080007080100020800080303090002070801010b020209000901010608010105010b0202080008030209000504434f494e095478436f6e7465787408565f5f305f325f3011577261707065644173736574536574757004636f696e0e6372656174655f777261707065640b64756d6d795f6669656c6404696e697414707265706172655f726567697374726174696f6e0f7075626c69635f7472616e736665720673656e646572087472616e736665720a74785f636f6e746578740f76657273696f6e5f636f6e74726f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"+a+"00020106010000000001090b0031"+r.toString(16).padStart(2,"0")+"0a0138000b012e110238010200";return{modules:[n.b2.encode(n.ar.decode(o))],dependencies:["0x1","0x2",t,e].map((e=>Qe(e)))}}createUnsignedTx(e,t){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new c(e,this.network,this.chain,t,r)}}(0,s.r)(i._,"TokenBridge",Hr)}}]);
//# sourceMappingURL=6446.630c66c9.chunk.js.map