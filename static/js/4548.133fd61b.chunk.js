"use strict";(self.webpackChunkmultichain_poc=self.webpackChunkmultichain_poc||[]).push([[4548],{9312:(e,t,r)=>{r.d(t,{c:()=>c});var o=r(7126);function n(e,t){switch(e.binary){case"bytes":if("layout"in e){const{custom:r}=e;return void 0===r||"function"!=typeof r.from?s(e.layout,r?r.from:t):t}case"int":case"uint":{const{custom:r}=e;return null!=e&&e.omit?void 0:(0,o.cX)(r)?r:(0,o.cY)(r)?r.to:t}case"array":return Array.isArray(t)?t.map((t=>s(e.layout,t))):void 0;case"switch":{const r=t[e.idTag??"id"],[o,n]=e.layouts.find((e=>{let[t]=e;return(Array.isArray(t)?t[1]:t)==r}));return{[e.idTag??"id"]:r,...s(n,t)}}}}function s(e,t){if(t=t??{},(0,o.cW)(e))return n(e,t);const r={};for(const o of e){const e=n(o,t[o.name]??{});void 0!==e&&(r[o.name]=e)}return r}function a(e,t){return s(e,t)}function i(e){return[...o.c_,(0,o.c$)(e)]}function c(e,t){const[r,n]=(0,o.cZ)(e),s=a(i(e),t);return{protocolName:r,payloadName:n,payloadLiteral:e,...a(o.d0,t),...s,hash:(0,o.cF)((0,o.cT)(i(e),s))}}},4548:(e,t,r)=>{r.r(t),r.d(t,{CosmwasmWormholeCore:()=>h});var o=r(8532),n=r(9312),s=r(7126),a=r(6310),i=Object.defineProperty,c=(e,t,r)=>(((e,t,r)=>{t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r})(e,"symbol"!=typeof t?t+"":t,r),r);class h{constructor(e,t,r,o){c(this,"network"),c(this,"chain"),c(this,"rpc"),c(this,"contracts"),c(this,"coreAddress"),this.network=e,this.chain=t,this.rpc=r,this.contracts=o;const n=this.contracts.coreBridge;if(!n)throw new Error(`Wormhole Token Bridge contract for domain ${t} not found`);this.coreAddress=n}getGuardianSet(e){throw new Error("Method not implemented.")}getGuardianSetIndex(){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[r,n]=await o.C.chainFromRpc(e),s=t[n];if(s.network!==r)throw new Error(`Network mismatch: ${s.network} != ${r}`);return new h(r,n,e,s.contracts)}async*publishMessage(e,t,r,o){throw new Error("Method not implemented.")}async*verifyMessage(e,t){throw new Error("Not implemented.")}async parseTransaction(e){const t=await this.rpc.getTx(e);if(!t)throw new Error("No transaction found for txid: "+e);return[h.parseWormholeMessageId(this.chain,this.coreAddress,t)]}async parseMessages(e){const t=await this.rpc.getTx(e);if(!t)throw new Error("No transaction found for txid: "+e);return[h.parseWormholeMessage(this.chain,this.coreAddress,t)]}static parseWormholeMessage(e,t,r){const o=r.events.filter((e=>"wasm"===e.type&&"_contract_address"===e.attributes[0].key&&e.attributes[0].value===t));if(0===o.length)throw new Error("No wormhole message found in tx");o.length>1&&console.error(`Expected single message, found ${o.length}`);const[a]=o,i=Object.fromEntries(a.attributes.map((e=>[e.key.split(".")[1],e.value])));return(0,n.c)("Uint8Array",{emitterChain:e,emitterAddress:new s.as(s.ar.decode(i.sender)),sequence:BigInt(i.sequence),guardianSet:0,timestamp:Number(i.block_time),consistencyLevel:0,nonce:Number(i.nonce),signatures:[],payload:s.ar.decode(i.message)})}static parseWormholeMessageId(e,t,r){const o=h.parseWormholeMessage(e,t,r);return{chain:o.emitterChain,emitter:o.emitterAddress,sequence:o.sequence}}}(0,a.r)(o._,"WormholeCore",h)}}]);
//# sourceMappingURL=4548.133fd61b.chunk.js.map