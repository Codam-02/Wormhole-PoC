{"version":3,"file":"static/js/8944.11a6cfce.chunk.js","mappings":"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","sources":["../node_modules/@wormhole-foundation/wormhole-connect/lib/aptos-fTgRd9kK.mjs","../node_modules/@wormhole-foundation/wormhole-connect/lib/chain-tk4BDPwT.mjs"],"sourcesContent":["var A = Object.defineProperty;\nvar S = (a, t, n) => t in a ? A(a, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : a[t] = n;\nvar r = (a, t, n) => (S(a, typeof t != \"symbol\" ? t + \"\" : t, n), n);\nimport { au as v, ae as b, av as T, aw as x, ax as d, ay as I, aZ as N, az as k, as as _, ar as g, at as $, a_ as O, aC as B } from \"./index-DV1w5RNX.mjs\";\nimport { C as F, P as E } from \"./chain-tk4BDPwT.mjs\";\nconst C = \"0x1::aptos_coin::AptosCoin\", u = \"::\";\nclass y extends F {\n}\nconst m = \"Aptos\", P = (a) => /^(0x)?[0-9a-fA-F]+::\\w+::\\w+$/.test(a), q = (a) => a.split(u)[0], h = class h extends E {\n  constructor(t, n) {\n    super(t, n ?? v(t, h._platform));\n  }\n  getRpc(t) {\n    if (t in this.config)\n      return new b(this.config[t].rpc);\n    throw new Error(\"No configuration available for chain: \" + t);\n  }\n  getChain(t, n) {\n    if (t in this.config)\n      return new y(t, this);\n    throw new Error(\"No configuration available for chain: \" + t);\n  }\n  static nativeTokenId(t, n) {\n    if (!this.isSupportedChain(n))\n      throw new Error(`invalid chain: ${n}`);\n    return T.tokenId(n, C);\n  }\n  static isNativeTokenId(t, n, i) {\n    return !this.isSupportedChain(n) || i.chain !== n ? !1 : this.nativeTokenId(t, n) == i;\n  }\n  static isSupportedChain(t) {\n    return x(t) === h._platform;\n  }\n  static async getDecimals(t, n, i) {\n    if (d(i))\n      return I(h._platform);\n    const s = i.toString(), c = `0x1::coin::CoinInfo<${s}>`;\n    return (await n.getAccountResource(s.split(u)[0], c)).data.decimals;\n  }\n  static async getBalance(t, n, i, s) {\n    const c = d(s) ? C : s.toString(), e = new N(n);\n    try {\n      return await e.checkBalance(i, {\n        coinType: c\n      });\n    } catch (o) {\n      if (o.errorCode === \"resource_not_found\" && o.status === 404)\n        return null;\n      throw o;\n    }\n  }\n  static async getBalances(t, n, i, s) {\n    return (await Promise.all(s.map(async (e) => {\n      const o = await this.getBalance(t, n, i, e);\n      return { [d(e) ? \"native\" : new f(e).toString()]: o };\n    }))).reduce((e, o) => Object.assign(e, o), {});\n  }\n  static async sendWait(t, n, i) {\n    const s = [];\n    for (const c of i) {\n      const e = await n.submitTransaction(c), o = await n.waitForTransactionWithResult(e.hash);\n      s.push(o.hash);\n    }\n    return s;\n  }\n  static async getLatestBlock(t) {\n    const n = await t.getLedgerInfo();\n    return Number(n.block_height);\n  }\n  static async getLatestFinalizedBlock(t) {\n    const n = await t.getLedgerInfo();\n    return Number(n.block_height);\n  }\n  static chainFromChainId(t) {\n    const n = k(h._platform, BigInt(t));\n    if (!n)\n      throw new Error(`No matching chainId to determine network and chain: ${t}`);\n    const [i, s] = n;\n    return [i, s];\n  }\n  static async chainFromRpc(t) {\n    const i = await t.getChainId();\n    return this.chainFromChainId(i.toString());\n  }\n};\nr(h, \"_platform\", m);\nlet l = h;\nfunction R(a) {\n  return a.length % 2 !== 0 || a.length < 66 ? (a = a.startsWith(\"0x\") ? a.slice(2) : a, \"0x\" + a.padStart(64, \"0\")) : a;\n}\nconst p = class p {\n  constructor(t) {\n    r(this, \"platform\", l._platform);\n    r(this, \"type\", \"Native\");\n    // Full 32 bytes of Address\n    r(this, \"address\");\n    // Optional module and contract name\n    r(this, \"module\");\n    if (p.instanceof(t))\n      this.address = t.address, this.module = t.module;\n    else if (_.instanceof(t))\n      this.address = t.toUint8Array();\n    else if (typeof t == \"string\") {\n      if (P(t)) {\n        const n = t.split(u);\n        this.module = n.slice(1).join(u), t = n[0];\n      }\n      if (t = R(t), !g.valid(t))\n        throw new Error(\"Invalid Aptos address: \" + t);\n      this.address = g.decode(t);\n    } else\n      this.address = t;\n  }\n  unwrap() {\n    const t = g.encode(this.address).replace(/^0+/, \"\"), n = this.module ? u + this.module : \"\";\n    return `0x${t}${n}`;\n  }\n  toString() {\n    return this.unwrap();\n  }\n  toNative() {\n    return this;\n  }\n  toUint8Array() {\n    return this.address;\n  }\n  toUniversalAddress() {\n    return new _(this.toUint8Array());\n  }\n  static instanceof(t) {\n    return t.platform === l._platform;\n  }\n  equals(t) {\n    return p.instanceof(t) ? t.unwrap() === this.unwrap() : this.toUniversalAddress().equals(t);\n  }\n};\nr(p, \"byteSize\", 32);\nlet f = p;\n$(m, f);\nasync function U(a, t) {\n  const [n, i] = await l.chainFromRpc(a);\n  return new W(i, new O(g.decode(t)), a);\n}\nclass W {\n  constructor(t, n, i, s) {\n    r(this, \"_chain\");\n    r(this, \"_account\");\n    r(this, \"_rpc\");\n    r(this, \"_debug\");\n    this._chain = t, this._account = n, this._rpc = i, this._debug = s;\n  }\n  chain() {\n    return this._chain;\n  }\n  address() {\n    return this._account.address().hex();\n  }\n  async signAndSend(t) {\n    const n = [];\n    for (const i of t) {\n      const { description: s, transaction: c } = i;\n      this._debug && console.log(`Signing: ${s} for ${this.address()}`);\n      const e = {\n        gas_unit_price: \"100\",\n        max_gas_amount: \"30000\",\n        expiration_timestamp_secs: (BigInt(Date.now() + 8 * 60 * 60 * 1e3) / 1000n).toString()\n      }, o = await this._rpc.generateTransaction(this._account.address(), c, e), { hash: w } = await this._simSignSend(o);\n      n.push(w);\n    }\n    return n;\n  }\n  async _simSignSend(t) {\n    return await this._rpc.simulateTransaction(this._account, t).then((n) => n.forEach((i) => {\n      if (!i.success)\n        throw new Error(`Transaction failed: ${i.vm_status}\n${JSON.stringify(i, null, 2)}`);\n    })), this._rpc.signTransaction(this._account, t).then((n) => this._rpc.submitTransaction(n)).then((n) => this._rpc.waitForTransactionWithResult(n.hash));\n  }\n}\nconst j = {\n  Address: f,\n  Platform: l,\n  getSigner: U,\n  protocols: {\n    WormholeCore: () => import(\"./index-Dxa4Ra4a.mjs\"),\n    TokenBridge: () => import(\"./index-Dwpsg6Mq.mjs\")\n  },\n  getChain: (a, t, n) => new y(t, new l(a, B(a, m, {\n    [t]: n\n  })))\n}, M = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: j\n}, Symbol.toStringTag, { value: \"Module\" }));\nexport {\n  l as A,\n  u as a,\n  C as b,\n  q as c,\n  f as d,\n  M as e,\n  P as i\n};\n","var p = Object.defineProperty;\nvar u = (o, t, i) => t in o ? p(o, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : o[t] = i;\nvar e = (o, t, i) => (u(o, typeof t != \"symbol\" ? t + \"\" : t, i), i);\nimport { cg as d, aw as f, ax as m, ch as w, ci as B, cj as k } from \"./index-DV1w5RNX.mjs\";\nfunction P(o) {\n  return \"getVersion\" in o;\n}\nconst s = {};\nfunction R(o, t, i) {\n  t in s || (s[t] = {});\n  const r = s[t];\n  if (o in r)\n    throw new Error(`Protocol ${o} for protocol ${t} has already registered`);\n  s[t][o] = i;\n}\nfunction C(o, t) {\n  const i = d(o) ? f.get(o) : o;\n  return t in s ? i in s[t] : !1;\n}\nfunction g(o, t) {\n  if (t in s) {\n    const i = s[t];\n    if (i && o in i) {\n      const r = i[o];\n      if (r)\n        return r;\n    }\n  }\n  throw new Error(`No protocols registered for ${o}:${t}. This may be because the platform specific protocol implementation is not registered (by installing and importing it) or no implementation exists for this platform`);\n}\nconst T = (o, t, i, r) => g(o, t).fromRpc(i, r);\nclass W {\n  constructor(t, i) {\n    e(this, \"network\");\n    e(this, \"config\");\n    this.network = t, this.config = i;\n  }\n  /** provides access to the static attributes of the PlatformContext class */\n  utils() {\n    return this.constructor;\n  }\n  /** Create a new Protocol Client instance by protocol name using the RPC connection to determine the network */\n  getProtocol(t, i) {\n    return T(this.utils()._platform, t, i, this.config);\n  }\n  /** Get the underlying ProtocolInitializer to construct yourself */\n  getProtocolInitializer(t) {\n    return g(this.utils()._platform, t);\n  }\n  /** Look up transaction logs and parse out Wormhole messages */\n  async parseWormholeMessages(t, i, r) {\n    return (await this.getProtocol(\"WormholeCore\", i)).parseTransaction(r);\n  }\n}\nclass I {\n  constructor(t, i, r) {\n    e(this, \"network\");\n    e(this, \"chain\");\n    e(this, \"config\");\n    e(this, \"platform\");\n    e(this, \"rpc\");\n    // Cached Protocol clients\n    e(this, \"protocols\", /* @__PURE__ */ new Map());\n    /**\n     * Check to see if the Wormhole Core protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Wormhole Core protocol\n     */\n    e(this, \"supportsWormholeCore\", () => this.supportsProtocol(\"WormholeCore\"));\n    /**\n     * Get the Wormhole Core protocol client for this chain\n     * @returns the Wormhole Core protocol client for this chain\n     */\n    e(this, \"getWormholeCore\", () => this.getProtocol(\"WormholeCore\"));\n    /**\n     * Check to see if the Token Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Token Bridge protocol\n     */\n    e(this, \"supportsTokenBridge\", () => this.supportsProtocol(\"TokenBridge\"));\n    /**\n     * Get the Token Bridge protocol client for this chain\n     * @returns the Token Bridge protocol client for this chain\n     */\n    e(this, \"getTokenBridge\", () => this.getProtocol(\"TokenBridge\"));\n    /**\n     * Check to see if the Automatic Token Bridge protocol is supported by this chain\n     * @returns  a boolean indicating if this chain supports the Automatic Token Bridge protocol\n     */\n    e(this, \"supportsAutomaticTokenBridge\", () => this.supportsProtocol(\"AutomaticTokenBridge\"));\n    /**\n     * Get the Automatic Token Bridge protocol client for this chain\n     * @returns the Automatic Token Bridge protocol client for this chain\n     */\n    e(this, \"getAutomaticTokenBridge\", () => this.getProtocol(\"AutomaticTokenBridge\"));\n    /**\n     * Check to see if the Circle Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Circle Bridge protocol\n     */\n    e(this, \"supportsCircleBridge\", () => this.supportsProtocol(\"CircleBridge\"));\n    /**\n     * Get the Circle Bridge protocol client for this chain\n     * @returns the Circle Bridge protocol client for this chain\n     */\n    e(this, \"getCircleBridge\", () => this.getProtocol(\"CircleBridge\"));\n    /**\n     * Check to see if the Automatic Circle Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Automatic Circle Bridge protocol\n     */\n    e(this, \"supportsAutomaticCircleBridge\", () => this.supportsProtocol(\"AutomaticCircleBridge\"));\n    /**\n     * Get the Automatic Circle Bridge protocol client for this chain\n     * @returns the Automatic Circle Bridge protocol client for this chain\n     */\n    e(this, \"getAutomaticCircleBridge\", () => this.getProtocol(\"AutomaticCircleBridge\"));\n    /**\n     * Check to see if the IBC Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the IBC Bridge protocol\n     */\n    e(this, \"supportsIbcBridge\", () => this.supportsProtocol(\"IbcBridge\"));\n    /**\n     * Get the IBC Bridge protocol client for this chain\n     * @returns the IBC Bridge protocol client for this chain\n     */\n    e(this, \"getIbcBridge\", () => this.getProtocol(\"IbcBridge\"));\n    /**\n     * Check to see if the Portico Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Portico Bridge protocol\n     */\n    e(this, \"supportsPorticoBridge\", () => this.supportsProtocol(\"PorticoBridge\"));\n    /**\n     * Get the Portico Bridge protocol client for this chain\n     * @returns the Portico Bridge protocol client for this chain\n     */\n    e(this, \"getPorticoBridge\", () => this.getProtocol(\"PorticoBridge\"));\n    this.config = i.config[t], this.platform = i, this.chain = this.config.key, this.network = this.config.network, this.rpc = r;\n  }\n  /**\n   * Get an RPC connection for this chain, uses the configuration passed in\n   * the initial constructor\n   *\n   * @returns the RPC connection for this chain\n   */\n  getRpc() {\n    return this.rpc = this.rpc ? this.rpc : this.platform.getRpc(this.chain), this.rpc;\n  }\n  /**\n   *  Get the number of decimals for a token\n   *\n   *  @param token the token to get the decimals for\n   *  @returns the number of decimals for the token\n   */\n  async getDecimals(t) {\n    if (m(t))\n      return this.config.nativeTokenDecimals;\n    if (this.config.tokenMap) {\n      const i = w({ chain: this.chain, address: t }), r = B(this.network, this.chain, i);\n      if (r)\n        return r.decimals;\n    }\n    return this.platform.utils().getDecimals(this.chain, await this.getRpc(), t);\n  }\n  /**\n   * Get the balance of a token for a given address\n   *\n   * @param walletAddr the address to get the balance for\n   * @param token the token to get the balance for\n   * @returns the balance of the token for the address\n   *\n   */\n  async getBalance(t, i) {\n    return this.platform.utils().getBalance(this.chain, await this.getRpc(), t, i);\n  }\n  /**\n   * Get the latest block number seen by the chain according to the RPC\n   *\n   * @returns the latest block number\n   */\n  async getLatestBlock() {\n    return this.platform.utils().getLatestBlock(await this.getRpc());\n  }\n  /**\n   * Get the latest _finalized_ block number seen by the chain according to the RPC\n   *\n   * @returns the latest finalized block number\n   */\n  async getLatestFinalizedBlock() {\n    return this.platform.utils().getLatestFinalizedBlock(await this.getRpc());\n  }\n  /**\n   * Parse the Wormhole Core messages from a transaction\n   *\n   * @param txid the transaction to parse\n   * @returns the Wormhole Core messages emitted by the transaction\n   */\n  async parseTransaction(t) {\n    return this.platform.parseWormholeMessages(this.chain, await this.getRpc(), t);\n  }\n  /**\n   *  Send a transaction and wait for it to be confirmed\n   *\n   * @param stxns the signed transaction to send\n   * @returns the transaction hashes of the sent transactions\n   */\n  async sendWait(t) {\n    return this.platform.utils().sendWait(this.chain, await this.getRpc(), t);\n  }\n  /**\n   * Get the token data from the local cache if available\n   * @param symbol the symbol of the token to get\n   * @returns the token data if available\n   */\n  getToken(t) {\n    if (this.config.tokenMap && t in this.config.tokenMap)\n      return this.config.tokenMap[t];\n  }\n  /**\n   * Get the token id of the wrapped token for the native gas token\n   *\n   * @returns the wrapped token for the native gas token\n   */\n  async getNativeWrappedTokenId() {\n    if (this.config.wrappedNative) {\n      const { address: i } = this.config.wrappedNative;\n      return { chain: this.chain, address: k(this.chain, i) };\n    }\n    const t = await this.getTokenBridge();\n    return { chain: this.chain, address: await t.getWrappedNative() };\n  }\n  /**\n   * Get the token account for a given address and token\n   *\n   * @remarks\n   * This is really only useful in the context of Solana but in order\n   * to provide a consistent interface, we provide it here.\n   *\n   * @param address the address to get the token account for\n   * @param token the token to get the token account for\n   * @returns the token account for the address and token\n   */\n  async getTokenAccount(t, i) {\n    return { chain: this.chain, address: t };\n  }\n  /**\n   * Check to see if a given protocol is supported by this chain\n   * by checking if it is registered in the platform and the configuration\n   * is available and correct\n   *\n   * @param protocolName the name of the Protocol to check for support\n   * @returns a boolean indicating if this protocol is supported\n   */\n  supportsProtocol(t) {\n    return C(this.chain, t);\n  }\n  /**\n   * Construct a protocol client for the given protocol\n   *\n   * Note: If no contracts are passed, we assume the default contracts should be used\n   * and that the protocol client is cacheable\n   *\n   * @param protocolName The name of the protocol to construct a client for\n   * @returns An instance of the protocol client that implements the protocol interface for the chain\n   */\n  async getProtocol(t, i, r) {\n    if (!i && this.protocols.has(t))\n      return this.protocols.get(t);\n    const n = i ? { ...this.config.contracts, ...i } : this.config.contracts, a = r ?? await this.getRpc(), h = this.platform.getProtocolInitializer(t);\n    let c;\n    if (r) {\n      if (i)\n        throw new Error(\"Custom contracts are currently not supported with custom rpc connection. Add the contracts to the base config.\");\n      c = await this.platform.getProtocol(t, a);\n    } else if (P(h)) {\n      const l = await h.getVersion(a, n);\n      c = new h(this.network, this.chain, a, n, l);\n    } else\n      c = new h(this.network, this.chain, a, n);\n    return i || this.protocols.set(t, c), c;\n  }\n}\nexport {\n  I as C,\n  W as P,\n  R as r\n};\n"],"names":["A","Object","defineProperty","r","a","t","n","S","enumerable","configurable","writable","value","C","u","y","F","m","P","test","q","split","h","E","constructor","super","v","_platform","getRpc","this","config","b","rpc","Error","getChain","nativeTokenId","isSupportedChain","T","tokenId","isNativeTokenId","i","chain","x","getDecimals","d","I","s","toString","c","getAccountResource","data","decimals","getBalance","e","N","checkBalance","coinType","o","errorCode","status","getBalances","Promise","all","map","async","f","reduce","assign","sendWait","submitTransaction","waitForTransactionWithResult","hash","push","getLatestBlock","getLedgerInfo","Number","block_height","getLatestFinalizedBlock","chainFromChainId","k","BigInt","chainFromRpc","getChainId","l","p","instanceof","address","module","_","toUint8Array","slice","join","length","startsWith","padStart","g","valid","decode","unwrap","encode","replace","toNative","toUniversalAddress","platform","equals","$","W","_chain","_account","_rpc","_debug","hex","signAndSend","description","transaction","console","log","gas_unit_price","max_gas_amount","expiration_timestamp_secs","Date","now","generateTransaction","w","_simSignSend","simulateTransaction","then","forEach","success","vm_status","JSON","stringify","signTransaction","j","Address","Platform","getSigner","O","protocols","WormholeCore","TokenBridge","B","M","freeze","__proto__","default","Symbol","toStringTag","R","network","utils","getProtocol","fromRpc","getProtocolInitializer","parseWormholeMessages","parseTransaction","Map","supportsProtocol","key","nativeTokenDecimals","tokenMap","getToken","getNativeWrappedTokenId","wrappedNative","getTokenBridge","getWrappedNative","getTokenAccount","get","has","contracts","getVersion","set"],"sourceRoot":""}