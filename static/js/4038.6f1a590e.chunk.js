"use strict";(self.webpackChunkmultichain_poc=self.webpackChunkmultichain_poc||[]).push([[4038],{4038:(e,t,s)=>{s.r(t),s.d(t,{AptosTokenBridge:()=>h});var n=s(7126),r=s(8944),a=s(6310),i=Object.defineProperty,o=(e,t,s)=>(((e,t,s)=>{t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s})(e,"symbol"!=typeof t?t+"":t,s),s);class d{constructor(e,t,s,n){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];o(this,"transaction"),o(this,"network"),o(this,"chain"),o(this,"description"),o(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=s,this.description=n,this.parallelizable=r}}const c=[{name:"tokenBridgeAddress",...n.cN},{name:"chain",...(0,n.cS)()},{name:"domainSeparator",binary:"bytes",custom:n.b3.encode(r.a),omit:!0},{name:"tokenId",...n.cN},{name:"domainSeparator",binary:"bytes",custom:new Uint8Array([255]),omit:!0}];class h{constructor(e,t,s,r){o(this,"network"),o(this,"chain"),o(this,"connection"),o(this,"contracts"),o(this,"chainId"),o(this,"tokenBridgeAddress"),this.network=e,this.chain=t,this.connection=s,this.contracts=r,this.chainId=(0,n.bW)(t);const a=r.tokenBridge;if(!a)throw new Error(`TokenBridge contract Address for chain ${t} not found`);this.tokenBridgeAddress=a}static async fromRpc(e,t){const[s,n]=await r.A.chainFromRpc(e),a=t[n];if(a.network!==s)throw new Error("Network mismatch "+a.network+" !== "+s);return new h(s,n,e,a.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){const t=e.toString().split(r.a);let s;if(s=(await this.connection.getAccountResource(t[0],`${this.tokenBridgeAddress}::state::OriginInfo`)).data,!s)throw n.cD;return{chain:(0,n.cE)(parseInt(s.token_chain.number)),address:new n.as(s.token_address.external_address)}}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){const t=await this.getAssetFullyQualifiedType(e);if(!t)throw new Error("Invalid asset address.");return await this.connection.getAccountResource((0,r.c)(t),`${this.tokenBridgeAddress}::state::OriginInfo`),(0,n.cj)(this.chain,t)}async isTransferCompleted(e){const t=(await this.connection.getAccountResource(this.tokenBridgeAddress,`${this.tokenBridgeAddress}::state::State`)).data.consumed_vaas.elems.handle;try{return await this.connection.getTableItem(t,{key_type:"vector<u8>",value_type:"u8",key:`0x${n.d.Buffer.from((0,n.cF)(e.hash)).toString("hex")}`}),!0}catch{return!1}}async getWrappedNative(){return(0,n.cj)(this.chain,r.b)}async*createAttestation(e,t){const s={chain:this.chain,address:new r.d(e)},n=await this.getAssetFullyQualifiedType(s);if(!n)throw new Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::attest_token::attest_token_entry`,type_arguments:[n],arguments:[]},"Aptos.AttestToken")}async*submitAttestation(e,t){yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin_type`,type_arguments:[],arguments:[(0,n.cw)(e)]},"Aptos.CreateWrappedCoinType");const s=await this.getAssetFullyQualifiedType(e.payload.token);if(!s)throw new Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin`,type_arguments:[s],arguments:[(0,n.cw)(e)]},"Aptos.CreateWrappedCoin")}async*transfer(e,t,s,a,i){const o=(0,n.ax)(s)?r.b:s.toString(),d=t.address.toUniversalAddress().toUint8Array(),c=(0,n.bW)(t.chain);i?yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_with_payload_entry`,type_arguments:[o],arguments:[a,c,d,0n,i]},"Aptos.TransferTokensWithPayload"):yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_entry`,type_arguments:[o],arguments:[a,c,d,0n,0n]},"Aptos.TransferTokens")}redeem(e,t){try{var s=this;return async function*(){const e=t.payload.token.chain===s.chain?await s.getTypeFromExternalAddress(t.payload.token.address.toString()):await s.getAssetFullyQualifiedType(t.payload.token);if(!e)throw new Error("Invalid asset address.");yield s.createUnsignedTx({function:`${s.tokenBridgeAddress}::complete_transfer::submit_vaa_and_register_entry`,type_arguments:[e],arguments:[(0,n.cw)(t)]},"Aptos.CompleteTransfer")}()}catch(e){return Promise.reject(e)}}async getAssetFullyQualifiedType(e){return e.chain===this.chain?(0,r.i)(e.address.toString())?e.address.toString():null:`${h.getForeignAssetAddress(this.chain,this.tokenBridgeAddress,e)}::coin::T`}async getTypeFromExternalAddress(e){try{const t=(await this.connection.getAccountResource(this.tokenBridgeAddress,`${this.tokenBridgeAddress}::state::State`)).data,{handle:s}=t.native_infos,a=await this.connection.getTableItem(s,{key_type:`${this.tokenBridgeAddress}::token_hash::TokenHash`,value_type:"0x1::type_info::TypeInfo",key:{hash:e}});return a?[a.account_address,n.ar.decode(a.module_name),n.ar.decode(a.struct_name)].join(r.a):null}catch{return null}}static getForeignAssetAddress(e,t,s){if((0,n.ax)(s.address))throw new Error("Invalid token address");const a=(i={chain:s.chain,tokenBridgeAddress:new r.d(t).toUniversalAddress(),tokenId:s.address.toUniversalAddress()},(0,n.cT)(c,i));var i;return n.ar.encode((0,n.cU)(a),!0)}createUnsignedTx(e,t){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new d(e,this.network,this.chain,t,s)}}(0,a.r)("Aptos","TokenBridge",h)}}]);
//# sourceMappingURL=4038.6f1a590e.chunk.js.map