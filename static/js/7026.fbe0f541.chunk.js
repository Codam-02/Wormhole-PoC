"use strict";(self.webpackChunkmultichain_poc=self.webpackChunkmultichain_poc||[]).push([[7026],{7026:(e,n,t)=>{t.r(n),t.d(n,{SolanaCircleBridge:()=>Sn,idl:()=>kn});var s=t(7126),i=t(6310),a=t(5002),r=t(9122),o=Object.defineProperty,u=(e,n,t)=>(((e,n,t)=>{n in e?o(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);class c extends TypeError{constructor(e,n){let t;const{message:s,...i}=e,{path:a}=e;super(0===a.length?s:"At path: "+a.join(".")+" -- "+s),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>{var s;return null!=(s=t)?s:t=[e,...n()]}}}function m(e){return"object"==typeof e&&null!=e}function d(e){return"string"==typeof e?JSON.stringify(e):""+e}function l(e,n,t,s){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:i,branch:a}=n,{type:r}=t,{refinement:o,message:u="Expected a value of type `"+r+"`"+(o?" with refinement `"+o+"`":"")+", but received: `"+d(s)+"`"}=e;return{value:s,type:r,refinement:o,key:i[i.length-1],path:i,branch:a,...e,message:u}}function*g(e,n,t,s){(function(e){return m(e)&&"function"==typeof e[Symbol.iterator]})(e)||(e=[e]);for(const i of e){const e=l(i,n,t,s);e&&(yield e)}}function p(e,n){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return function*(){const{path:s=[],branch:i=[e],coerce:a=!1,mask:r=!1}=t,o={path:s,branch:i};if(a&&(e=n.coercer(e,o),r&&"type"!==n.type&&m(n.schema)&&m(e)&&!Array.isArray(e)))for(const t in e)void 0===n.schema[t]&&delete e[t];let u=!0;for(const t of n.validator(e,o))u=!1,yield[t,void 0];for(let[t,c,d]of n.entries(e,o)){const n=p(c,d,{path:void 0===t?s:[...s,t],branch:void 0===t?i:[...i,c],coerce:a,mask:r});for(const s of n)s[0]?(u=!1,yield[s[0],void 0]):a&&(c=s[1],void 0===t?e=c:e instanceof Map?e.set(t,c):e instanceof Set?e.add(c):m(e)&&(e[t]=c))}if(u)for(const t of n.refiner(e,o))u=!1,yield[t,void 0];u&&(yield[void 0,e])}()}let y=class{constructor(e){const{type:n,schema:t,validator:s,refiner:i,coercer:a=e=>e,entries:r=function*(){}}=e;this.type=n,this.schema=t,this.entries=r,this.coercer=a,this.validator=s?(e,n)=>g(s(e,n),n,this,e):()=>[],this.refiner=i?(e,n)=>g(i(e,n),n,this,e):()=>[]}assert(e){return function(e,n){const t=b(e,n);if(t[0])throw t[0]}(e,this)}create(e){return h(e,this)}is(e){return f(e,this)}mask(e){return function(e,n){const t=b(e,n,{coerce:!0,mask:!0});if(t[0])throw t[0];return t[1]}(e,this)}validate(e){return b(e,this,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{})}};function h(e,n){const t=b(e,n,{coerce:!0});if(t[0])throw t[0];return t[1]}function f(e,n){return!b(e,n)[0]}function b(e,n){const t=p(e,n,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}),s=function(e){const{done:n,value:t}=e.next();return n?void 0:t}(t);return s[0]?[new c(s[0],(function*(){for(const e of t)e[0]&&(yield e[0])})),void 0]:[void 0,s[1]]}function S(e,n){return new y({type:e,schema:null,validator:n})}function k(e){return new y({type:"array",schema:e,*entries(n){if(e&&Array.isArray(n))for(const[t,s]of n.entries())yield[t,s,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||"Expected an array value, but received: "+d(e)})}function M(){return S("boolean",(e=>"boolean"==typeof e))}function v(e){return S("instance",(n=>n instanceof e||"Expected a `"+e.name+"` instance, but received: "+d(n)))}function w(e){const n=d(e),t=typeof e;return new y({type:"literal",schema:"string"===t||"number"===t||"boolean"===t?e:null,validator:t=>t===e||"Expected the literal `"+n+"`, but received: "+d(t)})}function I(e){return new y({...e,validator:(n,t)=>null===n||e.validator(n,t),refiner:(n,t)=>null===n||e.refiner(n,t)})}function P(){return S("number",(e=>"number"==typeof e&&!isNaN(e)||"Expected a number, but received: "+d(e)))}function A(e){return new y({...e,validator:(n,t)=>void 0===n||e.validator(n,t),refiner:(n,t)=>void 0===n||e.refiner(n,t)})}function T(e,n){return new y({type:"record",schema:null,*entries(t){if(m(t))for(const s in t){const i=t[s];yield[s,s,e],yield[s,i,n]}},validator:e=>m(e)||"Expected an object, but received: "+d(e)})}function x(){return S("string",(e=>"string"==typeof e||"Expected a string, but received: "+d(e)))}function B(e){const n=S("never",(()=>!1));return new y({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const s=Math.max(e.length,t.length);for(let i=0;i<s;i++)yield[i,t[i],e[i]||n]}},validator:e=>Array.isArray(e)||"Expected an array, but received: "+d(e)})}function K(e){const n=Object.keys(e);return new y({type:"type",schema:e,*entries(t){if(m(t))for(const s of n)yield[s,t[s],e[s]]},validator:e=>m(e)||"Expected an object, but received: "+d(e)})}function E(e){const n=e.map((e=>e.type)).join(" | ");return new y({type:"union",schema:null,validator(t,s){const i=[];for(const n of e){const[...e]=p(t,n,s),[a]=e;if(!a[0])return[];for(const[n]of e)n&&i.push(n)}return["Expected the value to satisfy a union of `"+n+"`, but received: "+d(t),...i]}})}function O(){return S("unknown",(()=>!0))}function W(e,n,t){return new y({...e,coercer:(s,i)=>f(s,n)?e.coercer(t(s,i),i):e.coercer(s,i)})}const z=()=>{const e=s.aP.utils.randomPrivateKey(),n=R(e),t=new Uint8Array(64);return t.set(e),t.set(n,32),{publicKey:n,secretKey:t}},R=s.aP.getPublicKey;function C(e){try{return s.aP.ExtendedPoint.fromHex(e),!0}catch{return!1}}const H=s.aP.verify,D=e=>s.n.Buffer.isBuffer(e)?e:e instanceof Uint8Array?s.n.Buffer.from(e.buffer,e.byteOffset,e.byteLength):s.n.Buffer.from(e);class _{constructor(e){Object.assign(this,e)}encode(){return s.n.Buffer.from((0,s.aQ)(N,this))}static decode(e){return(0,s.aR)(N,this,e)}static decodeUnchecked(e){return(0,s.aS)(N,this,e)}}const N=new Map;var L;let G;let U=1;G=Symbol.toStringTag;class F extends _{constructor(e){if(super({}),this._bn=void 0,void 0!==e._bn)this._bn=e._bn;else{if("string"==typeof e){const n=s.a3.decode(e);if(32!=n.length)throw new Error("Invalid public key input");this._bn=new s.aD(n)}else this._bn=new s.aD(e);if(this._bn.byteLength()>32)throw new Error("Invalid public key input")}}static unique(){const e=new F(U);return U+=1,new F(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return s.a3.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(s.n.Buffer);if(32===e.length)return e;const n=s.n.Buffer.alloc(32);return e.copy(n,32-e.length),n}get[G](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,n,t){const i=s.n.Buffer.concat([e.toBuffer(),s.n.Buffer.from(n),t.toBuffer()]),a=(0,s.aE)(i);return new F(a)}static createProgramAddressSync(e,n){let t=s.n.Buffer.alloc(0);e.forEach((function(e){if(e.length>32)throw new TypeError("Max seed length exceeded");t=s.n.Buffer.concat([t,D(e)])})),t=s.n.Buffer.concat([t,n.toBuffer(),s.n.Buffer.from("ProgramDerivedAddress")]);const i=(0,s.aE)(t);if(C(i))throw new Error("Invalid seeds, address must fall off the curve");return new F(i)}static async createProgramAddress(e,n){return this.createProgramAddressSync(e,n)}static findProgramAddressSync(e,n){let t,i=255;for(;0!=i;){try{const a=e.concat(s.n.Buffer.from([i]));t=this.createProgramAddressSync(a,n)}catch(a){if(a instanceof TypeError)throw a;i--;continue}return[t,i]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,n){return this.findProgramAddressSync(e,n)}static isOnCurve(e){return C(new F(e).toBytes())}}L=F,F.default=new L("11111111111111111111111111111111"),N.set(F,{kind:"struct",fields:[["_bn","u256"]]}),new F("BPFLoader1111111111111111111111111111111111");const J=1232;class q{constructor(e,n){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=n}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const n of this.keySegments()){if(e<n.length)return n[e];e-=n.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach(((e,t)=>{n.set(e.toBase58(),t)}));const t=e=>{const t=n.get(e.toBase58());if(void 0===t)throw new Error("Encountered an unknown instruction account key during compilation");return t};return e.map((e=>({programIdIndex:t(e.programId),accountKeyIndexes:e.keys.map((e=>t(e.pubkey))),data:e.data})))}}const V=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"publicKey";return(0,s.aO)(32,e)},j=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"string";const n=(0,s.aG)([(0,s.aH)("length"),(0,s.aH)("lengthPadding"),(0,s.aO)((0,s.aL)((0,s.aH)(),-8),"chars")],e),t=n.decode.bind(n),i=n.encode.bind(n),a=n;return a.decode=(e,n)=>t(e,n).chars.toString(),a.encode=(e,n,t)=>{const a={chars:s.n.Buffer.from(e,"utf8")};return i(a,n,t)},a.alloc=e=>(0,s.aH)().span+(0,s.aH)().span+s.n.Buffer.from(e,"utf8").length,a};function $(e,n){const t=e=>{if(e.span>=0)return e.span;if("function"==typeof e.alloc)return e.alloc(n[e.property]);if("count"in e&&"elementLayout"in e){const s=n[e.property];if(Array.isArray(s))return s.length*t(e.elementLayout)}else if("fields"in e)return $({layout:e},n[e.property]);return 0};let s=0;return e.layout.fields.forEach((e=>{s+=t(e)})),s}function X(e){let n=0,t=0;for(;;){let s=e.shift();if(n|=(127&s)<<7*t,t+=1,!(128&s))break}return n}function Q(e,n){let t=n;for(;;){let n=127&t;if(t>>=7,0==t){e.push(n);break}n|=128,e.push(n)}}function Z(e,n){if(!e)throw new Error(n||"Assertion failed")}class Y{constructor(e,n){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=n}static compile(e,n){const t=new Map,s=e=>{const n=e.toBase58();let s=t.get(n);return void 0===s&&(s={isSigner:!1,isWritable:!1,isInvoked:!1},t.set(n,s)),s},i=s(n);i.isSigner=!0,i.isWritable=!0;for(const a of e){s(a.programId).isInvoked=!0;for(const e of a.keys){const n=s(e.pubkey);n.isSigner||(n.isSigner=e.isSigner),n.isWritable||(n.isWritable=e.isWritable)}}return new Y(n,t)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];Z(e.length<=256,"Max static account keys length exceeded");const n=e.filter((e=>{let[,n]=e;return n.isSigner&&n.isWritable})),t=e.filter((e=>{let[,n]=e;return n.isSigner&&!n.isWritable})),s=e.filter((e=>{let[,n]=e;return!n.isSigner&&n.isWritable})),i=e.filter((e=>{let[,n]=e;return!n.isSigner&&!n.isWritable})),a={numRequiredSignatures:n.length+t.length,numReadonlySignedAccounts:t.length,numReadonlyUnsignedAccounts:i.length};{Z(n.length>0,"Expected at least one writable signer key");const[e]=n[0];Z(e===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}return[a,[...n.map((e=>{let[n]=e;return new F(n)})),...t.map((e=>{let[n]=e;return new F(n)})),...s.map((e=>{let[n]=e;return new F(n)})),...i.map((e=>{let[n]=e;return new F(n)}))]]}extractTableLookup(e){const[n,t]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&e.isWritable)),[s,i]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&!e.isWritable));if(0!==n.length||0!==s.length)return[{accountKey:e.key,writableIndexes:n,readonlyIndexes:s},{writable:t,readonly:i}]}drainKeysFoundInLookupTable(e,n){const t=new Array,s=new Array;for(const[i,a]of this.keyMetaMap.entries())if(n(a)){const n=new F(i),a=e.findIndex((e=>e.equals(n)));a>=0&&(Z(a<256,"Max lookup table index exceeded"),t.push(a),s.push(n),this.keyMetaMap.delete(i))}return[t,s]}}const ee="Reached end of buffer unexpectedly";function ne(e){if(0===e.length)throw new Error(ee);return e.shift()}function te(e){for(var n=arguments.length,t=new Array(n>1?n-1:0),s=1;s<n;s++)t[s-1]=arguments[s];const[i]=t;if(2===t.length?i+(t[1]??0)>e.length:i>=e.length)throw new Error(ee);return e.splice(...t)}class se{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map((e=>new F(e))),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach((e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex])))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map((e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:s.a3.decode(e.data)})))}get addressTableLookups(){return[]}getAccountKeys(){return new q(this.staticAccountKeys)}static compile(e){const n=Y.compile(e.instructions,e.payerKey),[t,i]=n.getMessageComponents(),a=new q(i).compileInstructions(e.instructions).map((e=>({programIdIndex:e.programIdIndex,accounts:e.accountKeyIndexes,data:s.a3.encode(e.data)})));return new se({header:t,accountKeys:i,recentBlockhash:e.recentBlockhash,instructions:a})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const n=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){return e-n<this.accountKeys.length-n-this.header.numReadonlyUnsignedAccounts}return e<n-this.header.numReadonlySignedAccounts}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter(((e,n)=>!this.isProgramId(n)))}serialize(){const e=this.accountKeys.length;let n=[];Q(n,e);const t=this.instructions.map((e=>{const{accounts:n,programIdIndex:t}=e,i=Array.from(s.a3.decode(e.data));let a=[];Q(a,n.length);let r=[];return Q(r,i.length),{programIdIndex:t,keyIndicesCount:s.n.Buffer.from(a),keyIndices:n,dataLength:s.n.Buffer.from(r),data:i}}));let i=[];Q(i,t.length);let a=s.n.Buffer.alloc(J);s.n.Buffer.from(i).copy(a);let r=i.length;t.forEach((e=>{const n=(0,s.aG)([(0,s.aJ)("programIdIndex"),(0,s.aO)(e.keyIndicesCount.length,"keyIndicesCount"),(0,s.aK)((0,s.aJ)("keyIndex"),e.keyIndices.length,"keyIndices"),(0,s.aO)(e.dataLength.length,"dataLength"),(0,s.aK)((0,s.aJ)("userdatum"),e.data.length,"data")]).encode(e,a,r);r+=n})),a=a.slice(0,r);const o=(0,s.aG)([(0,s.aO)(1,"numRequiredSignatures"),(0,s.aO)(1,"numReadonlySignedAccounts"),(0,s.aO)(1,"numReadonlyUnsignedAccounts"),(0,s.aO)(n.length,"keyCount"),(0,s.aK)(V("key"),e,"keys"),V("recentBlockhash")]),u={numRequiredSignatures:s.n.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:s.n.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:s.n.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:s.n.Buffer.from(n),keys:this.accountKeys.map((e=>D(e.toBytes()))),recentBlockhash:s.a3.decode(this.recentBlockhash)};let c=s.n.Buffer.alloc(2048);const m=o.encode(u,c);return a.copy(c,m),c.slice(0,m+a.length)}static from(e){let n=[...e];const t=ne(n);if(t!==(127&t))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const i=ne(n),a=ne(n),r=X(n);let o=[];for(let l=0;l<r;l++){const e=te(n,0,32);o.push(new F(s.n.Buffer.from(e)))}const u=te(n,0,32),c=X(n);let m=[];for(let l=0;l<c;l++){const e=ne(n),t=te(n,0,X(n)),i=te(n,0,X(n)),a=s.a3.encode(s.n.Buffer.from(i));m.push({programIdIndex:e,accounts:t,data:a})}const d={header:{numRequiredSignatures:t,numReadonlySignedAccounts:i,numReadonlyUnsignedAccounts:a},recentBlockhash:s.a3.encode(s.n.Buffer.from(u)),accountKeys:o,instructions:m};return new se(d)}}const ie=s.n.Buffer.alloc(64).fill(0);class ae{constructor(e){this.keys=void 0,this.programId=void 0,this.data=s.n.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map((e=>{let{pubkey:n,isSigner:t,isWritable:s}=e;return{pubkey:n.toJSON(),isSigner:t,isWritable:s}})),programId:this.programId.toJSON(),data:[...this.data]}}}class re{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:n,nonceInfo:t}=e;this.minNonceContextSlot=n,this.nonceInfo=t}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:n,lastValidBlockHeight:t}=e;this.recentBlockhash=n,this.lastValidBlockHeight=t}else{const{recentBlockhash:n,nonceInfo:t}=e;t&&(this.nonceInfo=t),this.recentBlockhash=n}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map((e=>e.toJSON())),signers:this.signatures.map((e=>{let{publicKey:n}=e;return n.toJSON()}))}}add(){for(var e=arguments.length,n=new Array(e),t=0;t<e;t++)n[t]=arguments[t];if(0===n.length)throw new Error("No instructions");return n.forEach((e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new ae(e))})),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,n,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,n=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(e=this.recentBlockhash,n=this.instructions),!e)throw new Error("Transaction recentBlockhash required");if(n.length<1&&console.warn("No instructions provided"),this.feePayer)t=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");t=this.signatures[0].publicKey}for(let s=0;s<n.length;s++)if(void 0===n[s].programId)throw new Error(`Transaction instruction index ${s} has undefined program id`);const i=[],a=[];n.forEach((e=>{e.keys.forEach((e=>{a.push({...e})}));const n=e.programId.toString();i.includes(n)||i.push(n)})),i.forEach((e=>{a.push({pubkey:new F(e),isSigner:!1,isWritable:!1})}));const r=[];a.forEach((e=>{const n=e.pubkey.toString(),t=r.findIndex((e=>e.pubkey.toString()===n));t>-1?(r[t].isWritable=r[t].isWritable||e.isWritable,r[t].isSigner=r[t].isSigner||e.isSigner):r.push(e)})),r.sort((function(e,n){if(e.isSigner!==n.isSigner)return e.isSigner?-1:1;if(e.isWritable!==n.isWritable)return e.isWritable?-1:1;return e.pubkey.toBase58().localeCompare(n.pubkey.toBase58(),"en",{localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"})}));const o=r.findIndex((e=>e.pubkey.equals(t)));if(o>-1){const[e]=r.splice(o,1);e.isSigner=!0,e.isWritable=!0,r.unshift(e)}else r.unshift({pubkey:t,isSigner:!0,isWritable:!0});for(const s of this.signatures){const e=r.findIndex((e=>e.pubkey.equals(s.publicKey)));if(!(e>-1))throw new Error(`unknown signer: ${s.publicKey.toString()}`);r[e].isSigner||(r[e].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))}let u=0,c=0,m=0;const d=[],l=[];r.forEach((e=>{let{pubkey:n,isSigner:t,isWritable:s}=e;t?(d.push(n.toString()),u+=1,s||(c+=1)):(l.push(n.toString()),s||(m+=1))}));const g=d.concat(l),p=n.map((e=>{const{data:n,programId:t}=e;return{programIdIndex:g.indexOf(t.toString()),accounts:e.keys.map((e=>g.indexOf(e.pubkey.toString()))),data:s.a3.encode(n)}}));return p.forEach((e=>{Z(e.programIdIndex>=0),e.accounts.forEach((e=>Z(e>=0)))})),new se({header:{numRequiredSignatures:u,numReadonlySignedAccounts:c,numReadonlyUnsignedAccounts:m},accountKeys:g,recentBlockhash:e,instructions:p})}_compile(){const e=this.compileMessage(),n=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===n.length&&this.signatures.every(((e,t)=>n[t].equals(e.publicKey)))||(this.signatures=n.map((e=>({signature:null,publicKey:e})))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(){for(var e=arguments.length,n=new Array(e),t=0;t<e;t++)n[t]=arguments[t];if(0===n.length)throw new Error("No signers");const s=new Set;this.signatures=n.filter((e=>{const n=e.toString();return!s.has(n)&&(s.add(n),!0)})).map((e=>({signature:null,publicKey:e})))}sign(){for(var e=arguments.length,n=new Array(e),t=0;t<e;t++)n[t]=arguments[t];if(0===n.length)throw new Error("No signers");const s=new Set,i=[];for(const r of n){const e=r.publicKey.toString();s.has(e)||(s.add(e),i.push(r))}this.signatures=i.map((e=>({signature:null,publicKey:e.publicKey})));const a=this._compile();this._partialSign(a,...i)}partialSign(){for(var e=arguments.length,n=new Array(e),t=0;t<e;t++)n[t]=arguments[t];if(0===n.length)throw new Error("No signers");const s=new Set,i=[];for(const r of n){const e=r.publicKey.toString();s.has(e)||(s.add(e),i.push(r))}const a=this._compile();this._partialSign(a,...i)}_partialSign(e){const n=e.serialize();for(var t=arguments.length,i=new Array(t>1?t-1:0),a=1;a<t;a++)i[a-1]=arguments[a];i.forEach((e=>{const t=((e,n)=>s.aP.sign(e,n.slice(0,32)))(n,e.secretKey);this._addSignature(e.publicKey,D(t))}))}addSignature(e,n){this._compile(),this._addSignature(e,n)}_addSignature(e,n){Z(64===n.length);const t=this.signatures.findIndex((n=>e.equals(n.publicKey)));if(t<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[t].signature=s.n.Buffer.from(n)}verifySignatures(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,n){const t={};for(const{signature:s,publicKey:i}of this.signatures)null===s?n&&(t.missing||(t.missing=[])).push(i):H(s,e,i.toBytes())||(t.invalid||(t.invalid=[])).push(i);return t.invalid||t.missing?t:void 0}serialize(e){const{requireAllSignatures:n,verifySignatures:t}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(t){const e=this._getMessageSignednessErrors(s,n);if(e){let n="Signature verification failed.";throw e.invalid&&(n+=`\nInvalid signature for public key${1===e.invalid.length?"":"(s)"} [\`${e.invalid.map((e=>e.toBase58())).join("`, `")}\`].`),e.missing&&(n+=`\nMissing signature for public key${1===e.missing.length?"":"(s)"} [\`${e.missing.map((e=>e.toBase58())).join("`, `")}\`].`),new Error(n)}}return this._serialize(s)}_serialize(e){const{signatures:n}=this,t=[];Q(t,n.length);const i=t.length+64*n.length+e.length,a=s.n.Buffer.alloc(i);return Z(n.length<256),s.n.Buffer.from(t).copy(a,0),n.forEach(((e,n)=>{let{signature:i}=e;null!==i&&(Z(64===i.length,"signature has invalid length"),s.n.Buffer.from(i).copy(a,t.length+64*n))})),e.copy(a,t.length+64*n.length),Z(a.length<=J,`Transaction too large: ${a.length} > 1232`),a}get keys(){return Z(1===this.instructions.length),this.instructions[0].keys.map((e=>e.pubkey))}get programId(){return Z(1===this.instructions.length),this.instructions[0].programId}get data(){return Z(1===this.instructions.length),this.instructions[0].data}static from(e){let n=[...e];const t=X(n);let i=[];for(let a=0;a<t;a++){const e=te(n,0,64);i.push(s.a3.encode(s.n.Buffer.from(e)))}return re.populate(se.from(n),i)}static populate(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const t=new re;return t.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(t.feePayer=e.accountKeys[0]),n.forEach(((n,i)=>{const a={signature:n==s.a3.encode(ie)?null:s.a3.decode(n),publicKey:e.accountKeys[i]};t.signatures.push(a)})),e.instructions.forEach((n=>{const i=n.accounts.map((n=>{const s=e.accountKeys[n];return{pubkey:s,isSigner:t.signatures.some((e=>e.publicKey.toString()===s.toString()))||e.isAccountSigner(n),isWritable:e.isAccountWritable(n)}}));t.instructions.push(new ae({keys:i,programId:e.accountKeys[n.programIdIndex],data:s.a3.decode(n.data)}))})),t._message=e,t._json=t.toJSON(),t}}new F("SysvarC1ock11111111111111111111111111111111"),new F("SysvarEpochSchedu1e111111111111111111111111"),new F("Sysvar1nstructions1111111111111111111111111");const oe=new F("SysvarRecentB1ockHashes11111111111111111111"),ue=new F("SysvarRent111111111111111111111111111111111");function ce(e,n){const t=e.layout.span>=0?e.layout.span:$(e,n),i=s.n.Buffer.alloc(t),a=Object.assign({instruction:e.index},n);return e.layout.encode(a,i),i}new F("SysvarRewards111111111111111111111111111111"),new F("SysvarS1otHashes111111111111111111111111111"),new F("SysvarS1otHistory11111111111111111111111111"),new F("SysvarStakeHistory1111111111111111111111111");const me=(0,s.aF)("lamportsPerSignature"),de=(0,s.aG)([(0,s.aH)("version"),(0,s.aH)("state"),V("authorizedPubkey"),V("nonce"),(0,s.aG)([me],"feeCalculator")]).span,le=(pe=8,e=>{const n=(0,s.aO)(pe,e),{encode:t,decode:i}=(e=>({decode:e.decode.bind(e),encode:e.encode.bind(e)}))(n),a=n;return a.decode=(e,n)=>{const t=i(e,n);return(0,s.aT)(s.n.Buffer.from(t))},a.encode=(e,n,i)=>{const a=(0,s.aU)(e,pe);return t(a,n,i)},a}),ge=Object.freeze({Create:{index:0,layout:(0,s.aG)([(0,s.aH)("instruction"),(0,s.aI)("lamports"),(0,s.aI)("space"),V("programId")])},Assign:{index:1,layout:(0,s.aG)([(0,s.aH)("instruction"),V("programId")])},Transfer:{index:2,layout:(0,s.aG)([(0,s.aH)("instruction"),le("lamports")])},CreateWithSeed:{index:3,layout:(0,s.aG)([(0,s.aH)("instruction"),V("base"),j("seed"),(0,s.aI)("lamports"),(0,s.aI)("space"),V("programId")])},AdvanceNonceAccount:{index:4,layout:(0,s.aG)([(0,s.aH)("instruction")])},WithdrawNonceAccount:{index:5,layout:(0,s.aG)([(0,s.aH)("instruction"),(0,s.aI)("lamports")])},InitializeNonceAccount:{index:6,layout:(0,s.aG)([(0,s.aH)("instruction"),V("authorized")])},AuthorizeNonceAccount:{index:7,layout:(0,s.aG)([(0,s.aH)("instruction"),V("authorized")])},Allocate:{index:8,layout:(0,s.aG)([(0,s.aH)("instruction"),(0,s.aI)("space")])},AllocateWithSeed:{index:9,layout:(0,s.aG)([(0,s.aH)("instruction"),V("base"),j("seed"),(0,s.aI)("space"),V("programId")])},AssignWithSeed:{index:10,layout:(0,s.aG)([(0,s.aH)("instruction"),V("base"),j("seed"),V("programId")])},TransferWithSeed:{index:11,layout:(0,s.aG)([(0,s.aH)("instruction"),le("lamports"),j("seed"),V("programId")])},UpgradeNonceAccount:{index:12,layout:(0,s.aG)([(0,s.aH)("instruction")])}});var pe;class ye{constructor(){}static createAccount(e){const n=ce(ge.Create,{lamports:e.lamports,space:e.space,programId:D(e.programId.toBuffer())});return new ae({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let n,t;if("basePubkey"in e){n=ce(ge.TransferWithSeed,{lamports:BigInt(e.lamports),seed:e.seed,programId:D(e.programId.toBuffer())}),t=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{n=ce(ge.Transfer,{lamports:BigInt(e.lamports)}),t=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new ae({keys:t,programId:this.programId,data:n})}static assign(e){let n,t;if("basePubkey"in e){n=ce(ge.AssignWithSeed,{base:D(e.basePubkey.toBuffer()),seed:e.seed,programId:D(e.programId.toBuffer())}),t=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{n=ce(ge.Assign,{programId:D(e.programId.toBuffer())}),t=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new ae({keys:t,programId:this.programId,data:n})}static createAccountWithSeed(e){const n=ce(ge.CreateWithSeed,{base:D(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:D(e.programId.toBuffer())});let t=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&t.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new ae({keys:t,programId:this.programId,data:n})}static createNonceAccount(e){const n=new re;"basePubkey"in e&&"seed"in e?n.add(ye.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:de,programId:this.programId})):n.add(ye.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:de,programId:this.programId}));const t={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return n.add(this.nonceInitialize(t)),n}static nonceInitialize(e){const n=ce(ge.InitializeNonceAccount,{authorized:D(e.authorizedPubkey.toBuffer())}),t={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:ue,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new ae(t)}static nonceAdvance(e){const n=ce(ge.AdvanceNonceAccount),t={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new ae(t)}static nonceWithdraw(e){const n=ce(ge.WithdrawNonceAccount,{lamports:e.lamports});return new ae({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:ue,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){const n=ce(ge.AuthorizeNonceAccount,{authorized:D(e.newAuthorizedPubkey.toBuffer())});return new ae({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let n,t;if("basePubkey"in e){n=ce(ge.AllocateWithSeed,{base:D(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:D(e.programId.toBuffer())}),t=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{n=ce(ge.Allocate,{space:e.space}),t=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new ae({keys:t,programId:this.programId,data:n})}}ye.programId=new F("11111111111111111111111111111111"),new F("BPFLoader2111111111111111111111111111111111"),(0,s.aG)([(0,s.aH)("typeIndex"),le("deactivationSlot"),(0,s.aF)("lastExtendedSlot"),(0,s.aJ)("lastExtendedStartIndex"),(0,s.aJ)(),(0,s.aK)(V(),(0,s.aL)((0,s.aJ)(),-1),"authority")]);const he=W(v(F),x(),(e=>new F(e))),fe=B([x(),w("base64")]),be=W(v(s.n.Buffer),fe,(e=>s.n.Buffer.from(e[0],"base64")));function Se(e){return E([K({jsonrpc:w("2.0"),id:x(),result:e}),K({jsonrpc:w("2.0"),id:x(),error:K({code:O(),message:x(),data:A(S("any",(()=>!0)))})})])}const ke=Se(O());function Me(e){return W(Se(e),ke,(n=>"error"in n?n:{...n,result:h(n.result,e)}))}function ve(e){return Me(K({context:K({slot:P()}),value:e}))}function we(e){return K({context:K({slot:P()}),value:e})}const Ie=K({foundation:P(),foundationTerm:P(),initial:P(),taper:P(),terminal:P()});Me(k(I(K({epoch:P(),effectiveSlot:P(),amount:P(),postBalance:P(),commission:A(I(P()))}))));const Pe=k(K({slot:P(),prioritizationFee:P()})),Ae=K({total:P(),validator:P(),foundation:P(),epoch:P()}),Te=K({epoch:P(),slotIndex:P(),slotsInEpoch:P(),absoluteSlot:P(),blockHeight:A(P()),transactionCount:A(P())}),xe=K({slotsPerEpoch:P(),leaderScheduleSlotOffset:P(),warmup:M(),firstNormalEpoch:P(),firstNormalSlot:P()}),Be=T(x(),k(P())),Ke=I(E([K({}),x()])),Ee=K({err:Ke}),Oe=w("receivedSignature");K({"solana-core":x(),"feature-set":A(P())}),ve(K({err:I(E([K({}),x()])),logs:I(k(x())),accounts:A(I(k(I(K({executable:M(),owner:x(),lamports:P(),data:k(x()),rentEpoch:A(P())}))))),unitsConsumed:A(P()),returnData:A(I(K({programId:x(),data:B([x(),w("base64")])})))})),ve(K({byIdentity:T(x(),k(P())),range:K({firstSlot:P(),lastSlot:P()})})),Me(Ie),Me(Ae),Me(Pe),Me(Te),Me(xe),Me(Be),Me(P()),ve(K({total:P(),circulating:P(),nonCirculating:P(),nonCirculatingAccounts:k(he)}));const We=K({amount:x(),uiAmount:I(P()),decimals:P(),uiAmountString:A(x())});ve(k(K({address:he,amount:x(),uiAmount:I(P()),decimals:P(),uiAmountString:A(x())}))),ve(k(K({pubkey:he,account:K({executable:M(),owner:he,lamports:P(),data:be,rentEpoch:P()})})));const ze=K({program:x(),parsed:O(),space:P()});ve(k(K({pubkey:he,account:K({executable:M(),owner:he,lamports:P(),data:ze,rentEpoch:P()})}))),ve(k(K({lamports:P(),address:he})));const Re=K({executable:M(),owner:he,lamports:P(),data:be,rentEpoch:P()});K({pubkey:he,account:Re});const Ce=W(E([v(s.n.Buffer),ze]),E([fe,ze]),(e=>Array.isArray(e)?h(e,be):e)),He=K({executable:M(),owner:he,lamports:P(),data:Ce,rentEpoch:P()});K({pubkey:he,account:He}),K({state:E([w("active"),w("inactive"),w("activating"),w("deactivating")]),active:P(),inactive:P()}),Me(k(K({signature:x(),slot:P(),err:Ke,memo:I(x()),blockTime:A(I(P()))}))),Me(k(K({signature:x(),slot:P(),err:Ke,memo:I(x()),blockTime:A(I(P()))}))),K({subscription:P(),result:we(Re)});const De=K({pubkey:he,account:Re});K({subscription:P(),result:we(De)});const _e=K({parent:P(),slot:P(),root:P()});K({subscription:P(),result:_e});const Ne=E([K({type:E([w("firstShredReceived"),w("completed"),w("optimisticConfirmation"),w("root")]),slot:P(),timestamp:P()}),K({type:w("createdBank"),parent:P(),slot:P(),timestamp:P()}),K({type:w("frozen"),slot:P(),timestamp:P(),stats:K({numTransactionEntries:P(),numSuccessfulTransactions:P(),numFailedTransactions:P(),maxTransactionsPerEntry:P()})}),K({type:w("dead"),slot:P(),timestamp:P(),err:x()})]);K({subscription:P(),result:Ne}),K({subscription:P(),result:we(E([Ee,Oe]))}),K({subscription:P(),result:P()}),K({pubkey:x(),gossip:I(x()),tpu:I(x()),rpc:I(x()),version:I(x())});const Le=K({votePubkey:x(),nodePubkey:x(),activatedStake:P(),epochVoteAccount:M(),epochCredits:k(B([P(),P(),P()])),commission:P(),lastVote:P(),rootSlot:I(P())});Me(K({current:k(Le),delinquent:k(Le)}));const Ge=E([w("processed"),w("confirmed"),w("finalized")]),Ue=K({slot:P(),confirmations:I(P()),err:Ke,confirmationStatus:A(Ge)});ve(k(I(Ue))),Me(P());const Fe=K({accountKey:he,writableIndexes:k(P()),readonlyIndexes:k(P())}),Je=K({signatures:k(x()),message:K({accountKeys:k(x()),header:K({numRequiredSignatures:P(),numReadonlySignedAccounts:P(),numReadonlyUnsignedAccounts:P()}),instructions:k(K({accounts:k(P()),data:x(),programIdIndex:P()})),recentBlockhash:x(),addressTableLookups:A(k(Fe))})}),qe=K({pubkey:he,signer:M(),writable:M(),source:A(E([w("transaction"),w("lookupTable")]))}),Ve=K({accountKeys:k(qe),signatures:k(x())}),je=K({parsed:O(),program:x(),programId:he}),$e=K({accounts:k(he),data:x(),programId:he}),Xe=W(E([$e,je]),E([K({parsed:O(),program:x(),programId:x()}),K({accounts:k(x()),data:x(),programId:x()})]),(e=>h(e,"accounts"in e?$e:je))),Qe=K({signatures:k(x()),message:K({accountKeys:k(qe),instructions:k(Xe),recentBlockhash:x(),addressTableLookups:A(I(k(Fe)))})}),Ze=K({accountIndex:P(),mint:x(),owner:A(x()),uiTokenAmount:We}),Ye=K({writable:k(he),readonly:k(he)}),en=K({err:Ke,fee:P(),innerInstructions:A(I(k(K({index:P(),instructions:k(K({accounts:k(P()),data:x(),programIdIndex:P()}))})))),preBalances:k(P()),postBalances:k(P()),logMessages:A(I(k(x()))),preTokenBalances:A(I(k(Ze))),postTokenBalances:A(I(k(Ze))),loadedAddresses:A(Ye),computeUnitsConsumed:A(P())}),nn=K({err:Ke,fee:P(),innerInstructions:A(I(k(K({index:P(),instructions:k(Xe)})))),preBalances:k(P()),postBalances:k(P()),logMessages:A(I(k(x()))),preTokenBalances:A(I(k(Ze))),postTokenBalances:A(I(k(Ze))),loadedAddresses:A(Ye),computeUnitsConsumed:A(P())}),tn=E([w(0),w("legacy")]),sn=K({pubkey:x(),lamports:P(),postBalance:I(P()),rewardType:I(x()),commission:A(I(P()))});Me(I(K({blockhash:x(),previousBlockhash:x(),parentSlot:P(),transactions:k(K({transaction:Je,meta:I(en),version:A(tn)})),rewards:A(k(sn)),blockTime:I(P()),blockHeight:I(P())}))),Me(I(K({blockhash:x(),previousBlockhash:x(),parentSlot:P(),rewards:A(k(sn)),blockTime:I(P()),blockHeight:I(P())}))),Me(I(K({blockhash:x(),previousBlockhash:x(),parentSlot:P(),transactions:k(K({transaction:Ve,meta:I(en),version:A(tn)})),rewards:A(k(sn)),blockTime:I(P()),blockHeight:I(P())}))),Me(I(K({blockhash:x(),previousBlockhash:x(),parentSlot:P(),transactions:k(K({transaction:Qe,meta:I(nn),version:A(tn)})),rewards:A(k(sn)),blockTime:I(P()),blockHeight:I(P())}))),Me(I(K({blockhash:x(),previousBlockhash:x(),parentSlot:P(),transactions:k(K({transaction:Ve,meta:I(nn),version:A(tn)})),rewards:A(k(sn)),blockTime:I(P()),blockHeight:I(P())}))),Me(I(K({blockhash:x(),previousBlockhash:x(),parentSlot:P(),rewards:A(k(sn)),blockTime:I(P()),blockHeight:I(P())}))),Me(I(K({blockhash:x(),previousBlockhash:x(),parentSlot:P(),transactions:k(K({transaction:Je,meta:I(en)})),rewards:A(k(sn)),blockTime:I(P())}))),Me(I(K({blockhash:x(),previousBlockhash:x(),parentSlot:P(),signatures:k(x()),blockTime:I(P())}))),Me(I(K({slot:P(),meta:I(en),blockTime:A(I(P())),transaction:Je,version:A(tn)}))),Me(I(K({slot:P(),transaction:Qe,meta:I(nn),blockTime:A(I(P())),version:A(tn)}))),ve(K({blockhash:x(),feeCalculator:K({lamportsPerSignature:P()})})),ve(K({blockhash:x(),lastValidBlockHeight:P()})),ve(M());Me(k(K({slot:P(),numTransactions:P(),numSlots:P(),samplePeriodSecs:P()}))),ve(I(K({feeCalculator:K({lamportsPerSignature:P()})}))),Me(x()),Me(x());const an=K({err:Ke,logs:k(x()),signature:x()});K({result:we(an),subscription:P()});class rn{constructor(e){this._keypair=void 0,this._keypair=e??z()}static generate(){return new rn(z())}static fromSecretKey(e,n){if(64!==e.byteLength)throw new Error("bad secret key size");const t=e.slice(32,64);if(!n||!n.skipValidation){const n=e.slice(0,32),s=R(n);for(let e=0;e<32;e++)if(t[e]!==s[e])throw new Error("provided secretKey is invalid")}return new rn({publicKey:t,secretKey:e})}static fromSeed(e){const n=R(e),t=new Uint8Array(64);return t.set(e),t.set(n,32),new rn({publicKey:n,secretKey:t})}get publicKey(){return new F(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}var on;Object.freeze({CreateLookupTable:{index:0,layout:(0,s.aG)([(0,s.aH)("instruction"),le("recentSlot"),(0,s.aJ)("bumpSeed")])},FreezeLookupTable:{index:1,layout:(0,s.aG)([(0,s.aH)("instruction")])},ExtendLookupTable:{index:2,layout:(0,s.aG)([(0,s.aH)("instruction"),le(),(0,s.aK)(V(),(0,s.aL)((0,s.aH)(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:(0,s.aG)([(0,s.aH)("instruction")])},CloseLookupTable:{index:4,layout:(0,s.aG)([(0,s.aH)("instruction")])}}),new F("AddressLookupTab1e1111111111111111111111111"),Object.freeze({RequestUnits:{index:0,layout:(0,s.aG)([(0,s.aJ)("instruction"),(0,s.aH)("units"),(0,s.aH)("additionalFee")])},RequestHeapFrame:{index:1,layout:(0,s.aG)([(0,s.aJ)("instruction"),(0,s.aH)("bytes")])},SetComputeUnitLimit:{index:2,layout:(0,s.aG)([(0,s.aJ)("instruction"),(0,s.aH)("units")])},SetComputeUnitPrice:{index:3,layout:(0,s.aG)([(0,s.aJ)("instruction"),le("microLamports")])}}),new F("ComputeBudget111111111111111111111111111111"),(0,s.aG)([(0,s.aJ)("numSignatures"),(0,s.aJ)("padding"),(0,s.aM)("signatureOffset"),(0,s.aM)("signatureInstructionIndex"),(0,s.aM)("publicKeyOffset"),(0,s.aM)("publicKeyInstructionIndex"),(0,s.aM)("messageDataOffset"),(0,s.aM)("messageDataSize"),(0,s.aM)("messageInstructionIndex")]),new F("Ed25519SigVerify111111111111111111111111111"),s.aN.utils.isValidPrivateKey,s.aN.getPublicKey,(0,s.aG)([(0,s.aJ)("numSignatures"),(0,s.aM)("signatureOffset"),(0,s.aJ)("signatureInstructionIndex"),(0,s.aM)("ethAddressOffset"),(0,s.aJ)("ethAddressInstructionIndex"),(0,s.aM)("messageDataOffset"),(0,s.aM)("messageDataSize"),(0,s.aJ)("messageInstructionIndex"),(0,s.aO)(20,"ethAddress"),(0,s.aO)(64,"signature"),(0,s.aJ)("recoveryId")]),new F("KeccakSecp256k11111111111111111111111111111"),new F("StakeConfig11111111111111111111111111111111");class un{constructor(e,n,t){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=n,this.custodian=t}}on=un,un.default=new on(0,0,F.default),Object.freeze({Initialize:{index:0,layout:(0,s.aG)([(0,s.aH)("instruction"),function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"authorized";return(0,s.aG)([V("staker"),V("withdrawer")],e)}(),function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"lockup";return(0,s.aG)([(0,s.aI)("unixTimestamp"),(0,s.aI)("epoch"),V("custodian")],e)}()])},Authorize:{index:1,layout:(0,s.aG)([(0,s.aH)("instruction"),V("newAuthorized"),(0,s.aH)("stakeAuthorizationType")])},Delegate:{index:2,layout:(0,s.aG)([(0,s.aH)("instruction")])},Split:{index:3,layout:(0,s.aG)([(0,s.aH)("instruction"),(0,s.aI)("lamports")])},Withdraw:{index:4,layout:(0,s.aG)([(0,s.aH)("instruction"),(0,s.aI)("lamports")])},Deactivate:{index:5,layout:(0,s.aG)([(0,s.aH)("instruction")])},Merge:{index:7,layout:(0,s.aG)([(0,s.aH)("instruction")])},AuthorizeWithSeed:{index:8,layout:(0,s.aG)([(0,s.aH)("instruction"),V("newAuthorized"),(0,s.aH)("stakeAuthorizationType"),j("authoritySeed"),V("authorityOwner")])}}),new F("Stake11111111111111111111111111111111111111"),Object.freeze({InitializeAccount:{index:0,layout:(0,s.aG)([(0,s.aH)("instruction"),function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"voteInit";return(0,s.aG)([V("nodePubkey"),V("authorizedVoter"),V("authorizedWithdrawer"),(0,s.aJ)("commission")],e)}()])},Authorize:{index:1,layout:(0,s.aG)([(0,s.aH)("instruction"),V("newAuthorized"),(0,s.aH)("voteAuthorizationType")])},Withdraw:{index:3,layout:(0,s.aG)([(0,s.aH)("instruction"),(0,s.aI)("lamports")])},UpdateValidatorIdentity:{index:4,layout:(0,s.aG)([(0,s.aH)("instruction")])},AuthorizeWithSeed:{index:10,layout:(0,s.aG)([(0,s.aH)("instruction"),function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"voteAuthorizeWithSeedArgs";return(0,s.aG)([(0,s.aH)("voteAuthorizationType"),V("currentAuthorityDerivedKeyOwnerPubkey"),j("currentAuthorityDerivedKeySeed"),V("newAuthorized")],e)}()])}}),new F("Vote111111111111111111111111111111111111111"),new F("Va1idator1nfo111111111111111111111111111111"),K({name:x(),website:A(x()),details:A(x()),keybaseUsername:A(x())}),new F("Vote111111111111111111111111111111111111111"),(0,s.aG)([V("nodePubkey"),V("authorizedWithdrawer"),(0,s.aJ)("commission"),(0,s.aF)(),(0,s.aK)((0,s.aG)([(0,s.aF)("slot"),(0,s.aH)("confirmationCount")]),(0,s.aL)((0,s.aH)(),-8),"votes"),(0,s.aJ)("rootSlotValid"),(0,s.aF)("rootSlot"),(0,s.aF)(),(0,s.aK)((0,s.aG)([(0,s.aF)("epoch"),V("authorizedVoter")]),(0,s.aL)((0,s.aH)(),-8),"authorizedVoters"),(0,s.aG)([(0,s.aK)((0,s.aG)([V("authorizedPubkey"),(0,s.aF)("epochOfLastAuthorizedSwitch"),(0,s.aF)("targetEpoch")]),32,"buf"),(0,s.aF)("idx"),(0,s.aJ)("isEmpty")],"priorVoters"),(0,s.aF)(),(0,s.aK)((0,s.aG)([(0,s.aF)("epoch"),(0,s.aF)("credits"),(0,s.aF)("prevCredits")]),(0,s.aL)((0,s.aH)(),-8),"epochCredits"),(0,s.aG)([(0,s.aF)("slot"),(0,s.aF)("timestamp")],"lastTimestamp")]);const cn=new F("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");new F("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");const mn=new F("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new F("So11111111111111111111111111111111111111112"),new F("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");class dn extends Error{constructor(e){super(e)}}class ln extends dn{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}}function gn(e,n){return new s.cM(kn.TokenMessengerIdl,new F(e),void 0===n?{connection:null}:n)}function pn(e,n){return new s.cM(kn.MessageTransmitterIdl,new F(e),void 0===n?{connection:null}:n)}(0,s.aG)([(0,s.aH)("mintAuthorityOption"),(0,s.cJ)("mintAuthority"),(0,s.cH)("supply"),(0,s.aJ)("decimals"),(0,s.cI)("isInitialized"),(0,s.aH)("freezeAuthorityOption"),(0,s.cJ)("freezeAuthority")]).span;const yn=(e,n,t)=>{const i=[s.d.Buffer.from(s.cR.bytes.utf8.encode(e))];if(t)for(const r of t)"string"==typeof r?i.push(s.d.Buffer.from(s.cR.bytes.utf8.encode(r))):Array.isArray(r)?i.push(s.d.Buffer.from(r)):s.d.Buffer.isBuffer(r)?i.push(r):i.push(r.toBuffer());const a=F.findProgramAddressSync(i,n);return{publicKey:a[0],bump:a[1]}};const hn=6400n;function fn(e){return(e-BigInt(1))/hn*hn+BigInt(1)}function bn(e,n,t){const s=n.toString();return yn("used_nonces",t,[s,fn(e).toString()]).publicKey}class Sn{constructor(e,n,t,s){var i,a;if(u(this,"network"),u(this,"chain"),u(this,"connection"),u(this,"contracts"),u(this,"tokenMessenger"),u(this,"messageTransmitter"),this.network=e,this.chain=n,this.connection=t,this.contracts=s,"Devnet"===e)throw new Error("CircleBridge not supported on Devnet");const o=null==(i=s.cctp)?void 0:i.messageTransmitter;if(!o)throw new Error(`Circle Messenge Transmitter contract for domain ${n} not found`);this.messageTransmitter=function(e,n){return pn(e,(0,r.c)(n))}(new F(o),this.connection);const c=null==(a=s.cctp)?void 0:a.tokenMessenger;if(!c)throw new Error(`Circle Token Messenger contract for domain ${n} not found`);this.tokenMessenger=function(e,n){return gn(e,(0,r.c)(n))}(new F(c),this.connection)}static async fromRpc(e,n){const[t,s]=await a.S.chainFromRpc(e),i=n[s];if(i.network!==t)throw new Error(`Network mismatch: ${i.network} != ${t}`);return new Sn(t,s,e,i.contracts)}async*redeem(e,n,t){const i=new F(s.cA.get(this.network,this.chain)),r=new a.a(e).unwrap(),o=await async function(e,n,t,i,r,o){const u=s.d.Buffer.from(s.cz.serialize(i)),c=s.d.Buffer.from(s.ar.decode(r)),m=new F(t),d=new F(i.payload.burnToken.toUint8Array()),l=new a.a(i.payload.mintRecipient).unwrap(),g=o?new F(o):l,p=i.sourceDomain.toString(),y=yn("message_transmitter",e),h=yn("token_messenger",n),f=yn("token_minter",n),b=yn("local_token",n,[m]),S=yn("remote_token_messenger",n,[p]),k=yn("token_pair",n,[p,d]),M=yn("custody",n,[m]),v=yn("message_transmitter_authority",e,[n]).publicKey,w=bn(i.nonce,i.sourceDomain,e),I=yn("__event_authority",e),P=yn("__event_authority",n),A=[];A.push({isSigner:!1,isWritable:!1,pubkey:h.publicKey}),A.push({isSigner:!1,isWritable:!1,pubkey:S.publicKey}),A.push({isSigner:!1,isWritable:!0,pubkey:f.publicKey}),A.push({isSigner:!1,isWritable:!0,pubkey:b.publicKey}),A.push({isSigner:!1,isWritable:!1,pubkey:k.publicKey}),A.push({isSigner:!1,isWritable:!0,pubkey:l}),A.push({isSigner:!1,isWritable:!0,pubkey:M.publicKey}),A.push({isSigner:!1,isWritable:!1,pubkey:cn}),A.push({isSigner:!1,isWritable:!1,pubkey:P.publicKey}),A.push({isSigner:!1,isWritable:!1,pubkey:n});const T=pn(e);return T.methods.receiveMessage({message:u,attestation:c}).accounts({payer:g,caller:g,authorityPda:v,messageTransmitter:y.publicKey,usedNonces:w,receiver:n,systemProgram:ye.programId,eventAuthority:I.publicKey,program:T.programId}).remainingAccounts(A).transaction()}(this.messageTransmitter.programId,this.tokenMessenger.programId,i,n,t,r),u=new re;u.feePayer=r,u.add(o),yield this.createUnsignedTx({transaction:u},"CircleBridge.Redeem")}async*transfer(e,n,t){const i=new F(s.cA.get(this.network,this.chain)),r=new a.a(e).unwrap(),o=function(e,n){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:cn,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:mn;if(!(arguments.length>2&&void 0!==arguments[2]&&arguments[2])&&!F.isOnCurve(n.toBuffer()))throw new ln;const[i]=F.findProgramAddressSync([n.toBuffer(),t.toBuffer(),e.toBuffer()],s);return i}(i,r),u=s.cy.get(this.network,n.chain),c=n.address.toUniversalAddress(),m=rn.generate(),d=await function(e,n,t,i,a,r,o,u,c){const m=yn("message_transmitter",e),d=yn("token_messenger",n),l=yn("token_minter",n),g=yn("local_token",n,[t]),p=yn("remote_token_messenger",n,[i.toString()]),y=yn("sender_authority",n),h=gn(n),f=yn("__event_authority",n);return h.methods.depositForBurn({amount:new s.aD(u.toString()),destinationDomain:i,mintRecipient:new F(o.toUint8Array())}).accounts({owner:a,senderAuthorityPda:y.publicKey,burnTokenAccount:r,messageTransmitter:m.publicKey,tokenMessenger:d.publicKey,remoteTokenMessenger:p.publicKey,tokenMinter:l.publicKey,localToken:g.publicKey,burnTokenMint:t,messageTransmitterProgram:e,tokenMessengerMinterProgram:n,tokenProgram:cn,eventAuthority:f.publicKey,eventRentPayer:a,messageSentEventData:c}).instruction()}(this.messageTransmitter.programId,this.tokenMessenger.programId,i,u,r,o,c,t,m.publicKey),l=new re;l.feePayer=r,l.add(d),yield this.createUnsignedTx({transaction:l,signers:[m]},"CircleBridge.Transfer")}async isTransferCompleted(e){const n=bn(e.nonce,e.sourceDomain,this.messageTransmitter.programId),t=fn(e.nonce),{usedNonces:i}=await this.messageTransmitter.account.usedNonces.fetch(n),a=Number(e.nonce-t),r=i[Math.floor(a/64)];if(!r)throw new Error("Invalid nonce byte index");const o=a%64,u=new s.aD((BigInt(1)<<BigInt(o)).toString());return!r.and(u).isZero()}async parseTransactionDetails(e){const n=await this.connection.getTransaction(e);if(!n||!n.meta)throw new Error("Transaction not found");const t=n.transaction.message.getAccountKeys();if(t.length<2)throw new Error("No message account found");const i=t.get(1),a=await this.connection.getAccountInfo(i);if(!a)throw new Error("No account data found");const r=new Uint8Array(a.data).slice(44),[o,u]=s.cz.deserialize(r),{payload:c}=o,m=c.messageSender,d=c.mintRecipient,l=(0,s.cB)(this.network,o.sourceDomain);return{from:{chain:l,address:m},to:{chain:(0,s.cB)(this.network,o.destinationDomain),address:d},token:{chain:l,address:c.burnToken},amount:c.amount,message:o,id:{hash:u}}}createUnsignedTx(e,n){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new a.b(e,this.network,this.chain,n,t)}}(0,i.r)(a._,"CircleBridge",Sn);const kn={TokenMessengerIdl:{version:"0.1.0",name:"token_messenger_minter",instructions:[{name:"initialize",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"upgradeAuthority",isMut:!1,isSigner:!0},{name:"authorityPda",isMut:!1,isSigner:!1},{name:"tokenMessenger",isMut:!0,isSigner:!1},{name:"tokenMinter",isMut:!0,isSigner:!1},{name:"tokenMessengerMinterProgramData",isMut:!1,isSigner:!1},{name:"tokenMessengerMinterProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"InitializeParams"}}]},{name:"transferOwnership",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"TransferOwnershipParams"}}]},{name:"acceptOwnership",accounts:[{name:"pendingOwner",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"AcceptOwnershipParams"}}]},{name:"addRemoteTokenMessenger",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"owner",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"remoteTokenMessenger",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"AddRemoteTokenMessengerParams"}}]},{name:"removeRemoteTokenMessenger",accounts:[{name:"payee",isMut:!0,isSigner:!0},{name:"owner",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"remoteTokenMessenger",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"RemoveRemoteTokenMessengerParams"}}]},{name:"depositForBurn",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"eventRentPayer",isMut:!0,isSigner:!0},{name:"senderAuthorityPda",isMut:!1,isSigner:!1},{name:"burnTokenAccount",isMut:!0,isSigner:!1},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"remoteTokenMessenger",isMut:!1,isSigner:!1},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!0,isSigner:!1},{name:"burnTokenMint",isMut:!0,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!0},{name:"messageTransmitterProgram",isMut:!1,isSigner:!1},{name:"tokenMessengerMinterProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"DepositForBurnParams"}}],returns:"u64"},{name:"depositForBurnWithCaller",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"eventRentPayer",isMut:!0,isSigner:!0},{name:"senderAuthorityPda",isMut:!1,isSigner:!1},{name:"burnTokenAccount",isMut:!0,isSigner:!1},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"remoteTokenMessenger",isMut:!1,isSigner:!1},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!0,isSigner:!1},{name:"burnTokenMint",isMut:!0,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!0},{name:"messageTransmitterProgram",isMut:!1,isSigner:!1},{name:"tokenMessengerMinterProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"DepositForBurnWithCallerParams"}}],returns:"u64"},{name:"replaceDepositForBurn",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"eventRentPayer",isMut:!0,isSigner:!0},{name:"senderAuthorityPda",isMut:!1,isSigner:!1},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!0},{name:"messageTransmitterProgram",isMut:!1,isSigner:!1},{name:"tokenMessengerMinterProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"ReplaceDepositForBurnParams"}}],returns:"u64"},{name:"handleReceiveMessage",accounts:[{name:"authorityPda",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"remoteTokenMessenger",isMut:!1,isSigner:!1},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!0,isSigner:!1},{name:"tokenPair",isMut:!1,isSigner:!1},{name:"recipientTokenAccount",isMut:!0,isSigner:!1},{name:"custodyTokenAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"HandleReceiveMessageParams"}}]},{name:"setTokenController",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"tokenMinter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"SetTokenControllerParams"}}]},{name:"pause",accounts:[{name:"pauser",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"PauseParams"}}]},{name:"unpause",accounts:[{name:"pauser",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"UnpauseParams"}}]},{name:"updatePauser",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"tokenMinter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"UpdatePauserParams"}}]},{name:"setMaxBurnAmountPerMessage",accounts:[{name:"tokenController",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"SetMaxBurnAmountPerMessageParams"}}]},{name:"addLocalToken",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"tokenController",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!0,isSigner:!1},{name:"custodyTokenAccount",isMut:!0,isSigner:!1},{name:"localTokenMint",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"AddLocalTokenParams"}}]},{name:"removeLocalToken",accounts:[{name:"payee",isMut:!0,isSigner:!0},{name:"tokenController",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!0,isSigner:!1},{name:"custodyTokenAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"RemoveLocalTokenParams"}}]},{name:"linkTokenPair",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"tokenController",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"tokenPair",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"LinkTokenPairParams"}}]},{name:"unlinkTokenPair",accounts:[{name:"payee",isMut:!0,isSigner:!0},{name:"tokenController",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"tokenPair",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"UninkTokenPairParams"}}]},{name:"burnTokenCustody",accounts:[{name:"payee",isMut:!0,isSigner:!0},{name:"tokenController",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!1,isSigner:!1},{name:"custodyTokenAccount",isMut:!0,isSigner:!1},{name:"custodyTokenMint",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"BurnTokenCustodyParams"}}]}],accounts:[{name:"tokenMessenger",type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"pendingOwner",type:"publicKey"},{name:"localMessageTransmitter",type:"publicKey"},{name:"messageBodyVersion",type:"u32"},{name:"authorityBump",type:"u8"}]}},{name:"remoteTokenMessenger",type:{kind:"struct",fields:[{name:"domain",type:"u32"},{name:"tokenMessenger",type:"publicKey"}]}},{name:"tokenMinter",type:{kind:"struct",fields:[{name:"tokenController",type:"publicKey"},{name:"pauser",type:"publicKey"},{name:"paused",type:"bool"},{name:"bump",type:"u8"}]}},{name:"tokenPair",type:{kind:"struct",fields:[{name:"remoteDomain",type:"u32"},{name:"remoteToken",type:"publicKey"},{name:"localToken",type:"publicKey"},{name:"bump",type:"u8"}]}},{name:"localToken",type:{kind:"struct",fields:[{name:"custody",type:"publicKey"},{name:"mint",type:"publicKey"},{name:"burnLimitPerMessage",type:"u64"},{name:"messagesSent",type:"u64"},{name:"messagesReceived",type:"u64"},{name:"amountSent",type:"u128"},{name:"amountReceived",type:"u128"},{name:"bump",type:"u8"},{name:"custodyBump",type:"u8"}]}}],types:[{name:"AcceptOwnershipParams",type:{kind:"struct",fields:[]}},{name:"AddRemoteTokenMessengerParams",type:{kind:"struct",fields:[{name:"domain",type:"u32"},{name:"tokenMessenger",type:"publicKey"}]}},{name:"DepositForBurnWithCallerParams",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"destinationDomain",type:"u32"},{name:"mintRecipient",type:"publicKey"},{name:"destinationCaller",type:"publicKey"}]}},{name:"DepositForBurnParams",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"destinationDomain",type:"u32"},{name:"mintRecipient",type:"publicKey"}]}},{name:"HandleReceiveMessageParams",type:{kind:"struct",fields:[{name:"remoteDomain",type:"u32"},{name:"sender",type:"publicKey"},{name:"messageBody",type:"bytes"},{name:"authorityBump",type:"u8"}]}},{name:"InitializeParams",type:{kind:"struct",fields:[{name:"tokenController",type:"publicKey"},{name:"localMessageTransmitter",type:"publicKey"},{name:"messageBodyVersion",type:"u32"}]}},{name:"RemoveRemoteTokenMessengerParams",type:{kind:"struct",fields:[]}},{name:"ReplaceDepositForBurnParams",type:{kind:"struct",fields:[{name:"originalMessage",type:"bytes"},{name:"originalAttestation",type:"bytes"},{name:"newDestinationCaller",type:"publicKey"},{name:"newMintRecipient",type:"publicKey"}]}},{name:"TransferOwnershipParams",type:{kind:"struct",fields:[{name:"newOwner",type:"publicKey"}]}},{name:"AddLocalTokenParams",type:{kind:"struct",fields:[]}},{name:"BurnTokenCustodyParams",type:{kind:"struct",fields:[{name:"amount",type:"u64"}]}},{name:"LinkTokenPairParams",type:{kind:"struct",fields:[{name:"localToken",type:"publicKey"},{name:"remoteDomain",type:"u32"},{name:"remoteToken",type:"publicKey"}]}},{name:"PauseParams",type:{kind:"struct",fields:[]}},{name:"RemoveLocalTokenParams",type:{kind:"struct",fields:[]}},{name:"SetMaxBurnAmountPerMessageParams",type:{kind:"struct",fields:[{name:"burnLimitPerMessage",type:"u64"}]}},{name:"SetTokenControllerParams",type:{kind:"struct",fields:[{name:"tokenController",type:"publicKey"}]}},{name:"UninkTokenPairParams",type:{kind:"struct",fields:[]}},{name:"UnpauseParams",type:{kind:"struct",fields:[]}},{name:"UpdatePauserParams",type:{kind:"struct",fields:[{name:"newPauser",type:"publicKey"}]}},{name:"TokenMinterError",type:{kind:"enum",variants:[{name:"InvalidAuthority"},{name:"InvalidTokenMinterState"},{name:"ProgramPaused"},{name:"InvalidTokenPairState"},{name:"InvalidLocalTokenState"},{name:"InvalidPauser"},{name:"InvalidTokenController"},{name:"BurnAmountExceeded"},{name:"InvalidAmount"}]}}],events:[{name:"OwnershipTransferStarted",fields:[{name:"previousOwner",type:"publicKey",index:!1},{name:"newOwner",type:"publicKey",index:!1}]},{name:"OwnershipTransferred",fields:[{name:"previousOwner",type:"publicKey",index:!1},{name:"newOwner",type:"publicKey",index:!1}]},{name:"DepositForBurn",fields:[{name:"nonce",type:"u64",index:!1},{name:"burnToken",type:"publicKey",index:!1},{name:"amount",type:"u64",index:!1},{name:"depositor",type:"publicKey",index:!1},{name:"mintRecipient",type:"publicKey",index:!1},{name:"destinationDomain",type:"u32",index:!1},{name:"destinationTokenMessenger",type:"publicKey",index:!1},{name:"destinationCaller",type:"publicKey",index:!1}]},{name:"MintAndWithdraw",fields:[{name:"mintRecipient",type:"publicKey",index:!1},{name:"amount",type:"u64",index:!1},{name:"mintToken",type:"publicKey",index:!1}]},{name:"RemoteTokenMessengerAdded",fields:[{name:"domain",type:"u32",index:!1},{name:"tokenMessenger",type:"publicKey",index:!1}]},{name:"RemoteTokenMessengerRemoved",fields:[{name:"domain",type:"u32",index:!1},{name:"tokenMessenger",type:"publicKey",index:!1}]},{name:"SetTokenController",fields:[{name:"tokenController",type:"publicKey",index:!1}]},{name:"PauserChanged",fields:[{name:"newAddress",type:"publicKey",index:!1}]},{name:"SetBurnLimitPerMessage",fields:[{name:"token",type:"publicKey",index:!1},{name:"burnLimitPerMessage",type:"u64",index:!1}]},{name:"LocalTokenAdded",fields:[{name:"custody",type:"publicKey",index:!1},{name:"mint",type:"publicKey",index:!1}]},{name:"LocalTokenRemoved",fields:[{name:"custody",type:"publicKey",index:!1},{name:"mint",type:"publicKey",index:!1}]},{name:"TokenPairLinked",fields:[{name:"localToken",type:"publicKey",index:!1},{name:"remoteDomain",type:"u32",index:!1},{name:"remoteToken",type:"publicKey",index:!1}]},{name:"TokenPairUnlinked",fields:[{name:"localToken",type:"publicKey",index:!1},{name:"remoteDomain",type:"u32",index:!1},{name:"remoteToken",type:"publicKey",index:!1}]},{name:"Pause",fields:[]},{name:"Unpause",fields:[]},{name:"TokenCustodyBurned",fields:[{name:"custodyTokenAccount",type:"publicKey",index:!1},{name:"amount",type:"u64",index:!1}]}],errors:[{code:6e3,name:"InvalidAuthority",msg:"Invalid authority"},{code:6001,name:"InvalidTokenMessengerState",msg:"Invalid token messenger state"},{code:6002,name:"InvalidTokenMessenger",msg:"Invalid token messenger"},{code:6003,name:"InvalidOwner",msg:"Invalid owner"},{code:6004,name:"MalformedMessage",msg:"Malformed message"},{code:6005,name:"InvalidMessageBodyVersion",msg:"Invalid message body version"},{code:6006,name:"InvalidAmount",msg:"Invalid amount"},{code:6007,name:"InvalidDestinationDomain",msg:"Invalid destination domain"},{code:6008,name:"InvalidDestinationCaller",msg:"Invalid destination caller"},{code:6009,name:"InvalidMintRecipient",msg:"Invalid mint recipient"},{code:6010,name:"InvalidSender",msg:"Invalid sender"},{code:6011,name:"InvalidTokenPair",msg:"Invalid token pair"},{code:6012,name:"InvalidTokenMint",msg:"Invalid token mint"}]},MessageTransmitterIdl:{version:"0.1.0",name:"message_transmitter",instructions:[{name:"initialize",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"upgradeAuthority",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"messageTransmitterProgramData",isMut:!1,isSigner:!1},{name:"messageTransmitterProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"InitializeParams"}}]},{name:"transferOwnership",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"TransferOwnershipParams"}}]},{name:"acceptOwnership",accounts:[{name:"pendingOwner",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"AcceptOwnershipParams"}}]},{name:"updatePauser",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"UpdatePauserParams"}}]},{name:"updateAttesterManager",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"UpdateAttesterManagerParams"}}]},{name:"pause",accounts:[{name:"pauser",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"PauseParams"}}]},{name:"unpause",accounts:[{name:"pauser",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"UnpauseParams"}}]},{name:"setMaxMessageBodySize",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"SetMaxMessageBodySizeParams"}}]},{name:"enableAttester",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"attesterManager",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"EnableAttesterParams"}}]},{name:"disableAttester",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"attesterManager",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"DisableAttesterParams"}}]},{name:"setSignatureThreshold",accounts:[{name:"attesterManager",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"SetSignatureThresholdParams"}}]},{name:"sendMessage",accounts:[{name:"eventRentPayer",isMut:!0,isSigner:!0},{name:"senderAuthorityPda",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!0},{name:"senderProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"SendMessageParams"}}],returns:"u64"},{name:"sendMessageWithCaller",accounts:[{name:"eventRentPayer",isMut:!0,isSigner:!0},{name:"senderAuthorityPda",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!0},{name:"senderProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"SendMessageWithCallerParams"}}],returns:"u64"},{name:"replaceMessage",accounts:[{name:"eventRentPayer",isMut:!0,isSigner:!0},{name:"senderAuthorityPda",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!0},{name:"senderProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"ReplaceMessageParams"}}],returns:"u64"},{name:"receiveMessage",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"caller",isMut:!1,isSigner:!0},{name:"authorityPda",isMut:!1,isSigner:!1},{name:"messageTransmitter",isMut:!1,isSigner:!1},{name:"usedNonces",isMut:!0,isSigner:!1},{name:"receiver",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"ReceiveMessageParams"}}]},{name:"reclaimEventAccount",accounts:[{name:"payee",isMut:!0,isSigner:!0,docs:["rent SOL receiver, should match original rent payer"]},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!1}],args:[{name:"params",type:{defined:"ReclaimEventAccountParams"}}]},{name:"getNoncePda",accounts:[{name:"messageTransmitter",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"GetNoncePDAParams"}}],returns:"publicKey"},{name:"isNonceUsed",accounts:[{name:"usedNonces",isMut:!1,isSigner:!1,docs:["Account will be explicitly loaded to avoid error when it's not initialized"]}],args:[{name:"params",type:{defined:"IsNonceUsedParams"}}],returns:"bool"}],accounts:[{name:"messageSent",type:{kind:"struct",fields:[{name:"rentPayer",type:"publicKey"},{name:"message",type:"bytes"}]}},{name:"messageTransmitter",docs:["Main state of the MessageTransmitter program"],type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"pendingOwner",type:"publicKey"},{name:"attesterManager",type:"publicKey"},{name:"pauser",type:"publicKey"},{name:"paused",type:"bool"},{name:"localDomain",type:"u32"},{name:"version",type:"u32"},{name:"signatureThreshold",type:"u32"},{name:"enabledAttesters",type:{vec:"publicKey"}},{name:"maxMessageBodySize",type:"u64"},{name:"nextAvailableNonce",type:"u64"}]}},{name:"usedNonces",docs:["UsedNonces account holds an array of bits that indicate which nonces were already used","so they can't be resused to receive new messages. Array starts with the first_nonce and","holds flags for UsedNonces::MAX_NONCES. Nonces are recorded separately for each remote_domain."],type:{kind:"struct",fields:[{name:"remoteDomain",type:"u32"},{name:"firstNonce",type:"u64"},{name:"usedNonces",type:{array:["u64",100]}}]}}],types:[{name:"AcceptOwnershipParams",type:{kind:"struct",fields:[]}},{name:"DisableAttesterParams",type:{kind:"struct",fields:[{name:"attester",type:"publicKey"}]}},{name:"EnableAttesterParams",type:{kind:"struct",fields:[{name:"newAttester",type:"publicKey"}]}},{name:"GetNoncePDAParams",type:{kind:"struct",fields:[{name:"nonce",type:"u64"},{name:"sourceDomain",type:"u32"}]}},{name:"InitializeParams",type:{kind:"struct",fields:[{name:"localDomain",type:"u32"},{name:"attester",type:"publicKey"},{name:"maxMessageBodySize",type:"u64"},{name:"version",type:"u32"}]}},{name:"IsNonceUsedParams",type:{kind:"struct",fields:[{name:"nonce",type:"u64"}]}},{name:"PauseParams",type:{kind:"struct",fields:[]}},{name:"ReceiveMessageParams",type:{kind:"struct",fields:[{name:"message",type:"bytes"},{name:"attestation",type:"bytes"}]}},{name:"HandleReceiveMessageParams",type:{kind:"struct",fields:[{name:"remoteDomain",type:"u32"},{name:"sender",type:"publicKey"},{name:"messageBody",type:"bytes"},{name:"authorityBump",type:"u8"}]}},{name:"ReclaimEventAccountParams",type:{kind:"struct",fields:[{name:"attestation",type:"bytes"}]}},{name:"ReplaceMessageParams",type:{kind:"struct",fields:[{name:"originalMessage",type:"bytes"},{name:"originalAttestation",type:"bytes"},{name:"newMessageBody",type:"bytes"},{name:"newDestinationCaller",type:"publicKey"}]}},{name:"SendMessageWithCallerParams",type:{kind:"struct",fields:[{name:"destinationDomain",type:"u32"},{name:"recipient",type:"publicKey"},{name:"messageBody",type:"bytes"},{name:"destinationCaller",type:"publicKey"}]}},{name:"SendMessageParams",type:{kind:"struct",fields:[{name:"destinationDomain",type:"u32"},{name:"recipient",type:"publicKey"},{name:"messageBody",type:"bytes"}]}},{name:"SetMaxMessageBodySizeParams",type:{kind:"struct",fields:[{name:"newMaxMessageBodySize",type:"u64"}]}},{name:"SetSignatureThresholdParams",type:{kind:"struct",fields:[{name:"newSignatureThreshold",type:"u32"}]}},{name:"TransferOwnershipParams",type:{kind:"struct",fields:[{name:"newOwner",type:"publicKey"}]}},{name:"UnpauseParams",type:{kind:"struct",fields:[]}},{name:"UpdateAttesterManagerParams",type:{kind:"struct",fields:[{name:"newAttesterManager",type:"publicKey"}]}},{name:"UpdatePauserParams",type:{kind:"struct",fields:[{name:"newPauser",type:"publicKey"}]}},{name:"MathError",type:{kind:"enum",variants:[{name:"MathOverflow"},{name:"MathUnderflow"},{name:"ErrorInDivision"}]}}],events:[{name:"OwnershipTransferStarted",fields:[{name:"previousOwner",type:"publicKey",index:!1},{name:"newOwner",type:"publicKey",index:!1}]},{name:"OwnershipTransferred",fields:[{name:"previousOwner",type:"publicKey",index:!1},{name:"newOwner",type:"publicKey",index:!1}]},{name:"PauserChanged",fields:[{name:"newAddress",type:"publicKey",index:!1}]},{name:"AttesterManagerUpdated",fields:[{name:"previousAttesterManager",type:"publicKey",index:!1},{name:"newAttesterManager",type:"publicKey",index:!1}]},{name:"MessageReceived",fields:[{name:"caller",type:"publicKey",index:!1},{name:"sourceDomain",type:"u32",index:!1},{name:"nonce",type:"u64",index:!1},{name:"sender",type:"publicKey",index:!1},{name:"messageBody",type:"bytes",index:!1}]},{name:"SignatureThresholdUpdated",fields:[{name:"oldSignatureThreshold",type:"u32",index:!1},{name:"newSignatureThreshold",type:"u32",index:!1}]},{name:"AttesterEnabled",fields:[{name:"attester",type:"publicKey",index:!1}]},{name:"AttesterDisabled",fields:[{name:"attester",type:"publicKey",index:!1}]},{name:"MaxMessageBodySizeUpdated",fields:[{name:"newMaxMessageBodySize",type:"u64",index:!1}]},{name:"Pause",fields:[]},{name:"Unpause",fields:[]}],errors:[{code:6e3,name:"InvalidAuthority",msg:"Invalid authority"},{code:6001,name:"ProgramPaused",msg:"Instruction is not allowed at this time"},{code:6002,name:"InvalidMessageTransmitterState",msg:"Invalid message transmitter state"},{code:6003,name:"InvalidSignatureThreshold",msg:"Invalid signature threshold"},{code:6004,name:"SignatureThresholdAlreadySet",msg:"Signature threshold already set"},{code:6005,name:"InvalidOwner",msg:"Invalid owner"},{code:6006,name:"InvalidPauser",msg:"Invalid pauser"},{code:6007,name:"InvalidAttesterManager",msg:"Invalid attester manager"},{code:6008,name:"InvalidAttester",msg:"Invalid attester"},{code:6009,name:"AttesterAlreadyEnabled",msg:"Attester already enabled"},{code:6010,name:"TooFewEnabledAttesters",msg:"Too few enabled attesters"},{code:6011,name:"SignatureThresholdTooLow",msg:"Signature threshold is too low"},{code:6012,name:"AttesterAlreadyDisabled",msg:"Attester already disabled"},{code:6013,name:"MessageBodyLimitExceeded",msg:"Message body exceeds max size"},{code:6014,name:"InvalidDestinationCaller",msg:"Invalid destination caller"},{code:6015,name:"InvalidRecipient",msg:"Invalid message recipient"},{code:6016,name:"SenderNotPermitted",msg:"Sender is not permitted"},{code:6017,name:"InvalidSourceDomain",msg:"Invalid source domain"},{code:6018,name:"InvalidDestinationDomain",msg:"Invalid destination domain"},{code:6019,name:"InvalidMessageVersion",msg:"Invalid message version"},{code:6020,name:"InvalidUsedNoncesAccount",msg:"Invalid used nonces account"},{code:6021,name:"InvalidRecipientProgram",msg:"Invalid recipient program"},{code:6022,name:"InvalidNonce",msg:"Invalid nonce"},{code:6023,name:"NonceAlreadyUsed",msg:"Nonce already used"},{code:6024,name:"MessageTooShort",msg:"Message is too short"},{code:6025,name:"MalformedMessage",msg:"Malformed message"},{code:6026,name:"InvalidSignatureOrderOrDupe",msg:"Invalid signature order or dupe"},{code:6027,name:"InvalidAttesterSignature",msg:"Invalid attester signature"},{code:6028,name:"InvalidAttestationLength",msg:"Invalid attestation length"},{code:6029,name:"InvalidSignatureRecoveryId",msg:"Invalid signature recovery ID"},{code:6030,name:"InvalidSignatureSValue",msg:"Invalid signature S value"},{code:6031,name:"InvalidMessageHash",msg:"Invalid message hash"}]}}},9122:(e,n,t)=>{function s(e){if(void 0!==e)return{connection:e}}t.d(n,{c:()=>s})}}]);
//# sourceMappingURL=7026.fbe0f541.chunk.js.map