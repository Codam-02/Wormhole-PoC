"use strict";(self.webpackChunkmultichain_poc=self.webpackChunkmultichain_poc||[]).push([[2763],{2763:(t,o,i)=>{i.r(o),i.d(o,{A:()=>d,_:()=>a,a:()=>u,b:()=>m,s:()=>c});var e=i(7126),s=i(6310),r=Object.defineProperty,n=(t,o,i)=>(((t,o,i)=>{o in t?r(t,o,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[o]=i})(t,"symbol"!=typeof o?o+"":o,i),i);const a="Algorand";function c(t){if(t<BigInt(Number.MIN_SAFE_INTEGER)||t>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("Integer is unsafe");return Number(t)}const h=class t{constructor(o){if(n(this,"type","Native"),n(this,"address"),t.instanceof(o))this.address=o.address;else if(e.as.instanceof(o))this.address=o.toUint8Array();else if(o instanceof Uint8Array&&o.byteLength===t.byteSize)this.address=o;else if("string"==typeof o&&(0,e.ca)(o))this.address=(0,e.cb)(o).publicKey;else if("string"!=typeof o||isNaN(parseInt(o)))if("bigint"==typeof o)this.address=e.b3.zpad(e.aA.toBytes(o,8),t.byteSize);else{if(!(o instanceof Uint8Array&&8===o.byteLength))throw new Error(`Invalid Algorand address or ASA ID: ${o}`);this.address=e.b3.zpad(o,t.byteSize)}else this.address=e.b3.zpad(e.aA.toBytes(BigInt(o),8),t.byteSize)}unwrap(){return this.toString()}toString(){return(0,e.cc)(this.address)}toNative(){return this}toUint8Array(){return this.address}toUniversalAddress(){return new e.as(this.toUint8Array())}toBigInt(){return e.aA.decode(this.toUint8Array().slice(24,32))}toInt(){return c(this.toBigInt())}equals(o){return t.instanceof(o)?o.address===this.address:this.toUniversalAddress().equals(o)}static instanceof(t){return t.constructor.platform===a}};n(h,"byteSize",32),n(h,"platform",a);let d=h;(0,e.at)(a,d);class l extends s.C{}const g=class t extends s.P{constructor(o,i){super(o,i??(0,e.au)(o,t._platform))}getRpc(t){if(t in this.config)return new e.cd.Algodv2("",this.config[t].rpc);throw new Error("No configuration available for chain: "+t)}getChain(t){if(t in this.config)return new l(t,this);throw new Error("No configuration available for chain: "+t)}static nativeTokenId(o,i){if(!t.isSupportedChain(i))throw new Error(`invalid chain for Algorand: ${i}`);return e.av.chainAddress(i,"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ")}static isNativeTokenId(o,i,e){return!(!t.isSupportedChain(i)||e.chain!==i)&&this.nativeTokenId(o,i)==e}static isSupportedChain(o){return(0,e.aw)(o)===t._platform}static async getDecimals(o,i,s){const r=(0,e.ax)(s)?0:new d(s).toInt();if(0===r)return(0,e.ay)(t._platform);const n=await i.getAssetByID(r).do(),a=e.cd.modelsv2.Asset.from_obj_for_encoding(n);if(!a.params||!a.params.decimals)throw new Error("Could not fetch token details");return Number(a.params.decimals)}static async getBalance(t,o,i,s){const r=(0,e.ax)(s)?0:new d(s).toInt();if(0===r){const t=await o.accountInformation(i).do(),s=e.cd.modelsv2.Account.from_obj_for_encoding(t);return BigInt(s.amount)}const n=await o.accountAssetInformation(i,r).do(),a=e.cd.modelsv2.AssetHolding.from_obj_for_encoding(n);return BigInt(a.amount)}static async getBalances(t,o,i,s){let r;if(s.includes("native")){const t=await o.accountInformation(i).do(),s=e.cd.modelsv2.Account.from_obj_for_encoding(t);r=BigInt(s.amount)}return s.map((async t=>{if((0,e.ax)(t))return{native:r};const s=new d(t).toInt(),n=await o.accountAssetInformation(i,s).do(),a=e.cd.modelsv2.AssetHolding.from_obj_for_encoding(n);return BigInt(a.amount)})).reduce(((t,o)=>Object.assign(t,o)),{})}static async sendWait(t,o,i){const s=i.map(((t,o)=>e.cd.decodeSignedTransaction(t))).map(((t,o)=>t.txn.txID())),{txId:r}=await o.sendRawTransaction(i).do();if(!r)throw new Error("Transaction(s) failed to send");const n=await e.cd.waitForConfirmation(o,r,4);if(!e.cd.modelsv2.PendingTransactionResponse.from_obj_for_encoding(n).confirmedRound)throw new Error("Transaction(s) could not be confirmed in 4 rounds");return s}static async getLatestBlock(t){const o=await t.status().do(),i=e.cd.modelsv2.NodeStatusResponse.from_obj_for_encoding(o);if(!i.lastRound)throw new Error("Error getting status from node");return Number(i.lastRound)}static async getLatestFinalizedBlock(t){const o=await t.status().do(),i=e.cd.modelsv2.NodeStatusResponse.from_obj_for_encoding(o);if(!i.lastRound)throw new Error("Error getting status from node");return Number(i.lastRound)}static chainFromChainId(o){const i=(0,e.az)(t._platform,o);if(void 0===i)throw new Error(`Unknown native chain id ${o}`);const[s,r]=i;return[s,r]}static async chainFromRpc(t){const o=await t.versionsCheck().do(),i=e.cd.modelsv2.Version.from_obj_for_encoding(o);return this.chainFromChainId(i.genesisId)}};n(g,"_platform",a);let u=g;class f{constructor(t,o,i){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];n(this,"_chain"),n(this,"_debug"),n(this,"_account"),this._chain=t,this._debug=s,this._account=(0,e.ce)(i)}chain(){return this._chain}address(){return this._account.addr}async sign(t){const o=[],i=t.map(((t,o)=>t.transaction.tx)),s=(0,e.cf)(i),r=t.map(((t,o)=>(t.transaction.tx=s[o],t)));for(const e of r){const{description:t,transaction:i}=e,{tx:s,signer:r}=i;this._debug&&(console.log(s._getDictForDisplay()),console.log(s.txID())),r?(this._debug&&console.log(`Signing: ${t} with signer ${r.address} for address ${this.address()}`),o.push(await r.signTxn(s))):(this._debug&&console.log(`Signing: ${t} without signer for address ${this.address()}`),o.push(s.signTxn(this._account.sk)))}return o}}const p={Address:d,Platform:u,getSigner:async function(t,o){const[i,e]=await u.chainFromRpc(t);return new f(e,t,o)},protocols:{WormholeCore:()=>i.e(196).then(i.bind(i,196)).then((t=>t.i)),TokenBridge:()=>i.e(8971).then(i.bind(i,8971))},getChain:(t,o,i)=>new l(o,new u(t,(0,e.aC)(t,a,{[o]:i})))},m=Object.freeze(Object.defineProperty({__proto__:null,default:p},Symbol.toStringTag,{value:"Module"}))},6310:(t,o,i)=>{i.d(o,{C:()=>d,P:()=>h,r:()=>a});var e=i(7126),s=Object.defineProperty,r=(t,o,i)=>(((t,o,i)=>{o in t?s(t,o,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[o]=i})(t,"symbol"!=typeof o?o+"":o,i),i);const n={};function a(t,o,i){o in n||(n[o]={});if(t in n[o])throw new Error(`Protocol ${t} for protocol ${o} has already registered`);n[o][t]=i}function c(t,o){if(o in n){const i=n[o];if(i&&t in i){const o=i[t];if(o)return o}}throw new Error(`No protocols registered for ${t}:${o}. This may be because the platform specific protocol implementation is not registered (by installing and importing it) or no implementation exists for this platform`)}class h{constructor(t,o){r(this,"network"),r(this,"config"),this.network=t,this.config=o}utils(){return this.constructor}getProtocol(t,o){return((t,o,i,e)=>c(t,o).fromRpc(i,e))(this.utils()._platform,t,o,this.config)}getProtocolInitializer(t){return c(this.utils()._platform,t)}async parseWormholeMessages(t,o,i){return(await this.getProtocol("WormholeCore",o)).parseTransaction(i)}}class d{constructor(t,o,i){r(this,"network"),r(this,"chain"),r(this,"config"),r(this,"platform"),r(this,"rpc"),r(this,"protocols",new Map),r(this,"supportsWormholeCore",(()=>this.supportsProtocol("WormholeCore"))),r(this,"getWormholeCore",(()=>this.getProtocol("WormholeCore"))),r(this,"supportsTokenBridge",(()=>this.supportsProtocol("TokenBridge"))),r(this,"getTokenBridge",(()=>this.getProtocol("TokenBridge"))),r(this,"supportsAutomaticTokenBridge",(()=>this.supportsProtocol("AutomaticTokenBridge"))),r(this,"getAutomaticTokenBridge",(()=>this.getProtocol("AutomaticTokenBridge"))),r(this,"supportsCircleBridge",(()=>this.supportsProtocol("CircleBridge"))),r(this,"getCircleBridge",(()=>this.getProtocol("CircleBridge"))),r(this,"supportsAutomaticCircleBridge",(()=>this.supportsProtocol("AutomaticCircleBridge"))),r(this,"getAutomaticCircleBridge",(()=>this.getProtocol("AutomaticCircleBridge"))),r(this,"supportsIbcBridge",(()=>this.supportsProtocol("IbcBridge"))),r(this,"getIbcBridge",(()=>this.getProtocol("IbcBridge"))),r(this,"supportsPorticoBridge",(()=>this.supportsProtocol("PorticoBridge"))),r(this,"getPorticoBridge",(()=>this.getProtocol("PorticoBridge"))),this.config=o.config[t],this.platform=o,this.chain=this.config.key,this.network=this.config.network,this.rpc=i}getRpc(){return this.rpc=this.rpc?this.rpc:this.platform.getRpc(this.chain),this.rpc}async getDecimals(t){if((0,e.ax)(t))return this.config.nativeTokenDecimals;if(this.config.tokenMap){const o=(0,e.ch)({chain:this.chain,address:t}),i=(0,e.ci)(this.network,this.chain,o);if(i)return i.decimals}return this.platform.utils().getDecimals(this.chain,await this.getRpc(),t)}async getBalance(t,o){return this.platform.utils().getBalance(this.chain,await this.getRpc(),t,o)}async getLatestBlock(){return this.platform.utils().getLatestBlock(await this.getRpc())}async getLatestFinalizedBlock(){return this.platform.utils().getLatestFinalizedBlock(await this.getRpc())}async parseTransaction(t){return this.platform.parseWormholeMessages(this.chain,await this.getRpc(),t)}async sendWait(t){return this.platform.utils().sendWait(this.chain,await this.getRpc(),t)}getToken(t){if(this.config.tokenMap&&t in this.config.tokenMap)return this.config.tokenMap[t]}async getNativeWrappedTokenId(){if(this.config.wrappedNative){const{address:t}=this.config.wrappedNative;return{chain:this.chain,address:(0,e.cj)(this.chain,t)}}const t=await this.getTokenBridge();return{chain:this.chain,address:await t.getWrappedNative()}}async getTokenAccount(t,o){return{chain:this.chain,address:t}}supportsProtocol(t){return function(t,o){const i=(0,e.cg)(t)?e.aw.get(t):t;return o in n&&i in n[o]}(this.chain,t)}async getProtocol(t,o,i){if(!o&&this.protocols.has(t))return this.protocols.get(t);const e=o?{...this.config.contracts,...o}:this.config.contracts,s=i??await this.getRpc(),r=this.platform.getProtocolInitializer(t);let n;if(i){if(o)throw new Error("Custom contracts are currently not supported with custom rpc connection. Add the contracts to the base config.");n=await this.platform.getProtocol(t,s)}else if("getVersion"in r){const t=await r.getVersion(s,e);n=new r(this.network,this.chain,s,e,t)}else n=new r(this.network,this.chain,s,e);return o||this.protocols.set(t,n),n}}}}]);
//# sourceMappingURL=2763.f14a77bb.chunk.js.map