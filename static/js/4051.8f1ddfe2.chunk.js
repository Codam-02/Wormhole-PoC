/*! For license information please see 4051.8f1ddfe2.chunk.js.LICENSE.txt */
"use strict";(self.webpackChunkmultichain_poc=self.webpackChunkmultichain_poc||[]).push([[4051],{6310:(e,t,r)=>{r.d(t,{C:()=>l,P:()=>u,r:()=>o});var n=r(7126),i=Object.defineProperty,s=(e,t,r)=>(((e,t,r)=>{t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r})(e,"symbol"!=typeof t?t+"":t,r),r);const a={};function o(e,t,r){t in a||(a[t]={});if(e in a[t])throw new Error(`Protocol ${e} for protocol ${t} has already registered`);a[t][e]=r}function c(e,t){if(t in a){const r=a[t];if(r&&e in r){const t=r[e];if(t)return t}}throw new Error(`No protocols registered for ${e}:${t}. This may be because the platform specific protocol implementation is not registered (by installing and importing it) or no implementation exists for this platform`)}class u{constructor(e,t){s(this,"network"),s(this,"config"),this.network=e,this.config=t}utils(){return this.constructor}getProtocol(e,t){return((e,t,r,n)=>c(e,t).fromRpc(r,n))(this.utils()._platform,e,t,this.config)}getProtocolInitializer(e){return c(this.utils()._platform,e)}async parseWormholeMessages(e,t,r){return(await this.getProtocol("WormholeCore",t)).parseTransaction(r)}}class l{constructor(e,t,r){s(this,"network"),s(this,"chain"),s(this,"config"),s(this,"platform"),s(this,"rpc"),s(this,"protocols",new Map),s(this,"supportsWormholeCore",(()=>this.supportsProtocol("WormholeCore"))),s(this,"getWormholeCore",(()=>this.getProtocol("WormholeCore"))),s(this,"supportsTokenBridge",(()=>this.supportsProtocol("TokenBridge"))),s(this,"getTokenBridge",(()=>this.getProtocol("TokenBridge"))),s(this,"supportsAutomaticTokenBridge",(()=>this.supportsProtocol("AutomaticTokenBridge"))),s(this,"getAutomaticTokenBridge",(()=>this.getProtocol("AutomaticTokenBridge"))),s(this,"supportsCircleBridge",(()=>this.supportsProtocol("CircleBridge"))),s(this,"getCircleBridge",(()=>this.getProtocol("CircleBridge"))),s(this,"supportsAutomaticCircleBridge",(()=>this.supportsProtocol("AutomaticCircleBridge"))),s(this,"getAutomaticCircleBridge",(()=>this.getProtocol("AutomaticCircleBridge"))),s(this,"supportsIbcBridge",(()=>this.supportsProtocol("IbcBridge"))),s(this,"getIbcBridge",(()=>this.getProtocol("IbcBridge"))),s(this,"supportsPorticoBridge",(()=>this.supportsProtocol("PorticoBridge"))),s(this,"getPorticoBridge",(()=>this.getProtocol("PorticoBridge"))),this.config=t.config[e],this.platform=t,this.chain=this.config.key,this.network=this.config.network,this.rpc=r}getRpc(){return this.rpc=this.rpc?this.rpc:this.platform.getRpc(this.chain),this.rpc}async getDecimals(e){if((0,n.ax)(e))return this.config.nativeTokenDecimals;if(this.config.tokenMap){const t=(0,n.ch)({chain:this.chain,address:e}),r=(0,n.ci)(this.network,this.chain,t);if(r)return r.decimals}return this.platform.utils().getDecimals(this.chain,await this.getRpc(),e)}async getBalance(e,t){return this.platform.utils().getBalance(this.chain,await this.getRpc(),e,t)}async getLatestBlock(){return this.platform.utils().getLatestBlock(await this.getRpc())}async getLatestFinalizedBlock(){return this.platform.utils().getLatestFinalizedBlock(await this.getRpc())}async parseTransaction(e){return this.platform.parseWormholeMessages(this.chain,await this.getRpc(),e)}async sendWait(e){return this.platform.utils().sendWait(this.chain,await this.getRpc(),e)}getToken(e){if(this.config.tokenMap&&e in this.config.tokenMap)return this.config.tokenMap[e]}async getNativeWrappedTokenId(){if(this.config.wrappedNative){const{address:e}=this.config.wrappedNative;return{chain:this.chain,address:(0,n.cj)(this.chain,e)}}const e=await this.getTokenBridge();return{chain:this.chain,address:await e.getWrappedNative()}}async getTokenAccount(e,t){return{chain:this.chain,address:e}}supportsProtocol(e){return function(e,t){const r=(0,n.cg)(e)?n.aw.get(e):e;return t in a&&r in a[t]}(this.chain,e)}async getProtocol(e,t,r){if(!t&&this.protocols.has(e))return this.protocols.get(e);const n=t?{...this.config.contracts,...t}:this.config.contracts,i=r??await this.getRpc(),s=this.platform.getProtocolInitializer(e);let a;if(r){if(t)throw new Error("Custom contracts are currently not supported with custom rpc connection. Add the contracts to the base config.");a=await this.platform.getProtocol(e,i)}else if("getVersion"in s){const e=await s.getVersion(i,n);a=new s(this.network,this.chain,i,n,e)}else a=new s(this.network,this.chain,i,n);return t||this.protocols.set(e,a),a}}},4051:(e,t,r)=>{r.r(t),r.d(t,{S:()=>Gn,_:()=>Mn,a:()=>Yn,b:()=>ei,c:()=>$n,d:()=>Rn,e:()=>Nn,f:()=>_n,g:()=>qn,h:()=>zn,i:()=>Jn,j:()=>Qn,k:()=>Un,l:()=>Kn,m:()=>Wn,n:()=>Dn,o:()=>ri,p:()=>Ln,s:()=>Ai,t:()=>Zn,u:()=>Vn});var n=r(7126),i=r(6310),s=Object.defineProperty,a=(e,t,r)=>(((e,t,r)=>{t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r})(e,"symbol"!=typeof t?t+"":t,r),r);function o(e){if("string"!=typeof e)throw new TypeError("Invalid mnemonic type: "+typeof e);return e.normalize("NFKD")}const c=e=>o(`mnemonic${e}`);function u(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return(0,n.a$)(n.b0,function(e){const t=o(e),r=t.split(" ");if(![12,15,18,21,24].includes(r.length))throw new Error("Invalid mnemonic");return{nfkd:t,words:r}}(e).nfkd,c(t),{c:2048,dkLen:64})}var l=function(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<e.length;n++){var i=e.charAt(n),s=i.charCodeAt(0);if(255!==t[s])throw new TypeError(i+" is ambiguous");t[s]=n}var a=e.length,o=e.charAt(0),c=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function l(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;for(var r=0,n=0,i=0;e[r]===o;)n++,r++;for(var s=(e.length-r)*c+1>>>0,u=new Uint8Array(s);e[r];){var l=t[e.charCodeAt(r)];if(255===l)return;for(var d=0,h=s-1;(0!==l||d<i)&&-1!==h;h--,d++)l+=a*u[h]>>>0,u[h]=l%256>>>0,l=l/256>>>0;if(0!==l)throw new Error("Non-zero carry");i=d,r++}for(var p=s-i;p!==s&&0===u[p];)p++;for(var f=new Uint8Array(n+(s-p)),g=n;p!==s;)f[g++]=u[p++];return f}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,i=0,s=t.length;i!==s&&0===t[i];)i++,r++;for(var c=(s-i)*u+1>>>0,l=new Uint8Array(c);i!==s;){for(var d=t[i],h=0,p=c-1;(0!==d||h<n)&&-1!==p;p--,h++)d+=256*l[p]>>>0,l[p]=d%a>>>0,d=d/a>>>0;if(0!==d)throw new Error("Non-zero carry");n=h,i++}for(var f=c-n;f!==c&&0===l[f];)f++;for(var g=o.repeat(r);f<c;++f)g+=e.charAt(l[f]);return g},decodeUnsafe:l,decode:function(e){var t=l(e);if(t)return t;throw new Error("Non-base"+a+" character")}}};var d=l("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");const h=(0,n.g)(d),p=e=>h.encode(e),f=e=>h.decode(e);function g(e){return Uint8Array.from(atob(e),(e=>e.charCodeAt(0)))}const m=8192;function y(e){if(e.length<m)return btoa(String.fromCharCode(...e));let t="";for(var r=0;r<e.length;r+=m){const n=e.slice(r,r+m);t+=String.fromCharCode(...n)}return btoa(t)}function w(e){var t;const r=e.startsWith("0x")?e.slice(2):e,n=(null==(t=(r.length%2===0?r:`0${r}}`).match(/.{2}/g))?void 0:t.map((e=>parseInt(e,16))))??[];return Uint8Array.from(n)}function b(e){return e.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),"")}function v(e){let t=[],r=0;if(0===e)return[0];for(;e>0;)t[r]=127&e,(e>>=7)&&(t[r]|=128),r+=1;return t}class S{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer)}shift(e){return this.bytePosition+=e,this}read8(){let e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){let e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){let e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){let e=this.read32(),t=this.read32().toString(16)+e.toString(16).padStart(8,"0");return BigInt("0x"+t).toString(10)}read128(){let e=BigInt(this.read64()),t=BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0");return BigInt("0x"+t).toString(10)}read256(){let e=BigInt(this.read128()),t=BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0");return BigInt("0x"+t).toString(10)}readBytes(e){let t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t,e);return this.shift(e),r}readULEB(){let e=this.bytePosition+this.dataView.byteOffset,t=new Uint8Array(this.dataView.buffer,e),{value:r,length:n}=function(e){let t=0,r=0,n=0;for(;;){let i=e[n];if(n+=1,t|=(127&i)<<r,!(128&i))break;r+=7}return{value:t,length:n}}(t);return this.shift(n),r}readVec(e){let t=this.readULEB(),r=[];for(let n=0;n<t;n++)r.push(e(this,n,t));return r}}function k(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:["<",">"];const[r,n]=t,i=[];let s="",a=0;for(let o=0;o<e.length;o++){const t=e[o];(t===r&&a++,t===n&&a--,0!==a||","!==t)?s+=t:(i.push(s.trim()),s="")}return i.push(s.trim()),i}class T{constructor(){let{size:e=1024,maxSize:t,allocateSize:r=1024}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.bytePosition=0,this.size=e,this.maxSize=t||e,this.allocateSize=r,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){const t=this.bytePosition+e;if(t>this.size){const e=Math.min(this.maxSize,this.size+this.allocateSize);if(t>e)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`);this.size=e;const r=new ArrayBuffer(this.size);new Uint8Array(r).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(r)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return E(BigInt(e),8).forEach((e=>this.write8(e))),this}write128(e){return E(BigInt(e),16).forEach((e=>this.write8(e))),this}write256(e){return E(BigInt(e),32).forEach((e=>this.write8(e))),this}writeULEB(e){return v(e).forEach((e=>this.write8(e))),this}writeVec(e,t){return this.writeULEB(e.length),Array.from(e).forEach(((r,n)=>t(this,r,n,e.length))),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return function(e,t){switch(t){case"base58":return p(e);case"base64":return y(e);case"hex":return b(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}(this.toBytes(),e)}}function E(e,t){let r=new Uint8Array(t),n=0;for(;e>0;)r[n]=Number(e%BigInt(256)),e/=BigInt(256),n+=1;return r}var x,j,I,B,A=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},O=(e,t,r)=>(A(e,t,"read from private field"),r?r.call(e):t.get(e)),C=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},P=(e,t,r,n)=>(A(e,t,"write to private field"),t.set(e,r),r);const M=class{constructor(e){C(this,x,void 0),C(this,j,void 0),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),P(this,x,e.write),P(this,j,e.serialize??((e,t)=>{const r=new T({size:this.serializedSize(e)??void 0,...t});return O(this,x).call(this,e,r),r.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),O(this,x).call(this,e,t)}serialize(e,t){return this.validate(e),new _(this,O(this,j).call(this,e,t))}parse(e){const t=new S(e);return this.read(t)}transform(e){let{name:t,input:r,output:n}=e;return new M({name:t??this.name,read:e=>n(this.read(e)),write:(e,t)=>O(this,x).call(this,r(e),t),serializedSize:e=>this.serializedSize(r(e)),serialize:(e,t)=>O(this,j).call(this,r(e),t),validate:e=>this.validate(r(e))})}};let $=M;x=new WeakMap,j=new WeakMap;const U=Symbol.for("@mysten/serialized-bcs");function z(e){return!!e&&"object"==typeof e&&!0===e[U]}class _{constructor(e,t){C(this,I,void 0),C(this,B,void 0),P(this,I,e),P(this,B,t)}get[U](){return!0}toBytes(){return O(this,B)}toHex(){return b(O(this,B))}toBase64(){return y(O(this,B))}toBase58(){return p(O(this,B))}parse(){return O(this,I).parse(O(this,B))}}function N(e){let{size:t,...r}=e;return new $({...r,serializedSize:()=>t})}function R(e){let{readMethod:t,writeMethod:r,...n}=e;return N({...n,read:e=>e[t](),write:(e,t)=>t[r](e),validate:e=>{var t;if(e<0||e>n.maxValue)throw new TypeError(`Invalid ${n.name} value: ${e}. Expected value in range 0-${n.maxValue}`);null==(t=n.validate)||t.call(n,e)}})}function V(e){let{readMethod:t,writeMethod:r,...n}=e;return N({...n,read:e=>e[t](),write:(e,t)=>t[r](BigInt(e)),validate:e=>{var t;const r=BigInt(e);if(r<0||r>n.maxValue)throw new TypeError(`Invalid ${n.name} value: ${r}. Expected value in range 0-${n.maxValue}`);null==(t=n.validate)||t.call(n,r)}})}I=new WeakMap,B=new WeakMap;const D={u8:e=>R({name:"u8",readMethod:"read8",writeMethod:"write8",size:1,maxValue:255,...e}),u16:e=>R({name:"u16",readMethod:"read16",writeMethod:"write16",size:2,maxValue:65535,...e}),u32:e=>R({name:"u32",readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...e}),u64:e=>V({name:"u64",readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...e}),u128:e=>V({name:"u128",readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...e}),u256:e=>V({name:"u256",readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...e}),bool:e=>N({name:"bool",size:1,read:e=>1===e.read8(),write:(e,t)=>t.write8(e?1:0),...e,validate:t=>{var r;if(null==(r=null==e?void 0:e.validate)||r.call(e,t),"boolean"!=typeof t)throw new TypeError("Expected boolean, found "+typeof t)}}),uleb128:e=>function(e){let{serialize:t,...r}=e;const n=new $({...r,serialize:t,write:(e,t)=>{for(const r of n.serialize(e).toBytes())t.write8(r)}});return n}({name:"uleb128",read:e=>e.readULEB(),serialize:e=>Uint8Array.from(v(e)),...e}),bytes:(e,t)=>N({name:`bytes[${e}]`,size:e,read:t=>t.readBytes(e),write:(t,r)=>{for(let n=0;n<e;n++)r.write8(t[n]??0)},...t,validate:r=>{var n;if(null==(n=null==t?void 0:t.validate)||n.call(t,r),!("length"in r))throw new TypeError("Expected array, found "+typeof r);if(r.length!==e)throw new TypeError(`Expected array of length ${e}, found ${r.length}`)}}),string:e=>function(e){let{toBytes:t,fromBytes:r,...n}=e;return new $({...n,read:e=>{const t=e.readULEB(),n=e.readBytes(t);return r(n)},write:(e,r)=>{const n=t(e);r.writeULEB(n.length);for(let t=0;t<n.length;t++)r.write8(n[t])},serialize:e=>{const r=t(e),n=v(r.length),i=new Uint8Array(n.length+r.length);return i.set(n,0),i.set(r,n.length),i},validate:e=>{var t;if("string"!=typeof e)throw new TypeError(`Invalid ${n.name} value: ${e}. Expected string`);null==(t=n.validate)||t.call(n,e)}})}({name:"string",toBytes:e=>(new TextEncoder).encode(e),fromBytes:e=>(new TextDecoder).decode(e),...e}),fixedArray:(e,t,r)=>new $({name:`${t.name}[${e}]`,read:r=>{const n=new Array(e);for(let i=0;i<e;i++)n[i]=t.read(r);return n},write:(e,r)=>{for(const n of e)t.write(n,r)},...r,validate:t=>{var n;if(null==(n=null==r?void 0:r.validate)||n.call(r,t),!("length"in t))throw new TypeError("Expected array, found "+typeof t);if(t.length!==e)throw new TypeError(`Expected array of length ${e}, found ${t.length}`)}}),option:e=>D.enum(`Option<${e.name}>`,{None:null,Some:e}).transform({input:e=>null==e?{None:!0}:{Some:e},output:e=>"Some"in e?e.Some:null}),vector:(e,t)=>new $({name:`vector<${e.name}>`,read:t=>{const r=t.readULEB(),n=new Array(r);for(let i=0;i<r;i++)n[i]=e.read(t);return n},write:(t,r)=>{r.writeULEB(t.length);for(const n of t)e.write(n,r)},...t,validate:e=>{var r;if(null==(r=null==t?void 0:t.validate)||r.call(t,e),!("length"in e))throw new TypeError("Expected array, found "+typeof e)}}),tuple:(e,t)=>new $({name:`(${e.map((e=>e.name)).join(", ")})`,serializedSize:t=>{let r=0;for(let n=0;n<e.length;n++){const i=e[n].serializedSize(t[n]);if(null==i)return null;r+=i}return r},read:t=>{const r=[];for(const n of e)r.push(n.read(t));return r},write:(t,r)=>{for(let n=0;n<e.length;n++)e[n].write(t[n],r)},...t,validate:r=>{var n;if(null==(n=null==t?void 0:t.validate)||n.call(t,r),!Array.isArray(r))throw new TypeError("Expected array, found "+typeof r);if(r.length!==e.length)throw new TypeError(`Expected array of length ${e.length}, found ${r.length}`)}}),struct(e,t,r){const n=Object.entries(t);return new $({name:e,serializedSize:e=>{let t=0;for(const[r,i]of n){const n=i.serializedSize(e[r]);if(null==n)return null;t+=n}return t},read:e=>{const t={};for(const[r,i]of n)t[r]=i.read(e);return t},write:(e,t)=>{for(const[r,i]of n)i.write(e[r],t)},...r,validate:e=>{var t;if(null==(t=null==r?void 0:r.validate)||t.call(r,e),"object"!=typeof e||null==e)throw new TypeError("Expected object, found "+typeof e)}})},enum(e,t,r){const n=Object.entries(t);return new $({name:e,read:e=>{const t=e.readULEB(),[r,i]=n[t];return{[r]:(null==i?void 0:i.read(e))??!0}},write:(e,t)=>{const[r,i]=Object.entries(e)[0];for(let s=0;s<n.length;s++){const[e,a]=n[s];if(e===r)return t.writeULEB(s),void(null==a||a.write(i,t))}},...r,validate:e=>{var n;if(null==(n=null==r?void 0:r.validate)||n.call(r,e),"object"!=typeof e||null==e)throw new TypeError("Expected object, found "+typeof e);const i=Object.keys(e);if(1!==i.length)throw new TypeError(`Expected object with one key, found ${i.length}`);const[s]=i;if(!Object.hasOwn(t,s))throw new TypeError(`Invalid enum variant ${s}`)}})},map:(e,t)=>D.vector(D.tuple([e,t])).transform({name:`Map<${e.name}, ${t.name}>`,input:e=>[...e.entries()],output:e=>{const t=new Map;for(const[r,n]of e)t.set(r,n);return t}}),generic:(e,t)=>function(){for(var e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];return t(...r).transform({name:`${t.name}<${r.map((e=>e.name)).join(", ")}>`,input:e=>e,output:e=>e})},lazy:e=>function(e){let t=null;function r(){return t||(t=e()),t}return new $({name:"lazy",read:e=>r().read(e),serializedSize:e=>r().serializedSize(e),write:(e,t)=>r().write(e,t),serialize:(e,t)=>r().serialize(e,t).toBytes()})}(e)},q=class{constructor(e){if(this.types=new Map,this.counter=0,e instanceof q)return this.schema=e.schema,void(this.types=new Map(e.types));if(this.schema=e,this.registerAddressType(q.ADDRESS,e.addressLength,e.addressEncoding),this.registerVectorType(e.vectorType),e.types&&e.types.structs)for(let t of Object.keys(e.types.structs))this.registerStructType(t,e.types.structs[t]);if(e.types&&e.types.enums)for(let t of Object.keys(e.types.enums))this.registerEnumType(t,e.types.enums[t]);if(e.types&&e.types.aliases)for(let t of Object.keys(e.types.aliases))this.registerAlias(t,e.types.aliases[t]);!1!==e.withPrimitives&&function(e){e.registerType(W.U8,(function(e,t){return e.write8(t)}),(function(e){return e.read8()}),(e=>e<256)),e.registerType(W.U16,(function(e,t){return e.write16(t)}),(function(e){return e.read16()}),(e=>e<65536)),e.registerType(W.U32,(function(e,t){return e.write32(t)}),(function(e){return e.read32()}),(e=>e<=4294967296n)),e.registerType(W.U64,(function(e,t){return e.write64(t)}),(function(e){return e.read64()})),e.registerType(W.U128,(function(e,t){return e.write128(t)}),(function(e){return e.read128()})),e.registerType(W.U256,(function(e,t){return e.write256(t)}),(function(e){return e.read256()})),e.registerType(W.BOOL,(function(e,t){return e.write8(t)}),(function(e){return"1"===e.read8().toString(10)})),e.registerType(W.STRING,(function(e,t){return e.writeVec(Array.from(t),((e,t)=>e.write8(t.charCodeAt(0))))}),(function(e){return e.readVec((e=>e.read8())).map((e=>String.fromCharCode(Number(e)))).join("")}),(e=>!0)),e.registerType(W.HEX,(function(e,t){return e.writeVec(Array.from(w(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return b(new Uint8Array(t))})),e.registerType(W.BASE58,(function(e,t){return e.writeVec(Array.from(f(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return p(new Uint8Array(t))})),e.registerType(W.BASE64,(function(e,t){return e.writeVec(Array.from(g(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return y(new Uint8Array(t))}))}(this)}tempKey(){return"bcs-struct-"+ ++this.counter}ser(e,t,r){if("string"==typeof e||Array.isArray(e)){const{name:n,params:i}=this.parseTypeName(e);return this.getTypeInterface(n).encode(this,t,r,i)}if("object"==typeof e){const n=this.tempKey();return new q(this).registerStructType(n,e).ser(n,t,r)}throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(e)}`)}de(e,t,r){if("string"==typeof t){if(!r)throw new Error("To pass a string to `bcs.de`, specify encoding");t=function(e,t){switch(t){case"base58":return f(e);case"base64":return g(e);case"hex":return w(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}(t,r)}if("string"==typeof e||Array.isArray(e)){const{name:r,params:n}=this.parseTypeName(e);return this.getTypeInterface(r).decode(this,t,n)}if("object"==typeof e){const n=new q(this),i=this.tempKey();return n.registerStructType(i,e).de(i,t,r)}throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(e)}`)}hasType(e){return this.types.has(e)}registerAlias(e,t){return this.types.set(e,t),this}registerType(e,t,r){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:()=>!0;const{name:i,params:s}=this.parseTypeName(e);return this.types.set(i,{encode(e,t,r,n){const i=s.reduce(((e,t,r)=>Object.assign(e,{[t]:n[r]})),{});return this._encodeRaw.call(e,new T(r),t,n,i)},decode(e,t,r){const n=s.reduce(((e,t,n)=>Object.assign(e,{[t]:r[n]})),{});return this._decodeRaw.call(e,new S(t),r,n)},_encodeRaw(e,r,s,a){if(n(r))return t.call(this,e,r,s,a);throw new Error(`Validation failed for type ${i}, data: ${r}`)},_decodeRaw(e,t,n){return r.call(this,e,t,n)}}),this}registerBcsType(e,t){return this.registerType(e,((e,r,n)=>{const i=n.map((e=>new $({name:String(e),write:(t,r)=>{const{name:i,params:s}=this.parseTypeName(e),a=this.getTypeInterface(i),o=s.reduce(((e,t,r)=>Object.assign(e,{[t]:n[r]})),{});return a._encodeRaw.call(this,r,t,s,o)},read:()=>{throw new Error("Not implemented")}})));return t(...i).write(r,e),e}),((e,r)=>{const n=r.map((e=>new $({name:String(e),write:(e,t)=>{throw new Error("Not implemented")},read:t=>{const{name:n,params:i}=this.parseTypeName(e),s=this.getTypeInterface(n),a=i.reduce(((e,t,n)=>Object.assign(e,{[t]:r[n]})),{});return s._decodeRaw.call(this,t,i,a)}})));return t(...n).read(e)})),this}registerAddressType(e,t){switch(arguments.length>2&&void 0!==arguments[2]?arguments[2]:"hex"){case"base64":return this.registerType(e,(function(e,t){return g(t).reduce(((e,t)=>e.write8(t)),e)}),(function(e){return y(e.readBytes(t))}));case"hex":return this.registerType(e,(function(e,t){return w(t).reduce(((e,t)=>e.write8(t)),e)}),(function(e){return b(e.readBytes(t))}));default:throw new Error("Unsupported encoding! Use either hex or base64")}}registerVectorType(e){let{name:t,params:r}=this.parseTypeName(e);if(r.length>1)throw new Error("Vector can have only one type parameter; got "+t);return this.registerType(e,(function(t,r,n,i){return t.writeVec(r,((t,r)=>{let s=n[0];if(!s)throw new Error(`Incorrect number of type parameters passed a to vector '${e}'`);let{name:a,params:o}=this.parseTypeName(s);if(this.hasType(a))return this.getTypeInterface(a)._encodeRaw.call(this,t,r,o,i);if(!(a in i))throw new Error(`Unable to find a matching type definition for ${a} in vector; make sure you passed a generic`);let{name:c,params:u}=this.parseTypeName(i[a]);return this.getTypeInterface(c)._encodeRaw.call(this,t,r,u,i)}))}),(function(t,r,n){return t.readVec((t=>{let i=r[0];if(!i)throw new Error(`Incorrect number of type parameters passed to a vector '${e}'`);let{name:s,params:a}=this.parseTypeName(i);if(this.hasType(s))return this.getTypeInterface(s)._decodeRaw.call(this,t,a,n);if(!(s in n))throw new Error(`Unable to find a matching type definition for ${s} in vector; make sure you passed a generic`);let{name:o,params:c}=this.parseTypeName(n[s]);return this.getTypeInterface(o)._decodeRaw.call(this,t,c,n)}))}))}registerStructType(e,t){for(let a in t){let e=this.tempKey(),r=t[a];!Array.isArray(r)&&"string"!=typeof r&&(t[a]=e,this.registerStructType(e,r))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,a,o){if(!t||t.constructor!==Object)throw new Error(`Expected ${i} to be an Object, got: ${t}`);if(a.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${a.length}`);for(let c of n){if(!(c in t))throw new Error(`Struct ${i} requires field ${c}:${r[c]}`);const{name:n,params:u}=this.parseTypeName(r[c]);if(s.includes(n)){const r=s.indexOf(n);let{name:u,params:l}=this.parseTypeName(a[r]);if(this.hasType(u)){this.getTypeInterface(u)._encodeRaw.call(this,e,t[c],l,o);continue}if(!(u in o))throw new Error(`Unable to find a matching type definition for ${u} in ${i}; make sure you passed a generic`);let{name:d,params:h}=this.parseTypeName(o[u]);this.getTypeInterface(d)._encodeRaw.call(this,e,t[c],h,o)}else this.getTypeInterface(n)._encodeRaw.call(this,e,t[c],u,o)}return e}),(function(e,t,a){if(t.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${t.length}`);let o={};for(let c of n){const{name:n,params:u}=this.parseTypeName(r[c]);if(s.includes(n)){const r=s.indexOf(n);let{name:u,params:l}=this.parseTypeName(t[r]);if(this.hasType(u)){o[c]=this.getTypeInterface(u)._decodeRaw.call(this,e,l,a);continue}if(!(u in a))throw new Error(`Unable to find a matching type definition for ${u} in ${i}; make sure you passed a generic`);let{name:d,params:h}=this.parseTypeName(a[u]);o[c]=this.getTypeInterface(d)._decodeRaw.call(this,e,h,a)}else o[c]=this.getTypeInterface(n)._decodeRaw.call(this,e,u,a)}return o}))}registerEnumType(e,t){for(let a in t){let e=this.tempKey(),r=t[a];null!==r&&!Array.isArray(r)&&"string"!=typeof r&&(t[a]=e,this.registerStructType(e,r))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,a,o){if(!t)throw new Error(`Unable to write enum "${i}", missing data.\nReceived: "${t}"`);if("object"!=typeof t)throw new Error(`Incorrect data passed into enum "${i}", expected object with properties: "${n.join(" | ")}".\nReceived: "${JSON.stringify(t)}"`);let c=Object.keys(t)[0];if(void 0===c)throw new Error(`Empty object passed as invariant of the enum "${i}"`);let u=n.indexOf(c);if(-1===u)throw new Error(`Unknown invariant of the enum "${i}", allowed values: "${n.join(" | ")}"; received "${c}"`);let l=n[u],d=r[l];if(e.write8(u),null===d)return e;let h=s.indexOf(d),p=-1===h?d:a[h];{let{name:r,params:n}=this.parseTypeName(p);return this.getTypeInterface(r)._encodeRaw.call(this,e,t[c],n,o)}}),(function(e,t,a){let o=e.readULEB(),c=n[o],u=r[c];if(-1===o)throw new Error(`Decoding type mismatch, expected enum "${i}" invariant index, received "${o}"`);if(null===u)return{[c]:!0};let l=s.indexOf(u),d=-1===l?u:t[l];{let{name:t,params:r}=this.parseTypeName(d);return{[c]:this.getTypeInterface(t)._decodeRaw.call(this,e,r,a)}}}))}getTypeInterface(e){let t=this.types.get(e);if("string"==typeof t){let e=[];for(;"string"==typeof t;){if(e.includes(t))throw new Error(`Recursive definition found: ${e.join(" -> ")} -> ${t}`);e.push(t),t=this.types.get(t)}}if(void 0===t)throw new Error(`Type ${e} is not registered`);return t}parseTypeName(e){if(Array.isArray(e)){let[t,...r]=e;return{name:t,params:r}}if("string"!=typeof e)throw new Error(`Illegal type passed as a name of the type: ${e}`);let[t,r]=this.schema.genericSeparators||["<",">"],n=e.indexOf(t),i=Array.from(e).reverse().indexOf(r);if(-1===n&&-1===i)return{name:e,params:[]};if(-1===n||-1===i)throw new Error(`Unclosed generic in name '${e}'`);return{name:e.slice(0,n),params:k(e.slice(n+1,e.length-i-1),this.schema.genericSeparators)}}};let W=q;W.U8="u8",W.U16="u16",W.U32="u32",W.U64="u64",W.U128="u128",W.U256="u256",W.BOOL="bool",W.VECTOR="vector",W.ADDRESS="address",W.STRING="string",W.HEX="hex-string",W.BASE58="base58-string",W.BASE64="base64-string";function K(e){try{return 32===f(e).length}catch{return!1}}const L=32;function F(e){return function(e){return/^(0x|0X)?[a-fA-F0-9]+$/.test(e)&&e.length%2===0}(e)&&function(e){return/^(0x|0X)/.test(e)?(e.length-2)/2:e.length/2}(e)===L}function G(e){return F(e)}function J(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=e.toLowerCase();return!t&&r.startsWith("0x")&&(r=r.slice(2)),`0x${r.padStart(2*L,"0")}`}function Z(e){return J(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1])}class H extends TypeError{constructor(e,t){let r;const{message:n,explanation:i,...s}=e,{path:a}=e,o=0===a.length?n:`At path: ${a.join(".")} -- ${n}`;super(i??o),null!=i&&(this.cause=o),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>r??(r=[e,...t()])}}function X(e){return"object"==typeof e&&null!=e}function Q(e){return"symbol"==typeof e?e.toString():"string"==typeof e?JSON.stringify(e):`${e}`}function Y(e,t,r,n){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:i,branch:s}=t,{type:a}=r,{refinement:o,message:c=`Expected a value of type \`${a}\`${o?` with refinement \`${o}\``:""}, but received: \`${Q(n)}\``}=e;return{value:n,type:a,refinement:o,key:i[i.length-1],path:i,branch:s,...e,message:c}}function*ee(e,t,r,n){(function(e){return X(e)&&"function"==typeof e[Symbol.iterator]})(e)||(e=[e]);for(const i of e){const e=Y(i,t,r,n);e&&(yield e)}}function te(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return function*(){const{path:n=[],branch:i=[e],coerce:s=!1,mask:a=!1}=r,o={path:n,branch:i};if(s&&(e=t.coercer(e,o),a&&"type"!==t.type&&X(t.schema)&&X(e)&&!Array.isArray(e)))for(const r in e)void 0===t.schema[r]&&delete e[r];let c="valid";for(const u of t.validator(e,o))u.explanation=r.message,c="not_valid",yield[u,void 0];for(let[u,l,d]of t.entries(e,o)){const t=te(l,d,{path:void 0===u?n:[...n,u],branch:void 0===u?i:[...i,l],coerce:s,mask:a,message:r.message});for(const r of t)r[0]?(c=null!=r[0].refinement?"not_refined":"not_valid",yield[r[0],void 0]):s&&(l=r[1],void 0===u?e=l:e instanceof Map?e.set(u,l):e instanceof Set?e.add(l):X(e)&&(void 0!==l||u in e)&&(e[u]=l))}if("not_valid"!==c)for(const u of t.refiner(e,o))u.explanation=r.message,c="not_refined",yield[u,void 0];"valid"===c&&(yield[void 0,e])}()}class re{constructor(e){const{type:t,schema:r,validator:n,refiner:i,coercer:s=e=>e,entries:a=function*(){}}=e;this.type=t,this.schema=r,this.entries=a,this.coercer=s,this.validator=n?(e,t)=>ee(n(e,t),t,this,e):()=>[],this.refiner=i?(e,t)=>ee(i(e,t),t,this,e):()=>[]}assert(e,t){return ne(e,this,t)}create(e,t){return ie(e,this,t)}is(e){return ae(e,this)}mask(e,t){return se(e,this,t)}validate(e){return oe(e,this,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{})}}function ne(e,t,r){const n=oe(e,t,{message:r});if(n[0])throw n[0]}function ie(e,t,r){const n=oe(e,t,{coerce:!0,message:r});if(n[0])throw n[0];return n[1]}function se(e,t,r){const n=oe(e,t,{coerce:!0,mask:!0,message:r});if(n[0])throw n[0];return n[1]}function ae(e,t){return!oe(e,t)[0]}function oe(e,t){const r=te(e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}),n=function(e){const{done:t,value:r}=e.next();return t?void 0:r}(r);return n[0]?[new H(n[0],(function*(){for(const e of r)e[0]&&(yield e[0])})),void 0]:[void 0,n[1]]}function ce(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];const n="type"===t[0].type,i=t.map((e=>e.schema)),s=Object.assign({},...i);return n?function(e){const t=Object.keys(e);return new re({type:"type",schema:e,*entries(r){if(X(r))for(const n of t)yield[n,r[n],e[n]]},validator:e=>X(e)||`Expected an object, but received: ${Q(e)}`,coercer:e=>X(e)?{...e}:e})}(s):we(s)}function ue(e,t){return new re({type:e,schema:null,validator:t})}function le(){return ue("any",(()=>!0))}function de(e){return new re({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,n]of t.entries())yield[r,n,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${Q(e)}`})}function he(){return ue("boolean",(e=>"boolean"==typeof e))}function pe(){return ue("integer",(e=>"number"==typeof e&&!isNaN(e)&&Number.isInteger(e)||`Expected an integer, but received: ${Q(e)}`))}function fe(e){const t=Q(e),r=typeof e;return new re({type:"literal",schema:"string"===r||"number"===r||"boolean"===r?e:null,validator:r=>r===e||`Expected the literal \`${t}\`, but received: ${Q(r)}`})}function ge(){return ue("never",(()=>!1))}function me(e){return new re({...e,validator:(t,r)=>null===t||e.validator(t,r),refiner:(t,r)=>null===t||e.refiner(t,r)})}function ye(){return ue("number",(e=>"number"==typeof e&&!isNaN(e)||`Expected a number, but received: ${Q(e)}`))}function we(e){const t=e?Object.keys(e):[],r=ge();return new re({type:"object",schema:e||null,*entries(n){if(e&&X(n)){const i=new Set(Object.keys(n));for(const r of t)i.delete(r),yield[r,n[r],e[r]];for(const e of i)yield[e,n[e],r]}},validator:e=>X(e)||`Expected an object, but received: ${Q(e)}`,coercer:e=>X(e)?{...e}:e})}function be(e){return new re({...e,validator:(t,r)=>void 0===t||e.validator(t,r),refiner:(t,r)=>void 0===t||e.refiner(t,r)})}function ve(e,t){return new re({type:"record",schema:null,*entries(r){if(X(r))for(const n in r){const i=r[n];yield[n,n,e],yield[n,i,t]}},validator:e=>X(e)||`Expected an object, but received: ${Q(e)}`})}function Se(){return ue("string",(e=>"string"==typeof e||`Expected a string, but received: ${Q(e)}`))}function ke(e){const t=ge();return new re({type:"tuple",schema:null,*entries(r){if(Array.isArray(r)){const n=Math.max(e.length,r.length);for(let i=0;i<n;i++)yield[i,r[i],e[i]||t]}},validator:e=>Array.isArray(e)||`Expected an array, but received: ${Q(e)}`})}function Te(e){const t=e.map((e=>e.type)).join(" | ");return new re({type:"union",schema:null,coercer(t){for(const r of e){const[e,n]=r.validate(t,{coerce:!0});if(!e)return n}return t},validator(r,n){const i=[];for(const t of e){const[...e]=te(r,t,n),[s]=e;if(!s[0])return[];for(const[t]of e)t&&i.push(t)}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${Q(r)}`,...i]}})}function Ee(){return ue("unknown",(()=>!0))}BigInt(1e9);const xe="0x1";Z("0x6");Z("0x5");const je="::",Ie={"-32700":"ParseError","-32600":"InvalidRequest","-32601":"MethodNotFound","-32602":"InvalidParams","-32603":"InternalError"};class Be extends Error{}class Ae extends Be{constructor(e,t){super(e),this.code=t,this.type=Ie[t]??"ServerError"}}class Oe extends Be{constructor(e,t,r){super(e),this.status=t,this.statusText=r}}var Ce,Pe,Me,$e,Ue,ze,_e,Ne,Re,Ve,De=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},qe=(e,t,r)=>(De(e,t,"read from private field"),r?r.call(e):t.get(e)),We=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},Ke=(e,t,r,n)=>(De(e,t,"write to private field"),t.set(e,r),r),Le=(e,t,r)=>(De(e,t,"access private method"),r);const Fe={WebSocketConstructor:typeof WebSocket<"u"?WebSocket:void 0,callTimeout:3e4,reconnectTimeout:3e3,maxReconnects:5};class Ge{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(We(this,_e),We(this,Re),We(this,Ce,0),We(this,Pe,0),We(this,Me,null),We(this,$e,null),We(this,Ue,new Set),We(this,ze,new Map),this.endpoint=e,this.options={...Fe,...t},!this.options.WebSocketConstructor)throw new Error("Missing WebSocket constructor");this.endpoint.startsWith("http")&&(this.endpoint=function(e){const t=new URL(e);return t.protocol=t.protocol.replace("http","ws"),t.toString()}(this.endpoint))}async makeRequest(e,t){const r=await Le(this,_e,Ne).call(this);return new Promise(((n,i)=>{Ke(this,Ce,qe(this,Ce)+1),qe(this,ze).set(qe(this,Ce),{resolve:n,reject:i,timeout:setTimeout((()=>{qe(this,ze).delete(qe(this,Ce)),i(new Error(`Request timeout: ${e}`))}),this.options.callTimeout)}),r.send(JSON.stringify({jsonrpc:"2.0",id:qe(this,Ce),method:e,params:t}))})).then((e=>{let{error:t,result:r}=e;if(t)throw new Ae(t.message,t.code);return r}))}async subscribe(e){const t=new Je(e);return qe(this,Ue).add(t),await t.subscribe(this),()=>t.unsubscribe(this)}}Ce=new WeakMap,Pe=new WeakMap,Me=new WeakMap,$e=new WeakMap,Ue=new WeakMap,ze=new WeakMap,_e=new WeakSet,Ne=function(){return qe(this,$e)||Ke(this,$e,new Promise((e=>{var t;null==(t=qe(this,Me))||t.close(),Ke(this,Me,new this.options.WebSocketConstructor(this.endpoint)),qe(this,Me).addEventListener("open",(()=>{Ke(this,Pe,0),e(qe(this,Me))})),qe(this,Me).addEventListener("close",(()=>{((e,t,r,n)=>({set _(r){Ke(e,t,r)},get _(){return qe(e,t,n)}}))(this,Pe)._++,qe(this,Pe)<=this.options.maxReconnects&&setTimeout((()=>{Le(this,Re,Ve).call(this)}),this.options.reconnectTimeout)})),qe(this,Me).addEventListener("message",(e=>{let t,{data:r}=e;try{t=JSON.parse(r)}catch(n){return void console.error(new Error(`Failed to parse RPC message: ${r}`,{cause:n}))}if("id"in t&&null!=t.id&&qe(this,ze).has(t.id)){const{resolve:e,timeout:r}=qe(this,ze).get(t.id);clearTimeout(r),e(t)}else if("params"in t){const{params:e}=t;qe(this,Ue).forEach((t=>{t.subscriptionId===e.subscription&&e.subscription===t.subscriptionId&&t.onMessage(e.result)}))}}))}))),qe(this,$e)},Re=new WeakSet,Ve=async function(){var e;return null==(e=qe(this,Me))||e.close(),Ke(this,$e,null),Promise.allSettled([...qe(this,Ue)].map((e=>e.subscribe(this))))};class Je{constructor(e){this.subscriptionId=null,this.subscribed=!1,this.input=e}onMessage(e){this.subscribed&&this.input.onMessage(e)}async unsubscribe(e){const{subscriptionId:t}=this;return this.subscribed=!1,null!=t&&(this.subscriptionId=null,e.makeRequest(this.input.unsubscribe,[t]))}async subscribe(e){this.subscriptionId=null,this.subscribed=!0;const t=await e.makeRequest(this.input.method,this.input.params);this.subscribed&&(this.subscriptionId=t)}}var Ze,He,Xe,Qe,Ye,et=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},tt=(e,t,r)=>(et(e,t,"read from private field"),r?r.call(e):t.get(e)),rt=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},nt=(e,t,r,n)=>(et(e,t,"write to private field"),t.set(e,r),r);class it{constructor(e){rt(this,Qe),rt(this,Ze,0),rt(this,He,void 0),rt(this,Xe,void 0),nt(this,He,e)}fetch(e,t){const r=tt(this,He).fetch??globalThis.fetch;if(!this.fetch)throw new Error("The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport.");return r(e,t)}async request(e){var t,r;nt(this,Ze,tt(this,Ze)+1);const n=await this.fetch((null==(t=tt(this,He).rpc)?void 0:t.url)??tt(this,He).url,{method:"POST",headers:{"Content-Type":"application/json","Client-Sdk-Type":"typescript","Client-Sdk-Version":"0.50.1","Client-Target-Api-Version":"1.19.0",...null==(r=tt(this,He).rpc)?void 0:r.headers},body:JSON.stringify({jsonrpc:"2.0",id:tt(this,Ze),method:e.method,params:e.params})});if(!n.ok)throw new Oe(`Unexpected status code: ${n.status}`,n.status,n.statusText);const i=await n.json();if("error"in i&&null!=i.error)throw new Ae(i.error.message,i.error.code);return i.result}async subscribe(e){const t=await((e,t,r)=>(et(e,t,"access private method"),r))(this,Qe,Ye).call(this).subscribe(e);return async()=>!!await t()}}Ze=new WeakMap,He=new WeakMap,Xe=new WeakMap,Qe=new WeakSet,Ye=function(){var e;if(!tt(this,Xe)){const t=tt(this,He).WebSocketConstructor??globalThis.WebSocket;if(!t)throw new Error("The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport.");nt(this,Xe,new Ge((null==(e=tt(this,He).websocket)?void 0:e.url)??tt(this,He).url,{WebSocketConstructor:t,...tt(this,He).websocket}))}return tt(this,Xe)};const st=/^vector<(.+)>$/,at=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class ot{static parseFromStr(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("address"===e)return{address:null};if("bool"===e)return{bool:null};if("u8"===e)return{u8:null};if("u16"===e)return{u16:null};if("u32"===e)return{u32:null};if("u64"===e)return{u64:null};if("u128"===e)return{u128:null};if("u256"===e)return{u256:null};if("signer"===e)return{signer:null};const r=e.match(st);if(r)return{vector:ot.parseFromStr(r[1],t)};const n=e.match(at);if(n)return{struct:{address:t?J(n[1]):n[1],module:n[2],name:n[3],typeParams:void 0===n[5]?[]:ot.parseStructTypeArgs(n[5],t)}};throw new Error(`Encountered unexpected token when parsing type args for ${e}`)}static parseStructTypeArgs(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return k(e).map((e=>ot.parseFromStr(e,t)))}static tagToString(e){if("bool"in e)return"bool";if("u8"in e)return"u8";if("u16"in e)return"u16";if("u32"in e)return"u32";if("u64"in e)return"u64";if("u128"in e)return"u128";if("u256"in e)return"u256";if("address"in e)return"address";if("signer"in e)return"signer";if("vector"in e)return`vector<${ot.tagToString(e.vector)}>`;if("struct"in e){const t=e.struct,r=t.typeParams.map(ot.tagToString).join(", ");return`${t.address}::${t.module}::${t.name}${r?`<${r}>`:""}`}throw new Error("Invalid TypeTag")}}const ct=new W({genericSeparators:["<",">"],vectorType:"vector",addressLength:32,addressEncoding:"hex",types:{enums:{"Option<T>":{None:null,Some:"T"}}}});function ut(e){return D.u64({name:"unsafe_u64",...e}).transform({input:e=>e,output:e=>Number(e)})}function lt(e){return e.transform({input:e=>({[e.kind]:e}),output:e=>{const t=Object.keys(e)[0];return{kind:t,...e[t]}}})}const dt=D.bytes(L).transform({input:e=>"string"==typeof e?w(J(e)):e,output:e=>J(b(e))}),ht=D.vector(D.u8()).transform({name:"ObjectDigest",input:e=>f(e),output:e=>p(new Uint8Array(e))}),pt=D.struct("SuiObjectRef",{objectId:dt,version:D.u64(),digest:ht}),ft=D.struct("SharedObjectRef",{objectId:dt,initialSharedVersion:D.u64(),mutable:D.bool()}),gt=D.enum("ObjectArg",{ImmOrOwned:pt,Shared:ft,Receiving:pt}),mt=D.enum("CallArg",{Pure:D.vector(D.u8()),Object:gt,ObjVec:D.vector(gt)}),yt=D.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:D.lazy((()=>yt)),struct:D.lazy((()=>Et)),u16:null,u32:null,u256:null}),wt=lt(D.enum("Argument",{GasCoin:null,Input:D.struct("Input",{index:D.u16()}),Result:D.struct("Result",{index:D.u16()}),NestedResult:D.struct("NestedResult",{index:D.u16(),resultIndex:D.u16()})})),bt=D.struct("ProgrammableMoveCall",{package:dt,module:D.string(),function:D.string(),type_arguments:D.vector(yt),arguments:D.vector(wt)}).transform({input:e=>{const[t,r,n]=e.target.split("::"),i=e.typeArguments.map((e=>ot.parseFromStr(e,!0)));return{package:J(t),module:r,function:n,type_arguments:i,arguments:e.arguments}},output:e=>({target:[e.package,e.module,e.function].join("::"),arguments:e.arguments,typeArguments:e.type_arguments.map(ot.tagToString)})}),vt=lt(D.enum("Transaction",{MoveCall:bt,TransferObjects:D.struct("TransferObjects",{objects:D.vector(wt),address:wt}),SplitCoins:D.struct("SplitCoins",{coin:wt,amounts:D.vector(wt)}),MergeCoins:D.struct("MergeCoins",{destination:wt,sources:D.vector(wt)}),Publish:D.struct("Publish",{modules:D.vector(D.vector(D.u8())),dependencies:D.vector(dt)}),MakeMoveVec:D.struct("MakeMoveVec",{type:(qt=yt,D.enum("Option",{None:null,Some:qt})),objects:D.vector(wt)}),Upgrade:D.struct("Upgrade",{modules:D.vector(D.vector(D.u8())),dependencies:D.vector(dt),packageId:dt,ticket:wt})})),St=D.struct("ProgrammableTransaction",{inputs:D.vector(mt),transactions:D.vector(vt)}),kt=D.enum("TransactionKind",{ProgrammableTransaction:St,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),Tt=D.enum("TransactionExpiration",{None:null,Epoch:ut()}),Et=D.struct("StructTag",{address:dt,module:D.string(),name:D.string(),typeParams:D.vector(yt)}),xt=D.struct("GasData",{payment:D.vector(pt),owner:dt,price:D.u64(),budget:D.u64()}),jt=D.struct("TransactionDataV1",{kind:kt,sender:dt,gasData:xt,expiration:Tt}),It=D.enum("TransactionData",{V1:jt}),Bt=D.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),At=D.enum("IntentVersion",{V0:null}),Ot=D.enum("AppId",{Sui:null}),Ct=D.struct("Intent",{scope:Bt,version:At,appId:Ot}),Pt=D.generic(["T"],(e=>D.struct("IntentMessage<T>",{intent:Ct,value:e}))),Mt=D.enum("CompressedSignature",{ED25519:D.fixedArray(64,D.u8()),Secp256k1:D.fixedArray(64,D.u8()),Secp256r1:D.fixedArray(64,D.u8()),ZkLogin:D.vector(D.u8())}),$t=D.enum("PublicKey",{ED25519:D.fixedArray(32,D.u8()),Secp256k1:D.fixedArray(33,D.u8()),Secp256r1:D.fixedArray(33,D.u8()),ZkLogin:D.vector(D.u8())}),Ut=D.struct("MultiSigPkMap",{pubKey:$t,weight:D.u8()}),zt=D.struct("MultiSigPublicKey",{pk_map:D.vector(Ut),threshold:D.u16()}),_t=D.struct("MultiSig",{sigs:D.vector(Mt),bitmap:D.u16(),multisig_pk:zt}),Nt=D.vector(D.u8()).transform({input:e=>"string"==typeof e?g(e):e,output:e=>y(new Uint8Array(e))}),Rt=D.struct("SenderSignedTransaction",{intentMessage:Pt(It),txSignatures:D.vector(Nt)}),Vt=D.vector(Rt,{name:"SenderSignedData"}),Dt={...D,U8:D.u8(),U16:D.u16(),U32:D.u32(),U64:D.u64(),U128:D.u128(),U256:D.u256(),ULEB128:D.uleb128(),Bool:D.bool(),String:D.string(),Address:dt,Argument:wt,CallArg:mt,CompressedSignature:Mt,GasData:xt,MultiSig:_t,MultiSigPkMap:Ut,MultiSigPublicKey:zt,ObjectArg:gt,ObjectDigest:ht,ProgrammableMoveCall:bt,ProgrammableTransaction:St,PublicKey:$t,SenderSignedData:Vt,SenderSignedTransaction:Rt,SharedObjectRef:ft,StructTag:Et,SuiObjectRef:pt,Transaction:vt,TransactionData:It,TransactionDataV1:jt,TransactionExpiration:Tt,TransactionKind:kt,TypeTag:yt,ser:ct.ser.bind(ct),de:ct.de.bind(ct),getTypeInterface:ct.getTypeInterface.bind(ct),hasType:ct.hasType.bind(ct),parseTypeName:ct.parseTypeName.bind(ct),registerAddressType:ct.registerAddressType.bind(ct),registerAlias:ct.registerAlias.bind(ct),registerBcsType:ct.registerBcsType.bind(ct),registerEnumType:ct.registerEnumType.bind(ct),registerStructType:ct.registerStructType.bind(ct),registerType:ct.registerType.bind(ct),types:ct.types};var qt;ct.registerBcsType("utf8string",(()=>D.string({name:"utf8string"}))),ct.registerBcsType("unsafe_u64",(()=>ut())),ct.registerBcsType("enumKind",(e=>lt(e))),[dt,wt,mt,Mt,xt,_t,Ut,zt,gt,ht,bt,St,$t,Vt,ft,Et,pt,vt,It,jt,Tt,kt,yt].forEach((e=>{ct.registerBcsType(e.name,(()=>e))}));const Wt=Te([we({AddressOwner:Se()}),we({ObjectOwner:Se()}),we({Shared:we({initial_shared_version:me(Se())})}),fe("Immutable")]);ue("SuiJsonValue",(()=>!0));const Kt=Te([we({u32:Se()}),we({u64:Se()}),we({f64:Se()})]);we({attributes:ve(Se(),me(Kt)),featureFlags:ve(Se(),he()),maxSupportedProtocolVersion:Se(),minSupportedProtocolVersion:Se(),protocolVersion:Se()}),Te([Se(),fe("package")]);const Lt=we({digest:Se(),objectId:Se(),version:Te([ye(),Se(),ue("bigint",(e=>"bigint"==typeof e))])});we({owner:Wt,reference:Lt}),we({objectId:Se(),sequenceNumber:Se()}),we({payment:de(Lt),owner:Se(),price:Se(),budget:Se()});const Ft=ce(Lt,we({type:Se(),owner:Wt,previousTransaction:Se()})),Gt=ve(Se(),le()),Jt=ve(Se(),Ee()),Zt=we({type:Se(),fields:Gt,hasPublicTransfer:he()}),Ht=we({disassembled:Jt}),Xt=Te([ce(Zt,we({dataType:fe("moveObject")})),ce(Ht,we({dataType:fe("package")}))]),Qt=we({type:Se(),hasPublicTransfer:he(),version:Se(),bcsBytes:Se()}),Yt=we({id:Se(),moduleMap:ve(Se(),Se())}),er=Te([ce(Qt,we({dataType:fe("moveObject")})),ce(Yt,we({dataType:fe("package")}))]);BigInt(1e9);const tr=we({code:Se(),error:be(Se()),object_id:be(Se()),parent_object_id:be(Se()),version:be(Se()),digest:be(Se())}),rr=Te([we({data:me(be(ve(Se(),Se()))),error:me(be(tr))}),be(ve(Se(),Se()))]),nr=we({objectId:Se(),version:Se(),digest:Se(),type:me(be(Se())),content:me(be(Xt)),bcs:me(be(er)),owner:me(be(Wt)),previousTransaction:me(be(Se())),storageRebate:me(be(Se())),display:me(be(rr))});we({showType:me(be(he())),showContent:me(be(he())),showBcs:me(be(he())),showOwner:me(be(he())),showPreviousTransaction:me(be(he())),showStorageRebate:me(be(he())),showDisplay:me(be(he()))}),Te([fe("Exists"),fe("notExists"),fe("Deleted")]),de(Ft);const ir=we({data:me(be(nr)),error:me(be(tr))});function sr(e){if("reference"in e)return e.reference;const t=function(e){return e.data}(e);return t?{objectId:t.objectId,version:t.version,digest:t.digest}:function(e){if(e.error&&"object_id"in e.error&&"version"in e.error&&"digest"in e.error){const t=e.error;return{objectId:t.object_id,version:t.version,digest:t.digest}}}(e)}we({objectId:Se(),atCheckpoint:be(ye())}),we({data:de(ir),nextCursor:be(me(Se())),hasNextPage:he()}),Te([we({details:nr,status:fe("VersionFound")}),we({details:Se(),status:fe("ObjectNotExists")}),we({details:Lt,status:fe("ObjectDeleted")}),we({details:ke([Se(),ye()]),status:fe("VersionNotFound")}),we({details:we({asked_version:ye(),latest_version:ye(),object_id:Se()}),status:fe("VersionTooHigh")})]);de(Te([Se(),we({Object:Se()})]));const ar=we({address:Se(),name:Se()}),or=Te([fe("Private"),fe("Public"),fe("Friend")]),cr=we({abilities:de(Se())}),ur=we({constraints:cr,isPhantom:he()}),lr=we({TypeParameter:ye()}),dr=ke([we({module:Se(),package:Se(),function:Se()}),Se()]);function hr(e){if(!e)return!1;if("string"==typeof e||ae(e,lr)||fr(e))return!0;if("object"!=typeof e)return!1;const t=e;return!!(ae(t.Reference,pr)||ae(t.MutableReference,pr)||ae(t.Vector,pr))}we({rank3Days:de(dr),rank7Days:de(dr),rank30Days:de(dr)});const pr=ue("SuiMoveNormalizedType",hr);function fr(e){if(!e||"object"!=typeof e)return!1;const t=e;if(!t.Struct||"object"!=typeof t.Struct)return!1;const r=t.Struct;return!("string"!=typeof r.address||"string"!=typeof r.module||"string"!=typeof r.name||!Array.isArray(r.typeArguments)||!r.typeArguments.every((e=>hr(e))))}ue("SuiMoveNormalizedStructType",fr);const gr=we({visibility:or,isEntry:he(),typeParameters:de(cr),parameters:de(pr),return:de(pr)}),mr=we({name:Se(),type:pr}),yr=we({abilities:cr,typeParameters:de(ur),fields:de(mr)}),wr=we({fileFormatVersion:ye(),address:Se(),name:Se(),friends:de(ar),structs:ve(Se(),yr),exposedFunctions:ve(Se(),gr)});function br(e){return"object"==typeof e&&"MutableReference"in e?e.MutableReference:void 0}function vr(e){return"object"==typeof e&&"Reference"in e?e.Reference:void 0}function Sr(e){if("object"==typeof e&&"Struct"in e)return e;const t=vr(e),r=br(e);return"object"==typeof t&&"Struct"in t?t:"object"==typeof r&&"Struct"in r?r:void 0}ve(Se(),wr);const kr=Te([we({ImmOrOwned:Lt}),we({Shared:we({objectId:Se(),initialSharedVersion:Te([pe(),Se()]),mutable:he()})}),we({Receiving:Lt})]),Tr=we({Pure:de(pe())}),Er=we({Object:kr}),xr=Te([Tr,Er]);const jr={Pure:function(e,t){return{Pure:Array.from(e instanceof Uint8Array?e:z(e)?e.toBytes():Dt.ser(t,e,{maxSize:1/0}).toBytes())}},ObjectRef(e){let{objectId:t,digest:r,version:n}=e;return{Object:{ImmOrOwned:{digest:r,version:n,objectId:J(t)}}}},SharedObjectRef(e){let{objectId:t,mutable:r,initialSharedVersion:n}=e;return{Object:{Shared:{mutable:r,initialSharedVersion:n,objectId:J(t)}}}},ReceivingRef(e){let{objectId:t,digest:r,version:n}=e;return{Object:{Receiving:{digest:r,version:n,objectId:J(t)}}}}};function Ir(e){return"string"==typeof e?J(e):"ImmOrOwned"in e.Object?J(e.Object.ImmOrOwned.objectId):"Receiving"in e.Object?J(e.Object.Receiving.objectId):J(e.Object.Shared.objectId)}function Br(e){function t(t,r){return e(t,r)}return t.u8=t=>e(Dt.U8.serialize(t)),t.u16=t=>e(Dt.U16.serialize(t)),t.u32=t=>e(Dt.U32.serialize(t)),t.u64=t=>e(Dt.U64.serialize(t)),t.u128=t=>e(Dt.U128.serialize(t)),t.u256=t=>e(Dt.U256.serialize(t)),t.bool=t=>e(Dt.Bool.serialize(t)),t.string=t=>e(Dt.String.serialize(t)),t.address=t=>e(Dt.Address.serialize(t)),t.id=t.address,t}const Ar={address:"0x2",module:"object",name:"ID"},Or={address:xe,module:"ascii",name:"String"},Cr={address:xe,module:"string",name:"String"},Pr={address:xe,module:"option",name:"Option"},Mr=(e,t)=>e.address===t.address&&e.module===t.module&&e.name===t.name;function $r(e,t){if(!(typeof t>"u")&&typeof t!==e)throw new Error(`Expect ${t} to be ${e}, received ${typeof t}`)}const Ur=["Address","Bool","U8","U16","U32","U64","U128","U256"];function zr(e,t){if("string"==typeof e&&Ur.includes(e)){if(e in["U8","U16","U32","U64","U128","U256"])$r("number",t);else if("Bool"===e)$r("boolean",t);else if("Address"===e&&($r("string",t),t&&!F(t)))throw new Error("Invalid Sui Address");return e.toLowerCase()}if("string"==typeof e)throw new Error(`Unknown pure normalized type ${JSON.stringify(e,null,2)}`);if("Vector"in e){if((void 0===t||"string"==typeof t)&&"U8"===e.Vector)return"string";if(void 0!==t&&!Array.isArray(t))throw new Error(`Expect ${t} to be a array, received ${typeof t}`);const r=zr(e.Vector,t?t[0]:void 0);return void 0===r?void 0:`vector<${r}>`}if("Struct"in e){if(Mr(e.Struct,Or))return"string";if(Mr(e.Struct,Cr))return"utf8string";if(Mr(e.Struct,Ar))return"address";if(Mr(e.Struct,Pr)){return zr({Vector:e.Struct.typeArguments[0]},t)}}}function _r(e,t){return ie(e,t)}const Nr=Te([we({kind:fe("Input"),index:pe(),value:be(le()),type:be(fe("object"))}),we({kind:fe("Input"),index:pe(),value:be(le()),type:fe("pure")})]),Rr=Te([...[Nr,we({kind:fe("GasCoin")}),we({kind:fe("Result"),index:pe()}),we({kind:fe("NestedResult"),index:pe(),resultIndex:pe()})]]),Vr=we({kind:fe("MoveCall"),target:ue("target",Se().validator),typeArguments:de(Se()),arguments:de(Rr)}),Dr=we({kind:fe("TransferObjects"),objects:de(Rr),address:Rr}),qr=we({kind:fe("SplitCoins"),coin:Rr,amounts:de(Rr)}),Wr=we({kind:fe("MergeCoins"),destination:Rr,sources:de(Rr)}),Kr=we({kind:fe("MakeMoveVec"),type:be((e=>Te([we({None:Te([fe(!0),fe(null)])}),we({Some:e})]))(ve(Se(),Ee()))),objects:de(Rr)}),Lr=we({kind:fe("Publish"),modules:de(de(pe())),dependencies:de(Se())}),Fr=we({kind:fe("Upgrade"),modules:de(de(pe())),dependencies:de(Se()),packageId:Se(),ticket:Rr}),Gr=Te([...[Vr,Dr,qr,Wr,Lr,Fr,Kr]]),Jr={MoveCall:e=>_r({kind:"MoveCall",target:e.target,arguments:e.arguments??[],typeArguments:e.typeArguments??[]},Vr),TransferObjects:(e,t)=>("Input"===t.kind&&"pure"===t.type&&"object"!=typeof t.value&&(t.value=jr.Pure(Dt.Address.serialize(t.value))),_r({kind:"TransferObjects",objects:e,address:t},Dr)),SplitCoins:(e,t)=>(t.forEach((e=>{"Input"===e.kind&&"pure"===e.type&&"object"!=typeof e.value&&(e.value=jr.Pure(Dt.U64.serialize(e.value)))})),_r({kind:"SplitCoins",coin:e,amounts:t},qr)),MergeCoins:(e,t)=>_r({kind:"MergeCoins",destination:e,sources:t},Wr),Publish(e){let{modules:t,dependencies:r}=e;return _r({kind:"Publish",modules:t.map((e=>"string"==typeof e?Array.from(g(e)):e)),dependencies:r.map((e=>Z(e)))},Lr)},Upgrade(e){let{modules:t,dependencies:r,packageId:n,ticket:i}=e;return _r({kind:"Upgrade",modules:t.map((e=>"string"==typeof e?Array.from(g(e)):e)),dependencies:r.map((e=>Z(e))),packageId:n,ticket:i},Fr)},MakeMoveVec(e){let{type:t,objects:r}=e;return _r({kind:"MakeMoveVec",type:t?{Some:ot.parseFromStr(t)}:{None:null},objects:r},Kr)}},Zr=be(me(Te([we({Epoch:pe()}),we({None:Te([fe(!0),fe(null)])})]))),Hr=ue("StringEncodedBigint",(e=>{if(!["string","number","bigint"].includes(typeof e))return!1;try{return BigInt(e),!0}catch{return!1}})),Xr=we({budget:be(Hr),price:be(Hr),payment:be(de(Lt)),owner:be(Se())}),Qr=we({version:fe(1),sender:be(Se()),expiration:Zr,gasConfig:Xr,inputs:de(Nr),transactions:de(Gr)});function Yr(e){return J(e).replace("0x","")}class en{constructor(e){this.version=1,this.sender=null==e?void 0:e.sender,this.expiration=null==e?void 0:e.expiration,this.gasConfig=(null==e?void 0:e.gasConfig)??{},this.inputs=(null==e?void 0:e.inputs)??[],this.transactions=(null==e?void 0:e.transactions)??[]}static fromKindBytes(e){const t=Dt.TransactionKind.parse(e),r="ProgrammableTransaction"in t?t.ProgrammableTransaction:null;if(!r)throw new Error("Unable to deserialize from bytes.");const n=_r({version:1,gasConfig:{},inputs:r.inputs.map(((e,t)=>_r({kind:"Input",value:e,index:t,type:ae(e,Tr)?"pure":"object"},Nr))),transactions:r.transactions},Qr);return en.restore(n)}static fromBytes(e){var t;const r=Dt.TransactionData.parse(e),n=null==r?void 0:r.V1,i="ProgrammableTransaction"in n.kind?null==(t=null==n?void 0:n.kind)?void 0:t.ProgrammableTransaction:null;if(!n||!i)throw new Error("Unable to deserialize from bytes.");const s=_r({version:1,sender:n.sender,expiration:n.expiration,gasConfig:n.gasData,inputs:i.inputs.map(((e,t)=>_r({kind:"Input",value:e,index:t,type:ae(e,Tr)?"pure":"object"},Nr))),transactions:i.transactions},Qr);return en.restore(s)}static restore(e){ne(e,Qr);const t=new en;return Object.assign(t,e),t}static getDigestFromBytes(e){const t=function(e,t){const r=Array.from(`${e}::`).map((e=>e.charCodeAt(0))),i=new Uint8Array(r.length+t.length);return i.set(r),i.set(t,r.length),(0,n.b1)(i,{dkLen:32})}("TransactionData",e);return p(t)}build(){let{maxSizeBytes:e=1/0,overrides:t,onlyTransactionKind:r}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=this.inputs.map((e=>(ne(e.value,xr),e.value))),i={ProgrammableTransaction:{inputs:n,transactions:this.transactions}};if(r)return Dt.TransactionKind.serialize(i,{maxSize:e}).toBytes();const s=(null==t?void 0:t.expiration)??this.expiration,a=(null==t?void 0:t.sender)??this.sender,o={...this.gasConfig,...null==t?void 0:t.gasConfig};if(!a)throw new Error("Missing transaction sender");if(!o.budget)throw new Error("Missing gas budget");if(!o.payment)throw new Error("Missing gas payment");if(!o.price)throw new Error("Missing gas price");const c={sender:Yr(a),expiration:s||{None:!0},gasData:{payment:o.payment,owner:Yr(this.gasConfig.owner??a),price:BigInt(o.price),budget:BigInt(o.budget)},kind:{ProgrammableTransaction:{inputs:n,transactions:this.transactions}}};return Dt.TransactionData.serialize({V1:c},{maxSize:e}).toBytes()}getDigest(){const e=this.build({onlyTransactionKind:!1});return en.getDigestFromBytes(e)}snapshot(){return _r(this,Qr)}}var tn,rn,nn,sn,an,on,cn,un,ln,dn,hn,pn,fn,gn,mn,yn,wn,bn=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},vn=(e,t,r)=>(bn(e,t,"read from private field"),r?r.call(e):t.get(e)),Sn=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},kn=(e,t,r,n)=>(bn(e,t,"write to private field"),t.set(e,r),r),Tn=(e,t,r)=>(bn(e,t,"access private method"),r);const En={maxPureArgumentSize:16384,maxTxGas:5e10,maxGasObjects:256,maxTxSizeBytes:131072};function xn(e){if(!e.client)throw new Error("No provider passed to Transaction#build, but transaction data was not sufficient to build offline.");return e.client}const jn=Symbol.for("@mysten/transaction"),In={maxTxGas:"max_tx_gas",maxGasObjects:"max_gas_payment_objects",maxTxSizeBytes:"max_tx_size_bytes",maxPureArgumentSize:"max_pure_argument_size"};const Bn=class{constructor(e){Sn(this,rn),Sn(this,sn),Sn(this,on),Sn(this,un),Sn(this,dn),Sn(this,pn),Sn(this,gn),Sn(this,yn),Sn(this,tn,void 0),kn(this,tn,new en(e?e.blockData:void 0))}static fromKind(e){const t=new Bn;return kn(t,tn,en.fromKindBytes("string"==typeof e?g(e):e)),t}static from(e){const t=new Bn;return"string"==typeof e&&e.startsWith("{")?kn(t,tn,en.restore(JSON.parse(e))):kn(t,tn,en.fromBytes("string"==typeof e?g(e):e)),t}setSender(e){vn(this,tn).sender=e}setSenderIfNotSet(e){vn(this,tn).sender||(vn(this,tn).sender=e)}setExpiration(e){vn(this,tn).expiration=e}setGasPrice(e){vn(this,tn).gasConfig.price=String(e)}setGasBudget(e){vn(this,tn).gasConfig.budget=String(e)}setGasOwner(e){vn(this,tn).gasConfig.owner=e}setGasPayment(e){vn(this,tn).gasConfig.payment=e.map((e=>se(e,Lt)))}get blockData(){return vn(this,tn).snapshot()}get[jn](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:Br(((e,t)=>z(e)?Tn(this,rn,nn).call(this,"pure",{Pure:Array.from(e.toBytes())}):Tn(this,rn,nn).call(this,"pure",e instanceof Uint8Array?jr.Pure(e):t?jr.Pure(e,t):e)))}),this.pure}get gas(){return{kind:"GasCoin"}}object(e){if("object"==typeof e&&"kind"in e)return e;const t=Ir(e),r=vn(this,tn).inputs.find((e=>"object"===e.type&&t===Ir(e.value)));return r&&ae(r.value,Er)&&"Shared"in r.value.Object&&ae(e,Er)&&"Shared"in e.Object&&(r.value.Object.Shared.mutable=r.value.Object.Shared.mutable||e.Object.Shared.mutable),r??Tn(this,rn,nn).call(this,"object","string"==typeof e?J(e):e)}objectRef(){return this.object(jr.ObjectRef(...arguments))}receivingRef(){return this.object(jr.ReceivingRef(...arguments))}sharedObjectRef(){return this.object(jr.SharedObjectRef(...arguments))}add(e){return function(e){const t=[],r=r=>t[r]??(t[r]={kind:"NestedResult",index:e,resultIndex:r});return new Proxy({kind:"Result",index:e},{set(){throw new Error("The transaction result is a proxy, and does not support setting properties directly")},get(e,t){if(t in e)return Reflect.get(e,t);if(t===Symbol.iterator)return function*(){let e=0;for(;;)yield r(e),e++};if("symbol"==typeof t)return;const n=parseInt(t,10);return Number.isNaN(n)||n<0?void 0:r(n)}})}(vn(this,tn).transactions.push(e)-1)}splitCoins(e,t){return this.add(Jr.SplitCoins("string"==typeof e?this.object(e):e,t.map((e=>"number"==typeof e||"bigint"==typeof e||"string"==typeof e?this.pure.u64(e):Tn(this,sn,an).call(this,e)))))}mergeCoins(e,t){return this.add(Jr.MergeCoins("string"==typeof e?this.object(e):e,t.map((e=>"string"==typeof e?this.object(e):e))))}publish(e){let{modules:t,dependencies:r}=e;return this.add(Jr.Publish({modules:t,dependencies:r}))}upgrade(e){let{modules:t,dependencies:r,packageId:n,ticket:i}=e;return this.add(Jr.Upgrade({modules:t,dependencies:r,packageId:n,ticket:"string"==typeof i?this.object(i):i}))}moveCall(e){let{arguments:t,typeArguments:r,target:n}=e;return this.add(Jr.MoveCall({arguments:null==t?void 0:t.map((e=>Tn(this,sn,an).call(this,e))),typeArguments:r,target:n}))}transferObjects(e,t){return this.add(Jr.TransferObjects(e.map((e=>"string"==typeof e?this.object(e):e)),"string"==typeof t?this.pure.address(t):Tn(this,sn,an).call(this,t)))}makeMoveVec(e){let{type:t,objects:r}=e;return this.add(Jr.MakeMoveVec({type:t,objects:r.map((e=>"string"==typeof e?this.object(e):e))}))}serialize(){return JSON.stringify(vn(this,tn).snapshot())}async sign(e){const{signer:t,...r}=e,n=await this.build(r);return t.signTransactionBlock(n)}async build(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return await Tn(this,yn,wn).call(this,e),vn(this,tn).build({maxSizeBytes:Tn(this,on,cn).call(this,"maxTxSizeBytes",e),onlyTransactionKind:e.onlyTransactionKind})}async getDigest(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return await Tn(this,yn,wn).call(this,e),vn(this,tn).getDigest()}};let An=Bn;tn=new WeakMap,rn=new WeakSet,nn=function(e,t){const r=vn(this,tn).inputs.length,n=_r({kind:"Input",value:"bigint"==typeof t?String(t):t,index:r,type:e},Nr);return vn(this,tn).inputs.push(n),n},sn=new WeakSet,an=function(e){return z(e)?this.pure(e):e},on=new WeakSet,cn=function(e,t){let{protocolConfig:r,limits:n}=t;if(n&&"number"==typeof n[e])return n[e];if(!r)return En[e];const i=null==r?void 0:r.attributes[In[e]];if(!i)throw new Error(`Missing expected protocol config: "${In[e]}"`);const s="u64"in i?i.u64:"u32"in i?i.u32:i.f64;if(!s)throw new Error(`Unexpected protocol config value found for: "${In[e]}"`);return Number(s)},un=new WeakSet,ln=function(e){const t=Tn(this,on,cn).call(this,"maxPureArgumentSize",e);vn(this,tn).inputs.forEach(((e,r)=>{if(ae(e.value,Tr)&&e.value.Pure.length>t)throw new Error(`Input at index ${r} is too large, max pure input size is ${t} bytes, got ${e.value.Pure.length} bytes`)}))},dn=new WeakSet,hn=async function(e){if(vn(this,tn).gasConfig.payment){const t=Tn(this,on,cn).call(this,"maxGasObjects",e);if(vn(this,tn).gasConfig.payment.length>t)throw new Error(`Payment objects exceed maximum amount: ${t}`)}if(e.onlyTransactionKind||vn(this,tn).gasConfig.payment)return;const t=vn(this,tn).gasConfig.owner??vn(this,tn).sender,r=(await xn(e).getCoins({owner:t,coinType:"0x2::sui::SUI"})).data.filter((e=>!vn(this,tn).inputs.find((t=>!!(ae(t.value,xr)&&"Object"in t.value&&"ImmOrOwned"in t.value.Object)&&e.coinObjectId===t.value.Object.ImmOrOwned.objectId)))).slice(0,Tn(this,on,cn).call(this,"maxGasObjects",e)-1).map((e=>({objectId:e.coinObjectId,digest:e.digest,version:e.version})));if(!r.length)throw new Error("No valid gas coins found for the transaction.");this.setGasPayment(r)},pn=new WeakSet,fn=async function(e){e.onlyTransactionKind||vn(this,tn).gasConfig.price||this.setGasPrice(await xn(e).getReferenceGasPrice())},gn=new WeakSet,mn=async function(e){const{inputs:t,transactions:r}=vn(this,tn),n=[],i=[];if(t.forEach((e=>{"object"!==e.type||"string"!=typeof e.value||i.push({id:J(e.value),input:e})})),r.forEach((e=>{if("MoveCall"===e.kind&&e.arguments.some((e=>"Input"===e.kind&&!ae(t[e.index].value,xr)))&&n.push(e),"SplitCoins"===e.kind&&e.amounts.forEach((e=>{if("Input"===e.kind){const r=t[e.index];"object"!=typeof r.value&&(r.value=jr.Pure(Dt.U64.serialize(r.value)))}})),"TransferObjects"===e.kind&&"Input"===e.address.kind){const r=t[e.address.index];"object"!=typeof r.value&&(r.value=jr.Pure(Dt.Address.serialize(r.value)))}})),n.length&&await Promise.all(n.map((async r=>{const[n,s,a]=r.target.split("::"),o=await xn(e).getNormalizedMoveFunction({package:Z(n),module:s,function:a}),c=o.parameters.length>0&&function(e){var t;const r=null==(t=Sr(e))?void 0:t.Struct;return"0x2"===(null==r?void 0:r.address)&&"tx_context"===(null==r?void 0:r.module)&&"TxContext"===(null==r?void 0:r.name)}(o.parameters.at(-1))?o.parameters.slice(0,o.parameters.length-1):o.parameters;if(c.length!==r.arguments.length)throw new Error("Incorrect number of arguments.");c.forEach(((e,n)=>{const s=r.arguments[n];if("Input"!==s.kind)return;const a=t[s.index];if(ae(a.value,xr))return;const o=a.value,c=zr(e,o);if(c)a.value=jr.Pure(o,c);else{if(!(null!=Sr(e)||"object"==typeof e&&"TypeParameter"in e))throw new Error(`Unknown call arg type ${JSON.stringify(e,null,2)} for value ${JSON.stringify(o,null,2)}`);if("string"!=typeof o)throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(o,null,2)}`);i.push({id:o,input:a,normalizedType:e})}}))}))),i.length){const t=[...new Set(i.map((e=>{let{id:t}=e;return t})))],r=((e,t)=>Array.from({length:Math.ceil(e.length/t)},((r,n)=>e.slice(n*t,n*t+t))))(t,50),n=(await Promise.all(r.map((t=>xn(e).multiGetObjects({ids:t,options:{showOwner:!0}}))))).flat();let s=new Map(t.map(((e,t)=>[e,n[t]])));const a=Array.from(s).filter((e=>{let[t,r]=e;return r.error})).map((e=>{let[t,r]=e;return t}));if(a.length)throw new Error(`The following input objects are invalid: ${a.join(", ")}`);i.forEach((e=>{let{id:t,input:r,normalizedType:n}=e;var i;const a=s.get(t),o=null==(i=a.data)?void 0:i.owner,c=o&&"object"==typeof o&&"Shared"in o?o.Shared.initial_shared_version:void 0;if(c){const e=null!=n&&null==br(n)&&null==vr(n),i=function(e){var t;return(null==(t=function(e){return"object"==typeof e&&"Object"in e&&"Shared"in e.Object?e.Object.Shared:void 0}(e))?void 0:t.mutable)??!1}(r.value)||e||null!=n&&null!=br(n);r.value=jr.SharedObjectRef({objectId:t,initialSharedVersion:c,mutable:i})}else n&&function(e){const t=Sr(e);return!!t&&"0x2"===t.Struct.address&&"transfer"===t.Struct.module&&"Receiving"===t.Struct.name}(n)?r.value=jr.ReceivingRef(sr(a)):r.value=jr.ObjectRef(sr(a))}))}},yn=new WeakSet,wn=async function(e){if(!e.onlyTransactionKind&&!vn(this,tn).sender)throw new Error("Missing transaction sender");if(!e.protocolConfig&&!e.limits&&e.client&&(e.protocolConfig=await e.client.getProtocolConfig()),await Promise.all([Tn(this,pn,fn).call(this,e),Tn(this,gn,mn).call(this,e)]),!e.onlyTransactionKind&&(await Tn(this,dn,hn).call(this,e),!vn(this,tn).gasConfig.budget)){const t=await xn(e).dryRunTransactionBlock({transactionBlock:vn(this,tn).build({maxSizeBytes:Tn(this,on,cn).call(this,"maxTxSizeBytes",e),overrides:{gasConfig:{budget:String(Tn(this,on,cn).call(this,"maxTxGas",e)),payment:[]}}})});if("success"!==t.effects.status.status)throw new Error(`Dry run failed, could not automatically determine a budget: ${t.effects.status.error}`,{cause:t});const r=1000n*BigInt(this.blockData.gasConfig.price||1n),n=BigInt(t.effects.gasUsed.computationCost)+r,i=n+BigInt(t.effects.gasUsed.storageCost)-BigInt(t.effects.gasUsed.storageRebate);this.setGasBudget(i>n?i:n)}Tn(this,un,ln).call(this,e)};const On=Symbol.for("@mysten/SuiClient");class Cn{get[On](){return!0}constructor(e){this.transport=e.transport??new it({url:e.url})}async getRpcApiVersion(){return(await this.transport.request({method:"rpc.discover",params:[]})).info.version}async getCoins(e){if(!e.owner||!F(J(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getCoins",params:[e.owner,e.coinType,e.cursor,e.limit]})}async getAllCoins(e){if(!e.owner||!F(J(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllCoins",params:[e.owner,e.cursor,e.limit]})}async getBalance(e){if(!e.owner||!F(J(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getBalance",params:[e.owner,e.coinType]})}async getAllBalances(e){if(!e.owner||!F(J(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllBalances",params:[e.owner]})}async getCoinMetadata(e){return await this.transport.request({method:"suix_getCoinMetadata",params:[e.coinType]})}async getTotalSupply(e){return await this.transport.request({method:"suix_getTotalSupply",params:[e.coinType]})}async call(e,t){return await this.transport.request({method:e,params:t})}async getMoveFunctionArgTypes(e){return await this.transport.request({method:"sui_getMoveFunctionArgTypes",params:[e.package,e.module,e.function]})}async getNormalizedMoveModulesByPackage(e){return await this.transport.request({method:"sui_getNormalizedMoveModulesByPackage",params:[e.package]})}async getNormalizedMoveModule(e){return await this.transport.request({method:"sui_getNormalizedMoveModule",params:[e.package,e.module]})}async getNormalizedMoveFunction(e){return await this.transport.request({method:"sui_getNormalizedMoveFunction",params:[e.package,e.module,e.function]})}async getNormalizedMoveStruct(e){return await this.transport.request({method:"sui_getNormalizedMoveStruct",params:[e.package,e.module,e.struct]})}async getOwnedObjects(e){if(!e.owner||!F(J(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getOwnedObjects",params:[e.owner,{filter:e.filter,options:e.options},e.cursor,e.limit]})}async getObject(e){if(!e.id||!G(Z(e.id)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"sui_getObject",params:[e.id,e.options]})}async tryGetPastObject(e){return await this.transport.request({method:"sui_tryGetPastObject",params:[e.id,e.version,e.options]})}async multiGetObjects(e){if(e.ids.forEach((e=>{if(!e||!G(Z(e)))throw new Error(`Invalid Sui Object id ${e}`)})),e.ids.length!==new Set(e.ids).size)throw new Error(`Duplicate object ids in batch call ${e.ids}`);return await this.transport.request({method:"sui_multiGetObjects",params:[e.ids,e.options]})}async queryTransactionBlocks(e){return await this.transport.request({method:"suix_queryTransactionBlocks",params:[{filter:e.filter,options:e.options},e.cursor,e.limit,"descending"===(e.order||"descending")]})}async getTransactionBlock(e){if(!K(e.digest))throw new Error("Invalid Transaction digest");return await this.transport.request({method:"sui_getTransactionBlock",params:[e.digest,e.options]})}async multiGetTransactionBlocks(e){if(e.digests.forEach((e=>{if(!K(e))throw new Error(`Invalid Transaction digest ${e}`)})),e.digests.length!==new Set(e.digests).size)throw new Error(`Duplicate digests in batch call ${e.digests}`);return await this.transport.request({method:"sui_multiGetTransactionBlocks",params:[e.digests,e.options]})}async executeTransactionBlock(e){return await this.transport.request({method:"sui_executeTransactionBlock",params:["string"==typeof e.transactionBlock?e.transactionBlock:y(e.transactionBlock),Array.isArray(e.signature)?e.signature:[e.signature],e.options,e.requestType]})}async signAndExecuteTransactionBlock(e){let t,{transactionBlock:r,signer:n,...i}=e;r instanceof Uint8Array?t=r:(r.setSenderIfNotSet(n.toSuiAddress()),t=await r.build({client:this}));const{signature:s,bytes:a}=await n.signTransactionBlock(t);return this.executeTransactionBlock({transactionBlock:a,signature:s,...i})}async getTotalTransactionBlocks(){const e=await this.transport.request({method:"sui_getTotalTransactionBlocks",params:[]});return BigInt(e)}async getReferenceGasPrice(){const e=await this.transport.request({method:"suix_getReferenceGasPrice",params:[]});return BigInt(e)}async getStakes(e){if(!e.owner||!F(J(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getStakes",params:[e.owner]})}async getStakesByIds(e){return e.stakedSuiIds.forEach((e=>{if(!e||!G(Z(e)))throw new Error(`Invalid Sui Stake id ${e}`)})),await this.transport.request({method:"suix_getStakesByIds",params:[e.stakedSuiIds]})}async getLatestSuiSystemState(){return await this.transport.request({method:"suix_getLatestSuiSystemState",params:[]})}async queryEvents(e){return await this.transport.request({method:"suix_queryEvents",params:[e.query,e.cursor,e.limit,"descending"===(e.order||"descending")]})}async subscribeEvent(e){return this.transport.subscribe({method:"suix_subscribeEvent",unsubscribe:"suix_unsubscribeEvent",params:[e.filter],onMessage:e.onMessage})}async subscribeTransaction(e){return this.transport.subscribe({method:"suix_subscribeTransaction",unsubscribe:"suix_unsubscribeTransaction",params:[e.filter],onMessage:e.onMessage})}async devInspectTransactionBlock(e){var t;let r;if(function(e){return!!e&&"object"==typeof e&&!0===e[jn]}(e.transactionBlock))e.transactionBlock.setSenderIfNotSet(e.sender),r=y(await e.transactionBlock.build({client:this,onlyTransactionKind:!0}));else if("string"==typeof e.transactionBlock)r=e.transactionBlock;else{if(!(e.transactionBlock instanceof Uint8Array))throw new Error("Unknown transaction block format.");r=y(e.transactionBlock)}return await this.transport.request({method:"sui_devInspectTransactionBlock",params:[e.sender,r,null==(t=e.gasPrice)?void 0:t.toString(),e.epoch]})}async dryRunTransactionBlock(e){return await this.transport.request({method:"sui_dryRunTransactionBlock",params:["string"==typeof e.transactionBlock?e.transactionBlock:y(e.transactionBlock)]})}async getDynamicFields(e){if(!e.parentId||!G(Z(e.parentId)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"suix_getDynamicFields",params:[e.parentId,e.cursor,e.limit]})}async getDynamicFieldObject(e){return await this.transport.request({method:"suix_getDynamicFieldObject",params:[e.parentId,e.name]})}async getLatestCheckpointSequenceNumber(){const e=await this.transport.request({method:"sui_getLatestCheckpointSequenceNumber",params:[]});return String(e)}async getCheckpoint(e){return await this.transport.request({method:"sui_getCheckpoint",params:[e.id]})}async getCheckpoints(e){return await this.transport.request({method:"sui_getCheckpoints",params:[e.cursor,null==e?void 0:e.limit,e.descendingOrder]})}async getCommitteeInfo(e){return await this.transport.request({method:"suix_getCommitteeInfo",params:[null==e?void 0:e.epoch]})}async getNetworkMetrics(){return await this.transport.request({method:"suix_getNetworkMetrics",params:[]})}async getAddressMetrics(){return await this.transport.request({method:"suix_getLatestAddressMetrics",params:[]})}async getEpochMetrics(e){return await this.transport.request({method:"suix_getEpochMetrics",params:[null==e?void 0:e.cursor,null==e?void 0:e.limit,null==e?void 0:e.descendingOrder]})}async getAllEpochAddressMetrics(e){return await this.transport.request({method:"suix_getAllEpochAddressMetrics",params:[null==e?void 0:e.descendingOrder]})}async getEpochs(e){return await this.transport.request({method:"suix_getEpochs",params:[null==e?void 0:e.cursor,null==e?void 0:e.limit,null==e?void 0:e.descendingOrder]})}async getMoveCallMetrics(){return await this.transport.request({method:"suix_getMoveCallMetrics",params:[]})}async getCurrentEpoch(){return await this.transport.request({method:"suix_getCurrentEpoch",params:[]})}async getValidatorsApy(){return await this.transport.request({method:"suix_getValidatorsApy",params:[]})}async getChainIdentifier(){const e=await this.getCheckpoint({id:"0"});return b(f(e.digest).slice(0,4))}async resolveNameServiceAddress(e){return await this.transport.request({method:"suix_resolveNameServiceAddress",params:[e.name]})}async resolveNameServiceNames(e){return await this.transport.request({method:"suix_resolveNameServiceNames",params:[e.address,e.cursor,e.limit]})}async getProtocolConfig(e){return await this.transport.request({method:"sui_getProtocolConfig",params:[null==e?void 0:e.version]})}async waitForTransactionBlock(e){let{signal:t,timeout:r=6e4,pollInterval:n=2e3,...i}=e;const s=AbortSignal.timeout(r),a=new Promise(((e,t)=>{s.addEventListener("abort",(()=>t(s.reason)))}));for(a.catch((()=>{}));!s.aborted;){null==t||t.throwIfAborted();try{return await this.getTransactionBlock(i)}catch{await Promise.race([new Promise((e=>setTimeout(e,n))),a])}}throw s.throwIfAborted(),new Error("Unexpected error while waiting for transaction block.")}}class Pn extends i.C{}const Mn="Sui",$n=e=>{var t;const r=null==(t=e.data)?void 0:t.content;return r&&"moveObject"===r.dataType?r.fields:null},Un=(e,t)=>{try{return Xn(e)===Xn(t)}catch{return!1}},zn=e=>"created"===(null==e?void 0:e.type),_n=e=>"published"===(null==e?void 0:e.type);function Nn(e){return!Array.isArray(e)&&"object"==typeof e&&"fields"in e&&"type"in e}function Rn(e){return"object"==typeof e&&!function(e){return Array.isArray(e)}(e)&&!Nn(e)}const Vn=e=>Dt.ser("vector<u8>",e,{maxSize:16384}).toBytes(),Dn=async(e,t)=>{const{data:r,error:n}=await e.getObject({id:t,options:{showContent:!0}});if(n)throw new Error("Error getting object: "+n);if(!r||!Nn(r.content))throw new Error(`Cannot get oject for state id ${t}: `+r);return Yn(r.content.type)},qn=async(e,t)=>{if(!F(t))throw new Error(`Invalid object ID: ${t}`);const r=await e.getObject({id:t,options:{showContent:!0}});return $n(r)};async function Wn(e,t){let r,n;do{const i=await e.getDynamicFields({parentId:t,cursor:n});r=i.data.find((e=>e.name.type.endsWith("CurrentPackage"))),n=i.hasNextPage?i.nextCursor:null}while(n&&!r);if(!r)throw new Error("CurrentPackage not found");const i=await e.getObject({id:r.objectId,options:{showContent:!0}}),s=$n(i);if(!s||!Rn(s))throw new Error("Unable to get fields from object response");if(!("value"in s)||!Nn(s.value))throw new Error("Unable to get package id");return s.value.fields.package}const Kn=async(e,t,r)=>{let n,i=null,s=null,a=null;do{if(a=await e.getOwnedObjects({owner:r,filter:{StructType:`${t}::emitter::EmitterCap`},options:{showContent:!0},cursor:n}),!a||!a.data)throw Error("Failed to get owned objects");for(const e of a.data){if(!e.data)continue;const{version:t,objectId:r}=e.data;(null===i||t<i)&&(i=t,s=r)}n=a.hasNextPage?a.nextCursor:void 0}while(n);return s},Ln=async(e,t)=>{const r=new An,[i]=r.publish({modules:e.modules.map((e=>Array.from(n.b2.decode(e)))),dependencies:e.dependencies.map((e=>Z(e)))});return r.transferObjects([i],r.pure(t)),r},Fn=class e extends i.P{constructor(t,r){super(t,r??(0,n.au)(t,e._platform))}getRpc(e){if(e in this.config)return new Cn({url:this.config[e].rpc});throw new Error("No configuration available for chain: "+e)}getChain(e){if(e in this.config)return new Pn(e,this);throw new Error("No configuration available for chain: "+e)}static nativeTokenId(t,r){if(!e.isSupportedChain(r))throw new Error(`invalid chain for ${Mn}: ${r}`);return n.av.tokenId(r,"0x2::sui::SUI")}static isNativeTokenId(t,r,n){return!(!e.isSupportedChain(r)||n.chain!==r)&&this.nativeTokenId(t,r)===n}static isSupportedChain(t){return(0,n.aw)(t)===e._platform}static async getDecimals(t,r,i){if((0,n.ax)(i))return(0,n.ay)(e._platform);const s=new ri(i);try{const e=await qn(r,s.toString());if(e&&"decimals"in e)return e.decimals}catch{}const a=await r.getCoinMetadata({coinType:s.getCoinType()});if(null===a)throw new Error(`Can't fetch decimals for token ${s.toString()}`);return a.decimals}static async getBalance(e,t,r,i){if((0,n.ax)(i)){const{totalBalance:e}=await t.getBalance({owner:r});return BigInt(e)}const{totalBalance:s}=await t.getBalance({owner:r,coinType:i.toString()});return BigInt(s)}static async getBalances(e,t,r,i){return(await Promise.all(i.map((async i=>{const s=await this.getBalance(e,t,r,i);return{[(0,n.ax)(i)?"native":new ri(i).toString()]:s}})))).reduce(((e,t)=>Object.assign(e,t)),{})}static async sendWait(e,t,r){const n=[];for(const i of r){const e=await t.executeTransactionBlock(i);await t.waitForTransactionBlock({digest:e.digest}),n.push(e.digest)}return n}static async getLatestBlock(e){return Number(await e.getLatestCheckpointSequenceNumber())}static async getLatestFinalizedBlock(e){return this.getLatestBlock(e)}static chainFromChainId(t){const r=(0,n.az)(e._platform,t);if(void 0===r)throw new Error(`Unknown native chain id ${t}`);const[i,s]=r;return[i,s]}static async chainFromRpc(e){const t=await e.call("sui_getChainIdentifier",[]);return this.chainFromChainId(t)}};a(Fn,"_platform",Mn);let Gn=Fn;const Jn=e=>/^(0x)?[0-9a-fA-F]+::\w+::\w+$/.test(e),Zn=e=>e.replace(/(0x)(0*)/g,"0x");function Hn(e){return`0x${64===(e=(e=e.startsWith("0x")?e.slice(2):e).length%2===0?e:"0"+e).length?e:n.ar.encode(n.b3.zpad(n.ar.decode(e),32))}`}const Xn=e=>{const t=e.split(je);if(3!==t.length)throw new Error(`Invalid Sui type: ${e}`);return[J(t[0]),t[1],t[2]].join(je)},Qn=e=>new ri(e).getCoinType(),Yn=e=>new ri(e).getPackageId(),ei=e=>{const t=Zn(e).match(/0x2::table::Table<(.*)>/);if(!t)throw new Error(`Invalid table type: ${e}`);if(t.length<2)throw new Error(`Invalid table type: ${e}`);const[r]=t[1].split(",");if(!r||!Jn(r))throw new Error(`Invalid key type: ${r}`);return r},ti=class e{constructor(t){if(a(this,"address"),a(this,"module"),e.instanceof(t))this.address=t.address,this.module=t.module;else if(n.as.instanceof(t))this.address=t.toUint8Array();else if("string"==typeof t){if(Jn(t)){const e=t.split(je);this.module=e.slice(1).join(je),t=e[0]}if(t=Hn(t),!n.ar.valid(t))throw new Error("Invalid Sui address: "+t);this.address=n.ar.decode(t)}else this.address=t}unwrap(){return`${this.getPackageId()}${this.module?je+this.module:""}`}toString(){return this.unwrap()}toNative(){return this}toUint8Array(){return this.address}toUniversalAddress(){return new n.as(this.toUint8Array())}getPackageId(){return Hn(n.ar.encode(this.address))}getCoinType(){return[this.getPackageId(),"coin","COIN"].join(je)}static instanceof(t){return t.constructor.platform===e.platform}equals(t){return e.instanceof(t)?t.unwrap()===this.unwrap():this.toUniversalAddress().equals(t)}};a(ti,"byteSize",32),a(ti,"platform",Gn._platform);let ri=ti;(0,n.at)(Mn,ri);var ni=(e=>(e[e.TransactionData=0]="TransactionData",e[e.TransactionEffects=1]="TransactionEffects",e[e.CheckpointSummary=2]="CheckpointSummary",e[e.PersonalMessage=3]="PersonalMessage",e))(ni||{});function ii(e,t){const r=function(e){return[e,0,0]}(e),n=new Uint8Array(r.length+t.length);return n.set(r),n.set(t,r.length),n}const si={ED25519:0,Secp256k1:1,Secp256r1:2,MultiSig:3,ZkLogin:5},ai={ED25519:32,Secp256k1:33,Secp256r1:33},oi={0:"ED25519",1:"Secp256k1",2:"Secp256r1",3:"MultiSig",5:"ZkLogin"};function ci(e,t){const r=function(e,t){const r=e.toString(16);return(0,n.b4)(r.padStart(2*t,"0").slice(2*-t))}(e,t),i=function(e){for(let t=0;t<e.length;t++)if(0!==e[t])return t;return-1}(r);return-1===i?new Uint8Array([0]):r.slice(i)}function ui(e){if(1!==e.length)throw new Error("Invalid base64Url character: "+e);const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".indexOf(e);if(-1===t)throw new Error("Invalid base64Url character: "+e);const r=t.toString(2).padStart(6,"0");return Array.from(r).map(Number)}function li(e,t){if(e.length<2)throw new Error(`Input (s = ${e}) is not tightly packed because s.length < 2`);let r=function(e){let t=[];for(let r=0;r<e.length;r++){const n=ui(e.charAt(r));t=t.concat(n)}return t}(e);const n=t%4;if(0!==n)if(1===n)r=r.slice(2);else{if(2!==n)throw new Error(`Input (s = ${e}) is not tightly packed because i%4 = 3 (i = ${t}))`);r=r.slice(4)}const i=(t+e.length-1)%4;if(3!==i)if(2===i)r=r.slice(0,r.length-2);else{if(1!==i)throw new Error(`Input (s = ${e}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${t}))`);r=r.slice(0,r.length-4)}if(r.length%8!==0)throw new Error("We should never reach here...");const s=new Uint8Array(Math.floor(r.length/8));let a=0;for(let o=0;o<r.length;o+=8){const e=r.slice(o,o+8),t=parseInt(e.join(""),2);s[a++]=t}return(new TextDecoder).decode(s)}function di(e,t){const r=li(e.value,e.indexMod4),[n,i]=function(e){if("}"!==e.slice(-1)&&","!==e.slice(-1))throw new Error("Invalid claim");const t=JSON.parse("{"+e.slice(0,-1)+"}");if(1!==Object.keys(t).length)throw new Error("Invalid claim");const r=Object.keys(t)[0];return[r,t[r]]}(r);if(n!==t)throw new Error(`Invalid field name: found ${n} expected ${t}`);return i}const hi=D.struct("ZkLoginSignature",{inputs:D.struct("ZkLoginSignatureInputs",{proofPoints:D.struct("ZkLoginSignatureInputsProofPoints",{a:D.vector(D.string()),b:D.vector(D.vector(D.string())),c:D.vector(D.string())}),issBase64Details:D.struct("ZkLoginSignatureInputsClaim",{value:D.string(),indexMod4:D.u8()}),headerBase64:D.string(),addressSeed:D.string()}),maxEpoch:D.u64(),userSignature:D.vector(D.u8())});function pi(e){let{signature:t,signatureScheme:r,publicKey:n}=e;if(!n)throw new Error("`publicKey` is required");const i=n.toRawBytes(),s=new Uint8Array(1+t.length+i.length);return s.set([si[r]]),s.set(t,1),s.set(i,1+t.length),y(s)}function fi(e){const t=g(e),r=oi[t[0]];switch(r){case"MultiSig":return{serializedSignature:e,signatureScheme:r,multisig:Dt.MultiSig.parse(t.slice(1)),bytes:t};case"ZkLogin":const i=t.slice(1),{inputs:s,maxEpoch:a,userSignature:o}=function(e){return hi.parse("string"==typeof e?g(e):e)}(i),{issBase64Details:c,addressSeed:u}=s,l=di(c,"iss"),d=function(e,t){const r=ci(e,32);"accounts.google.com"===t&&(t="https://accounts.google.com");const i=(new TextEncoder).encode(t),s=new Uint8Array(2+r.length+i.length);return s.set([si.ZkLogin]),s.set([i.length],1),s.set(i,2),s.set(r,2+i.length),J((0,n.b5)((0,n.b1)(s,{dkLen:32})).slice(0,2*L))}(BigInt(u),l);return{serializedSignature:e,signatureScheme:r,zkLogin:{inputs:s,maxEpoch:a,userSignature:o,iss:l,address:d,addressSeed:BigInt(u)},signature:t};case"ED25519":case"Secp256k1":case"Secp256r1":const h=ai[r],p=t.slice(1,t.length-h);return{serializedSignature:e,signatureScheme:r,signature:p,publicKey:t.slice(1+p.length),bytes:t};default:throw new Error("Unsupported signature scheme")}}class gi{async signWithIntent(e,t){const r=ii(t,e),i=(0,n.b1)(r,{dkLen:32});return{signature:pi({signature:await this.sign(i),signatureScheme:this.getKeyScheme(),publicKey:this.getPublicKey()}),bytes:y(e)}}async signTransactionBlock(e){return this.signWithIntent(e,ni.TransactionData)}async signPersonalMessage(e){return this.signWithIntent(D.vector(D.u8()).serialize(e).toBytes(),ni.PersonalMessage)}toSuiAddress(){return this.getPublicKey().toSuiAddress()}}class mi extends gi{export(){return{schema:this.getKeyScheme(),privateKey:this.getSecretKey()}}}function yi(e){return!!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(e)}function wi(e){return b(function(e){return u(e,"")}(e))}const bi=new RegExp("^m(\\/[0-9]+')+$"),vi=e=>e.replace("'",""),Si=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2147483648;if(!(e=>!!bi.test(e)&&!e.split("/").slice(1).map(vi).some(isNaN))(e))throw new Error("Invalid derivation path");const{key:i,chainCode:s}=(e=>{const t=n.b7.create(n.b0,"ed25519 seed").update(w(e)).digest();return{key:t.slice(0,32),chainCode:t.slice(32)}})(t);return e.split("/").slice(1).map(vi).map((e=>parseInt(e,10))).reduce(((e,t)=>((e,t)=>{let{key:r,chainCode:i}=e;const s=new ArrayBuffer(4);new DataView(s).setUint32(0,t);const a=new Uint8Array(1+r.length+s.byteLength);a.set(new Uint8Array(1).fill(0)),a.set(r,1),a.set(new Uint8Array(s,0,s.byteLength),r.length+1);const o=n.b7.create(n.b0,i).update(a).digest();return{key:o.slice(0,32),chainCode:o.slice(32)}})(e,t+r)),{key:i,chainCode:s})};function ki(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}class Ti{equals(e){return ki(this.toRawBytes(),e.toRawBytes())}toBase64(){return y(this.toRawBytes())}toString(){throw new Error("`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.")}toSuiPublicKey(){return y(this.toSuiBytes())}verifyWithIntent(e,t,r){const i=ii(r,e),s=(0,n.b1)(i,{dkLen:32});return this.verify(s,t)}verifyPersonalMessage(e,t){return this.verifyWithIntent(Dt.vector(Dt.u8()).serialize(e).toBytes(),t,ni.PersonalMessage)}verifyTransactionBlock(e,t){return this.verifyWithIntent(e,t,ni.TransactionData)}toSuiBytes(){const e=this.toRawBytes(),t=new Uint8Array(e.length+1);return t.set([this.flag()]),t.set(e,1),t}toSuiAddress(){return J((0,n.b5)((0,n.b1)(this.toSuiBytes(),{dkLen:32})).slice(0,2*L))}}class Ei extends Ti{constructor(e){if(super(),"string"==typeof e?this.data=g(e):e instanceof Uint8Array?this.data=e:this.data=Uint8Array.from(e),32!==this.data.length)throw new Error(`Invalid public key input. Expected 32 bytes, got ${this.data.length}`)}equals(e){return super.equals(e)}toRawBytes(){return this.data}flag(){return si.ED25519}async verify(e,t){let r;if("string"==typeof t){const e=fi(t);if("ED25519"!==e.signatureScheme)throw new Error("Invalid signature scheme");if(!ki(this.toRawBytes(),e.publicKey))throw new Error("Signature does not match public key");r=e.signature}else r=t;return n.b8.sign.detached.verify(e,r,this.toRawBytes())}}Ei.SIZE=32;const xi="m/44'/784'/0'/0'/0'";class ji extends mi{constructor(e){super(),this.keypair=e||n.b8.sign.keyPair()}getKeyScheme(){return"ED25519"}static generate(){return new ji(n.b8.sign.keyPair())}static fromSecretKey(e,t){const r=e.length;if(32!==r)throw new Error(`Wrong secretKey size. Expected 32 bytes, got ${r}.`);const i=n.b8.sign.keyPair.fromSeed(e);if(!t||!t.skipValidation){const e=(new TextEncoder).encode("sui validation"),t=n.b8.sign.detached(e,i.secretKey);if(!n.b8.sign.detached.verify(e,t,i.publicKey))throw new Error("provided secretKey is invalid")}return new ji(i)}getPublicKey(){return new Ei(this.keypair.publicKey)}getSecretKey(){return function(e,t){if(32!==e.length)throw new Error("Invalid bytes length");const r=si[t],i=new Uint8Array(e.length+1);return i.set([r]),i.set(e,1),n.b6.encode("suiprivkey",n.b6.toWords(i))}(this.keypair.secretKey.slice(0,32),this.getKeyScheme())}async sign(e){return this.signData(e)}signData(e){return n.b8.sign.detached(e,this.keypair.secretKey)}static deriveKeypair(e,t){if(null==t&&(t=xi),!yi(t))throw new Error("Invalid derivation path");const{key:r}=Si(t,wi(e));return ji.fromSecretKey(r)}static deriveKeypairFromSeed(e,t){if(null==t&&(t=xi),!yi(t))throw new Error("Invalid derivation path");const{key:r}=Si(t,e);return ji.fromSecretKey(r)}}class Ii{constructor(e,t,r,n){a(this,"_chain"),a(this,"_client"),a(this,"_signer"),a(this,"_debug"),this._chain=e,this._client=t,this._signer=r,this._debug=n}chain(){return this._chain}address(){return this._signer.toSuiAddress()}async signAndSend(e){const t=[];for(const r of e){const{description:e,transaction:n}=r;this._debug&&console.log(`Signing ${e} for ${this.address()}`);const i=await this._client.signAndExecuteTransactionBlock({transactionBlock:n,signer:this._signer});t.push(i.digest)}return t}}const Bi={Address:ri,Platform:Gn,getSigner:async function(e,t){const[,r]=await Gn.chainFromRpc(e);return new Ii(r,e,ji.deriveKeypair(t,"m/44'/784'/0'/0'/0'"))},protocols:{WormholeCore:()=>r.e(8736).then(r.bind(r,8736)),TokenBridge:()=>r.e(6446).then(r.bind(r,6446))},getChain:(e,t,r)=>new Pn(t,new Gn(e,(0,n.aC)(e,Mn,{[t]:r})))},Ai=Object.freeze(Object.defineProperty({__proto__:null,default:Bi},Symbol.toStringTag,{value:"Module"}))}}]);
//# sourceMappingURL=4051.8f1ddfe2.chunk.js.map