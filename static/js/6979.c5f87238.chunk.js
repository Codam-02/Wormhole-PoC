"use strict";(self.webpackChunkmultichain_poc=self.webpackChunkmultichain_poc||[]).push([[6979,4548],{9312:(t,e,r)=>{r.d(e,{c:()=>c});var n=r(7126);function a(t,e){switch(t.binary){case"bytes":if("layout"in t){const{custom:r}=t;return void 0===r||"function"!=typeof r.from?s(t.layout,r?r.from:e):e}case"int":case"uint":{const{custom:r}=t;return null!=t&&t.omit?void 0:(0,n.cX)(r)?r:(0,n.cY)(r)?r.to:e}case"array":return Array.isArray(e)?e.map((e=>s(t.layout,e))):void 0;case"switch":{const r=e[t.idTag??"id"],[n,a]=t.layouts.find((t=>{let[e]=t;return(Array.isArray(e)?e[1]:e)==r}));return{[t.idTag??"id"]:r,...s(a,e)}}}}function s(t,e){if(e=e??{},(0,n.cW)(t))return a(t,e);const r={};for(const n of t){const t=a(n,e[n.name]??{});void 0!==t&&(r[n.name]=t)}return r}function o(t,e){return s(t,e)}function i(t){return[...n.c_,(0,n.c$)(t)]}function c(t,e){const[r,a]=(0,n.cZ)(t),s=o(i(t),e);return{protocolName:r,payloadName:a,payloadLiteral:t,...o(n.d0,e),...s,hash:(0,n.cF)((0,n.cT)(i(t),s))}}},4548:(t,e,r)=>{r.r(e),r.d(e,{CosmwasmWormholeCore:()=>d});var n=r(8532),a=r(9312),s=r(7126),o=r(6310),i=Object.defineProperty,c=(t,e,r)=>(((t,e,r)=>{e in t?i(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r})(t,"symbol"!=typeof e?e+"":e,r),r);class d{constructor(t,e,r,n){c(this,"network"),c(this,"chain"),c(this,"rpc"),c(this,"contracts"),c(this,"coreAddress"),this.network=t,this.chain=e,this.rpc=r,this.contracts=n;const a=this.contracts.coreBridge;if(!a)throw new Error(`Wormhole Token Bridge contract for domain ${e} not found`);this.coreAddress=a}getGuardianSet(t){throw new Error("Method not implemented.")}getGuardianSetIndex(){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(t,e){const[r,a]=await n.C.chainFromRpc(t),s=e[a];if(s.network!==r)throw new Error(`Network mismatch: ${s.network} != ${r}`);return new d(r,a,t,s.contracts)}async*publishMessage(t,e,r,n){throw new Error("Method not implemented.")}async*verifyMessage(t,e){throw new Error("Not implemented.")}async parseTransaction(t){const e=await this.rpc.getTx(t);if(!e)throw new Error("No transaction found for txid: "+t);return[d.parseWormholeMessageId(this.chain,this.coreAddress,e)]}async parseMessages(t){const e=await this.rpc.getTx(t);if(!e)throw new Error("No transaction found for txid: "+t);return[d.parseWormholeMessage(this.chain,this.coreAddress,e)]}static parseWormholeMessage(t,e,r){const n=r.events.filter((t=>"wasm"===t.type&&"_contract_address"===t.attributes[0].key&&t.attributes[0].value===e));if(0===n.length)throw new Error("No wormhole message found in tx");n.length>1&&console.error(`Expected single message, found ${n.length}`);const[o]=n,i=Object.fromEntries(o.attributes.map((t=>[t.key.split(".")[1],t.value])));return(0,a.c)("Uint8Array",{emitterChain:t,emitterAddress:new s.as(s.ar.decode(i.sender)),sequence:BigInt(i.sequence),guardianSet:0,timestamp:Number(i.block_time),consistencyLevel:0,nonce:Number(i.nonce),signatures:[],payload:s.ar.decode(i.message)})}static parseWormholeMessageId(t,e,r){const n=d.parseWormholeMessage(t,e,r);return{chain:n.emitterChain,emitter:n.emitterAddress,sequence:n.sequence}}}(0,o.r)(n._,"WormholeCore",d)},6979:(t,e,r)=>{r.r(e),r.d(e,{CosmwasmTokenBridge:()=>d});r(4548);var n=r(8532),a=r(3908),s=r(7126),o=r(6310),i=Object.defineProperty,c=(t,e,r)=>(((t,e,r)=>{e in t?i(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r})(t,"symbol"!=typeof e?e+"":e,r),r);class d{constructor(t,e,r,n){c(this,"network"),c(this,"chain"),c(this,"rpc"),c(this,"contracts"),c(this,"tokenBridge"),c(this,"translator"),this.network=t,this.chain=e,this.rpc=r,this.contracts=n;const a=this.contracts.tokenBridge;if(!a)throw new Error(`Wormhole Token Bridge contract for domain ${e} not found`);if(this.tokenBridge=a,this.translator=this.contracts.translator,void 0!==this.translator&&""===this.translator)throw new Error("Translator address may be undefined but not empty string")}static async fromRpc(t,e){const[r,a]=await n.C.chainFromRpc(t),s=e[a];if(s.network!==r)throw new Error(`Network mismatch: ${s.network} != ${r}`);return new d(r,a,t,e[a].contracts)}async isWrappedAsset(t){try{return await this.getOriginalAsset(t),!0}catch{}return!1}async hasWrappedAsset(t){try{return await this.getWrappedAsset(t),!0}catch{}return!1}async getWrappedAsset(t){if(t.chain===this.chain)throw new Error(`Expected foreign chain, got ${t.chain}`);if((0,s.ax)(t.address))throw new Error("Native asset cannot be a wrapped asset");const e=s.b2.encode(t.address.toUniversalAddress().toUint8Array()),{address:r}=await this.rpc.queryContractSmart(this.tokenBridge,{wrapped_registry:{chain:(0,s.bW)(t.chain),address:e}});return(0,s.cj)(this.chain,r)}async getOriginalAsset(t){let e=new n.a(t);"factory"===e.denomType&&(e=n.G.factoryToCw20(e));const r=await this.rpc.queryContractSmart(e.toString(),{wrapped_asset_info:{}}),a=(0,s.cE)(r.asset_chain),o=s.b2.decode(r.asset_address);return{chain:a,address:new s.as(new Uint8Array(o))}}async isTransferCompleted(t){const e=s.b2.encode((0,s.cw)(t));return(await this.rpc.queryContractSmart(this.tokenBridge,{is_vaa_redeemed:{vaa:e}})).is_redeemed}async*createAttestation(t,e){if(!e)throw new Error("Payer required to create attestation");const r=new n.a(t).toString(),o=new n.a(e).toString(),i=(0,s.ax)(t)?{native_token:{denom:n.C.getNativeDenom(this.network,this.chain)}}:{token:{contract_addr:r}};yield this.createUnsignedTx({msgs:[(0,a.b)(o,this.tokenBridge,{create_asset_meta:{asset_info:i,nonce:0}})],fee:(0,a.c)(this.network,this.chain),memo:"Wormhole - Create Attestation"},"TokenBridge.createAttestation")}async*submitAttestation(t,e){if(!e)throw new Error("Payer required to submit attestation");const r=new n.a(e).toString();yield this.createUnsignedTx({msgs:[(0,a.b)(r,this.tokenBridge,{submit_vaa:{data:(0,s.cw)(t)}})],fee:(0,a.c)(this.network,this.chain),memo:"Wormhole - Submit Attestation"},"TokenBridge.submitAttestation")}async*transfer(t,e,r,o,i){const c=Math.round(1e5*Math.random()),d=(0,s.bW)(e.chain),h=s.b2.encode(e.address.toUniversalAddress().toUint8Array()),m=n.C.getNativeDenom(this.network,this.chain),l=(0,s.ax)(r);let u=l?m:r.toString();u.startsWith("factory")&&(u=n.G.factoryToCw20(new n.a(u)).toString());const w=new n.a(t).toString(),g=t=>{const e={asset:{amount:o.toString(),info:t},recipient_chain:d,recipient:h,fee:"0",nonce:c};return i?{initiate_transfer_with_payload:{...e,payload:s.b2.encode(i)}}:{initiate_transfer:e}};if(l){const t=[(0,a.b)(w,this.tokenBridge,{deposit_tokens:{}},[{amount:o.toString(),denom:u}]),(0,a.b)(w,this.tokenBridge,g({native_token:{denom:u}}))];yield this.createUnsignedTx({msgs:t,fee:(0,a.c)(this.network,this.chain),memo:"Wormhole - Initiate Native Transfer"},"TokenBridge.transferNative")}else{const t=[(0,a.b)(w,u,{increase_allowance:{spender:this.tokenBridge,amount:o.toString(),expires:{never:{}}}}),(0,a.b)(w,this.tokenBridge,g({token:{contract_addr:u}}),[{amount:o.toString(),denom:u}])];yield this.createUnsignedTx({msgs:t,fee:(0,a.c)(this.network,this.chain),memo:"Wormhole - Initiate Transfer"},"TokenBridge.transfer")}}redeem(t,e){try{var r=this;return async function*(){const o=s.b2.encode((0,s.cw)(e)),i=new n.a(t).toString(),c=r.translator&&new n.a(r.translator).toUniversalAddress().equals(e.payload.to.address)?(0,a.b)(i,r.translator,{complete_transfer_and_convert:{vaa:o}}):(0,a.b)(i,r.tokenBridge,{submit_vaa:{data:o}});yield r.createUnsignedTx({msgs:[c],fee:(0,a.c)(r.network,r.chain),memo:"Wormhole - Complete Transfer"},"TokenBridge.redeem")}()}catch(e){return Promise.reject(e)}}async parseTransactionDetails(t){throw new Error("Not implemented")}async getWrappedNative(){return(0,s.cj)(this.chain,n.C.getNativeDenom(this.network,this.chain))}createUnsignedTx(t,e){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new a.C(t,this.network,this.chain,e,r)}}(0,o.r)(n._,"TokenBridge",d)},3908:(t,e,r)=>{r.d(e,{C:()=>d,b:()=>c,c:()=>i});var n=r(8532),a=r(7126),s=Object.defineProperty,o=(t,e,r)=>(((t,e,r)=>{e in t?s(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r})(t,"symbol"!=typeof e?e+"":e,r),r);function i(t,e){let r=n.l.get(t,e);return r||(r="0.1"),n.m.calculateFee(1.5*n.D,`${r}${n.C.getNativeDenom(t,e)}`)}function c(t,e,r,s){return{typeUrl:n.M,value:a.bT.MsgExecuteContract.fromPartial({sender:t,contract:e,msg:a.b3.encode(JSON.stringify(r)),funds:s})}}class d{constructor(t,e,r,n){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];o(this,"transaction"),o(this,"network"),o(this,"chain"),o(this,"description"),o(this,"parallelizable"),this.transaction=t,this.network=e,this.chain=r,this.description=n,this.parallelizable=a}}}}]);
//# sourceMappingURL=6979.c5f87238.chunk.js.map