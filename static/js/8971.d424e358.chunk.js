"use strict";(self.webpackChunkmultichain_poc=self.webpackChunkmultichain_poc||[]).push([[8971,196],{9312:(e,t,n)=>{n.d(t,{c:()=>d});var s=n(7126);function o(e,t){switch(e.binary){case"bytes":if("layout"in e){const{custom:n}=e;return void 0===n||"function"!=typeof n.from?r(e.layout,n?n.from:t):t}case"int":case"uint":{const{custom:n}=e;return null!=e&&e.omit?void 0:(0,s.cX)(n)?n:(0,s.cY)(n)?n.to:t}case"array":return Array.isArray(t)?t.map((t=>r(e.layout,t))):void 0;case"switch":{const n=t[e.idTag??"id"],[s,o]=e.layouts.find((e=>{let[t]=e;return(Array.isArray(t)?t[1]:t)==n}));return{[e.idTag??"id"]:n,...r(o,t)}}}}function r(e,t){if(t=t??{},(0,s.cW)(e))return o(e,t);const n={};for(const s of e){const e=o(s,t[s.name]??{});void 0!==e&&(n[s.name]=e)}return n}function a(e,t){return r(e,t)}function i(e){return[...s.c_,(0,s.c$)(e)]}function d(e,t){const[n,o]=(0,s.cZ)(e),r=a(i(e),t);return{protocolName:n,payloadName:o,payloadLiteral:e,...a(s.d0,t),...r,hash:(0,s.cF)((0,s.cT)(i(e),r))}}},8971:(e,t,n)=>{n.r(t),n.d(t,{AlgorandTokenBridge:()=>g,TransferMethodSelector:()=>c});var s=n(196),o=n(7126),r=n(2763),a=n(6310),i=Object.defineProperty,d=(e,t,n)=>(((e,t,n)=>{t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n})(e,"symbol"!=typeof t?t+"":t,n),n);const c=o.dc.fromSignature("portal_transfer(byte[])byte[]"),p=class e{constructor(e,t,n,r){if(d(this,"network"),d(this,"chain"),d(this,"connection"),d(this,"contracts"),d(this,"chainId"),d(this,"coreBridge"),d(this,"coreAppId"),d(this,"coreAppAddress"),d(this,"tokenBridgeAppId"),d(this,"tokenBridgeAddress"),this.network=e,this.chain=t,this.connection=n,this.contracts=r,this.chainId=(0,o.bW)(t),!r.coreBridge)throw new Error(`Core contract address for chain ${t} not found`);const a=BigInt(r.coreBridge);if(this.coreAppId=a,this.coreAppAddress=(0,o.d1)(a),this.coreBridge=new s.A(e,t,n,r),!r.tokenBridge)throw new Error(`TokenBridge contract address for chain ${t} not found`);const i=BigInt(r.tokenBridge);this.tokenBridgeAppId=i,this.tokenBridgeAddress=(0,o.d1)(i)}static async fromRpc(t,n){const[s,o]=await r.a.chainFromRpc(t),a=n[o];if(a.network!==s)throw new Error(`Network mismatch: ${a.network} != ${s}`);return new e(s,o,t,a.contracts)}async isWrappedAsset(e){const t=new r.A(e).toInt();if(0===t)return!1;const n=await this.connection.getAssetByID(t).do(),s=o.dd.from_obj_for_encoding(n).params.creator,a=await this.connection.accountInformation(s).exclude("all").do(),i=o.d4.from_obj_for_encoding(a);return(null==i?void 0:i.authAddr)===this.tokenBridgeAddress}async getOriginalAsset(e){const t=new r.A(e).toInt(),n=await this.connection.getAssetByID(t).do(),a=o.dd.from_obj_for_encoding(n),i=await s.S.decodeLocalState(this.connection,this.tokenBridgeAppId,a.params.creator);if(i.length<94)throw new Error("Invalid local state data");const d=i.slice(92,94);return{chain:(0,o.cE)(o.aA.decode(d)),address:new o.as(i.slice(60,92))}}async getWrappedAsset(e){const t=s.S.forWrappedAsset(this.tokenBridgeAppId,e),n=await s.S.decodeLocalState(this.connection,this.tokenBridgeAppId,t.address());if(n.length<8)throw new Error("Invalid wrapped asset data");return(0,o.cj)(this.chain,o.aA.decode(n.slice(0,8)).toString())}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedNative(){return(0,o.cj)(this.chain,"0")}async isTransferCompleted(e){const t=s.S.forMessageId(this.tokenBridgeAppId,{sequence:e.sequence,chain:e.emitterChain,emitter:e.emitterAddress});try{return await s.S.checkBitsSet(this.connection,this.tokenBridgeAppId,t.address(),e.sequence)}catch{}return!1}async*createAttestation(t,n){if(!n)throw new Error("Payer required to create attestation");const a=new r.A(n).toString(),i=new r.A(t).toInt(),d=[],c=await this.connection.getTransactionParams().do(),p=s.S.forEmitter(this.coreAppId,new r.A(this.tokenBridgeAddress).toUint8Array()),{accounts:[g],txs:h}=await s.A.maybeCreateStorageTx(this.connection,a,this.coreAppId,p,c);d.push(...h);let u,f="";if(0!==i){const e=await this.connection.getAssetByID(i).do(),t=o.dd.from_obj_for_encoding(e),n=await this.connection.accountInformation(t.params.creator).do();if(u=o.d4.from_obj_for_encoding(n),u.authAddr===this.tokenBridgeAddress.toString())throw new Error("Cannot re-attest wormhole assets")}const A=s.S.forNativeAsset(this.tokenBridgeAppId,BigInt(i)),l=await s.A.maybeCreateStorageTx(this.connection,a,this.tokenBridgeAppId,A);f=l.accounts[0],d.push(...l.txs);const m=(0,o.d5)({from:a,appIndex:(0,r.s)(this.tokenBridgeAppId),onComplete:o.d6.NoOpOC,appArgs:[e.noop],suggestedParams:c});d.push({tx:m});const y=await this.coreBridge.getMessageFee();if(y>BigInt(0)){const e=(0,o.d9)({from:a,suggestedParams:c,to:this.tokenBridgeAddress,amount:y});d.push({tx:e})}let I=[g,f,this.coreAppAddress];u&&I.push(u.address);let w=(0,o.d5)({appArgs:[e.attestToken,o.aA.toBytes(i,8)],accounts:I,appIndex:(0,r.s)(this.tokenBridgeAppId),foreignApps:[(0,r.s)(this.coreAppId)],foreignAssets:[i],from:a,onComplete:o.d6.NoOpOC,suggestedParams:c});y>BigInt(0)?w.fee*=3:w.fee*=2,d.push({tx:w});for(const e of d)yield this.createUnsignedTx(e,"TokenBridge.createAttestation",!0)}async*submitAttestation(t,n,a){if(!n)throw new Error("Sender required to submit attestation");a||(a=await this.connection.getTransactionParams().do());const i=n.toString(),d=s.S.forWrappedAsset(this.tokenBridgeAppId,t.payload.token).address(),c=[],p=[],g=await s.S.decodeLocalState(this.connection,this.tokenBridgeAppId,d);g.length>8&&p.push(new r.A(g.slice(0,8)).toInt()),c.push({tx:(0,o.d9)({from:i,to:d,amount:1e5,suggestedParams:a})});let h=new Uint8Array(1);h[0]=1,c.push({tx:(0,o.d5)({appArgs:[e.noop,h],appIndex:(0,r.s)(this.tokenBridgeAppId),from:i,onComplete:o.d6.NoOpOC,suggestedParams:a})}),h=new Uint8Array(1),h[0]=2,c.push({tx:(0,o.d5)({appArgs:[e.noop,h],appIndex:(0,r.s)(this.tokenBridgeAppId),from:i,onComplete:o.d6.NoOpOC,suggestedParams:a})}),c.push({tx:(0,o.d5)({accounts:[],appArgs:[e.receiveAttest,(0,o.cw)(t)],appIndex:(0,r.s)(this.tokenBridgeAppId),foreignAssets:p,from:i,onComplete:o.d6.NoOpOC,suggestedParams:a})}),c[c.length-1].tx.fee=2*c[c.length-1].tx.fee;for(const e of c)yield this.createUnsignedTx(e,"TokenBridge.submitAttestation",!0)}async*transfer(t,n,a,i,d){const c=t.toString(),p=(0,o.ax)(a)?0:new r.A(a).toInt(),g=i,h=(0,o.bW)(n.chain),u=n.address.toUniversalAddress().toUint8Array(),f=await this.connection.getTransactionParams().do(),A=BigInt(0),l=s.S.fromData({appId:this.coreAppId,appAddress:(0,o.cb)(this.coreAppAddress).publicKey,idx:BigInt(0),address:(0,o.cb)(this.tokenBridgeAddress).publicKey}),m=[],{accounts:[y],txs:I}=await s.A.maybeCreateStorageTx(this.connection,c,this.coreAppId,l,f);m.push(...I);let w,b="",x=!1;if(0!==p){const e=await this.connection.getAssetByID(p).do();b=o.dd.from_obj_for_encoding(e).params.creator;const t=await this.connection.accountInformation(b).do();w=o.d4.from_obj_for_encoding(t),x=w.authAddr===this.tokenBridgeAddress.toString()}const B=await this.coreBridge.getMessageFee();if(B>0&&m.push({tx:(0,o.d9)({from:c,to:this.tokenBridgeAddress,amount:B,suggestedParams:f})}),!x){const e=s.S.forNativeAsset(this.tokenBridgeAppId,BigInt(p)),{accounts:[t],txs:n}=await s.A.maybeCreateStorageTx(this.connection,c,this.tokenBridgeAppId,e,f);b=t,n.push(...n)}if(0!==p&&!await e.isOptedInToAsset(this.connection,b,p)){const t=(0,o.d9)({from:c,to:b,amount:1e5,suggestedParams:f});let n=(0,o.d5)({from:c,appIndex:(0,r.s)(this.tokenBridgeAppId),onComplete:o.d6.NoOpOC,appArgs:[e.optIn,(0,o.de)(p,8)],foreignAssets:[p],accounts:[b],suggestedParams:f});n.fee*=2,m.unshift({tx:t},{tx:n})}const k=(0,o.d5)({from:c,appIndex:(0,r.s)(this.tokenBridgeAppId),onComplete:o.d6.NoOpOC,appArgs:[e.noop],suggestedParams:f});m.push({tx:k});let _=[];if(0===p){const e=(0,o.d9)({from:c,to:b,amount:g,suggestedParams:f});m.push({tx:e}),_=[y,b,b]}else{const e=(0,o.df)({from:c,to:b,amount:g,assetIndex:p,suggestedParams:f});m.push({tx:e}),_=null!=w&&w.address?[y,b,w.address]:[y,b]}const S=[e.sendTransfer,o.aA.toBytes(p,8),o.aA.toBytes(g,8),u,o.aA.toBytes(h,8),o.aA.toBytes(A,8)];d&&S.push(d);const T=(0,o.d5)({from:c,appIndex:(0,r.s)(this.tokenBridgeAppId),onComplete:o.d6.NoOpOC,appArgs:S,foreignApps:[(0,r.s)(this.coreAppId)],foreignAssets:[p],accounts:_,suggestedParams:f});T.fee*=2,m.push({tx:T});for(const e of m)yield this.createUnsignedTx(e,"TokenBridge.transfer",!0)}redeem(t,n){try{var a=this;let i=arguments.length>3?arguments[3]:void 0;return async function*(){i||(i=await a.connection.getTransactionParams().do());const d=new r.A(t).toString(),{accounts:p,txs:g}=await s.A.submitVAAHeader(a.connection,a.coreAppId,a.tokenBridgeAppId,n,d);let h,u="",f=[],A=0;if(n.payload.token.chain!==a.chain){h=s.S.forWrappedAsset(a.tokenBridgeAppId,n.payload.token),u=h.address();const e=await s.S.decodeLocalState(a.connection,a.tokenBridgeAppId,u);A=new r.A(e.slice(0,8)).toInt()}else{const e=new r.A(n.payload.token.address).toBigInt();h=s.S.forNativeAsset(a.tokenBridgeAppId,e),u=h.address(),A=(0,r.s)(e)}p.push(u);let l=0,m="";if("TransferWithPayload"===n.payloadName?(l=new r.A(n.payload.to.address).toInt(),m=(0,o.d1)(l)):m=new r.A(n.payload.to.address.toUint8Array()).toString(),p.push(m),0!==A&&(f.push(A),!await e.isOptedInToAsset(a.connection,m,A))){if(d!=m)throw new Error("Cannot ASA optin for somebody else (asset "+A.toString()+")");g.unshift({tx:(0,o.df)({amount:0,assetIndex:A,from:d,suggestedParams:i,to:d})})}const y={accounts:p,appArgs:[e.completeTransfer,(0,o.cw)(n)],appIndex:(0,r.s)(a.tokenBridgeAppId),foreignAssets:f,from:d,onComplete:o.d6.NoOpOC,suggestedParams:i};g.push({tx:(0,o.d5)(y)}),g[g.length-1].tx.fee=g[g.length-1].tx.fee*("Transfer"===n.payloadName&&void 0!==n.payload.fee&&0n===n.payload.fee?2:3),"TransferWithPayload"===n.payloadName&&(g[g.length-1].tx.appForeignApps=[l],g.push({tx:(0,o.d5)({appArgs:[c.getSelector(),c.args[0].type.encode((0,o.cw)(n))],appIndex:l,foreignAssets:f,from:d,onComplete:o.d6.NoOpOC,suggestedParams:i})}));for(const e of g)yield a.createUnsignedTx(e,"TokenBridge.redeem",!0)}()}catch(i){return Promise.reject(i)}}static async isOptedInToAsset(e,t,n){var s;try{const r=await e.accountAssetInformation(t,n).do();return((null==(s=o.dg.from_obj_for_encoding(r).assetHolding)?void 0:s.amount)??0)>0}catch{}return!1}createUnsignedTx(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return new s.a(e,this.network,this.chain,t,n)}};d(p,"sendTransfer",o.b3.encode("sendTransfer")),d(p,"attestToken",o.b3.encode("attestToken")),d(p,"noop",o.b3.encode("nop")),d(p,"optIn",o.b3.encode("optin")),d(p,"completeTransfer",o.b3.encode("completeTransfer")),d(p,"receiveAttest",o.b3.encode("receiveAttest"));let g=p;(0,a.r)(r._,"TokenBridge",g)},196:(e,t,n)=>{n.r(t),n.d(t,{A:()=>l,S:()=>f,a:()=>c,i:()=>m});var s=n(7126),o=n(2763),r=n(9312),a=n(6310),i=Object.defineProperty,d=(e,t,n)=>(((e,t,n)=>{t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n})(e,"symbol"!=typeof t?t+"":t,n),n);class c{constructor(e,t,n,s){let o=arguments.length>4&&void 0!==arguments[4]&&arguments[4];d(this,"transaction"),d(this,"network"),d(this,"chain"),d(this,"description"),d(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=n,this.description=s,this.parallelizable=o}}const p=1002e3,g=1016,h=15240,u={_limit:127,encodingLength:e=>{let t=0;for(;e>=128;t++)e>>=7;return t+1},encode:(e,t,n)=>{if("bigint"==typeof e&&(e=(0,o.s)(e)),e<0)throw new RangeError("value must be unsigned");const s=u.encodingLength(e);if(n=n||0,(t=t||new ArrayBuffer(s)).byteLength<n+s)throw new RangeError("the buffer is too small to encode the number at the offset");const r=new Uint8Array(t,n);let a=0;for(;u._limit<e;)r[a++]=e&u._limit|128,e>>=7;return r[a]=Number(e),r},decode:function(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,s=0,o=0;do{if(t=e[n+o],void 0===t)throw new RangeError("offset out of range");s+=(t&u._limit)<<7*o,o++}while(128<=t);return s}},f={forMessageId:(e,t)=>{const n=(0,s.cb)((0,s.d1)(e)).publicKey,o=t.emitter.toUniversalAddress().toUint8Array(),r=s.aA.toBytes(BigInt((0,s.bW)(t.chain)),2),a=s.b3.concat(r,o);return f.fromData({appId:e,appAddress:n,idx:t.sequence/BigInt(h),address:a})},forWrappedAsset:(e,t)=>{if((0,s.ax)(t.address))throw new Error("native asset cannot be a wrapped asset");const n=(0,s.cb)((0,s.d1)(e)).publicKey;return f.fromData({appId:e,appAddress:n,idx:BigInt((0,s.bW)(t.chain)),address:t.address.toUniversalAddress().toUint8Array()})},forNativeAsset:(e,t)=>{const n=(0,s.cb)((0,s.d1)(e)).publicKey;return f.fromData({appId:e,appAddress:n,idx:t,address:s.b3.encode("native")})},forGuardianSet:(e,t)=>{const n=(0,s.cb)((0,s.d1)(e)).publicKey;return f.fromData({appId:e,appAddress:n,idx:BigInt(t),address:s.b3.encode("guardian")})},forEmitter:(e,t)=>{const n=(0,s.cb)((0,s.d1)(e)).publicKey;return f.fromData({appId:e,appAddress:n,idx:0n,address:t})},_encode:e=>"bigint"==typeof e?[s.ar.encode(u.encode(e))]:[s.ar.encode(u.encode(e.length)),s.ar.encode(e)],fromData:e=>{const t=["0620010181",...f._encode(e.idx),"4880",...f._encode(e.address),"483110810612443119221244311881",...f._encode(e.appId),"1244312080",...f._encode(e.appAddress),"124431018100124431093203124431153203124422"],n=s.ar.decode(t.join(""));return new s.d2(n)},decodeLocalState:async(e,t,n)=>{let r;try{const a=await e.accountApplicationInformation(n,(0,o.s)(t)).do();r=s.d3.from_obj_for_encoding(a).appLocalState}catch{return new Uint8Array}const a=s.b2.encode("meta");let i=new Map;for(const o of r.keyValue){if(o.key===a)continue;const e=s.b2.decode(o.key)[0],t=s.b2.decode(o.value.bytes);i.set(e,t)}const d=[];for(let s=0;s<15;s++)i.has(s)&&d.push(i.get(s));return s.b3.concat(...d)},checkBitsSet:async(e,t,n,r)=>{let a,i=!1;const d=await e.accountInformation(n).do(),c=s.d4.from_obj_for_encoding(d).appsLocalState;if(c&&c.forEach((e=>{BigInt(e.id)===t&&(a=e.keyValue)})),0===(null==a?void 0:a.length))return i;const p=BigInt(h),u=BigInt(8),f=r/p*p,A=(0,o.s)(r-f),l=Math.floor(A/g),m=Math.floor((A-l*g)/8),y=s.b2.encode(s.aA.toBytes(l,1));return null==a||a.forEach((e=>{if(e.key!==y);else{const t=s.d.Buffer.from(e.value.bytes,"base64"),n=1<<(0,o.s)(r%u);i=0!=(t[m]&n)}})),i},storageAccountExists:async(e,t,n)=>{try{const s=await e.accountApplicationInformation(t,(0,o.s)(n)).do();return Object.keys(s).length>0}catch{}return!1}},A=class e{constructor(e,t,n,o){if(d(this,"network"),d(this,"chain"),d(this,"connection"),d(this,"contracts"),d(this,"chainId"),d(this,"coreAppId"),d(this,"coreAppAddress"),d(this,"tokenBridgeAppId"),d(this,"tokenBridgeAppAddress"),this.network=e,this.chain=t,this.connection=n,this.contracts=o,this.chainId=(0,s.bW)(t),!o.coreBridge)throw new Error(`Core contract address for chain ${t} not found`);const r=BigInt(o.coreBridge);if(this.coreAppId=r,this.coreAppAddress=(0,s.d1)(r),!o.tokenBridge)throw new Error(`TokenBridge contract address for chain ${t} not found`);const a=BigInt(o.tokenBridge);this.tokenBridgeAppId=a,this.tokenBridgeAppAddress=(0,s.d1)(a)}getGuardianSet(e){throw new Error("Method not implemented.")}async*verifyMessage(t,n,s){const r=new o.A(t).toString(),a=await e.submitVAAHeader(this.connection,this.coreAppId,s??this.coreAppId,n,r);for(const e of a.txs)yield this.createUnsignedTx(e,"Core.verifyMessage")}static async fromRpc(t,n){const[s,r]=await o.a.chainFromRpc(t),a=n[r];if(a.network!==s)throw new Error(`Network mismatch: ${a.network} !== ${s}`);return new e(s,r,t,a.contracts)}async*publishMessage(t,n){const r=new o.A(t),a=r.toString(),i=await this.connection.getTransactionParams().do(),d=f.forEmitter(this.coreAppId,r.toUint8Array()),{accounts:c,txs:p}=await e.maybeCreateStorageTx(this.connection,a,this.coreAppId,d,i);for(const e of p)yield this.createUnsignedTx(e,"Core.publishMessage",!0);const g=(0,s.d5)({from:a,appIndex:(0,o.s)(this.coreAppId),appArgs:[e.publishMessage,n,s.aA.toBytes(0n,8)],accounts:c,onComplete:s.d6.NoOpOC,suggestedParams:i});yield this.createUnsignedTx({tx:g},"Core.publishMessage",!0)}async getMessageFee(){var t;const n=await this.connection.getApplicationByID((0,o.s)(this.coreAppId)).do(),r=null==(t=s.d7.from_obj_for_encoding(n).params.globalState)?void 0:t.find((t=>t.key===e.feeKey));return r?BigInt(r.value.uint):0n}async getGuardianSetIndex(){throw new Error("Not implemented")}async parseTransaction(e){const t=await this.connection.pendingTransactionInformation(e).do(),n=s.d8.from_obj_for_encoding(t);return this.parseTx(n).map((e=>({chain:e.emitterChain,emitter:e.emitterAddress,sequence:e.sequence})))}async parseMessages(e){const t=await this.connection.pendingTransactionInformation(e).do(),n=s.d8.from_obj_for_encoding(t);return this.parseTx(n)}parseTx(t){const n=[];if(t.innerTxns&&t.innerTxns.length>0&&n.push(...t.innerTxns.flatMap((e=>this.parseTx(e)))),BigInt(t.txn.txn.apid??0)!==this.coreAppId||!t.logs||0===t.logs.length)return n;const a=t.txn.txn.apaa??[];if(3!==a.length||!s.b3.equals(new Uint8Array(a[0]),e.publishMessage))return n;const i=s.aA.decode(t.logs[0]),d=new o.A(t.txn.txn.snd).toUniversalAddress(),c=new Uint8Array(a[1]),p=s.aA.decode(a[2]);return n.push((0,r.c)("Uint8Array",{emitterChain:this.chain,emitterAddress:d,sequence:i,guardianSet:0,timestamp:0,consistencyLevel:0,nonce:Number(p),payload:c,signatures:[]})),n}static async maybeCreateStorageTx(e,t,n,r,a){const i=(0,s.d1)(n),d=r.address(),c=[];if(await f.storageAccountExists(e,d,n))return{accounts:[d],txs:c};a=a??await e.getTransactionParams().do();const g=(0,s.d9)({from:t,to:d,amount:p,suggestedParams:a});g.fee=2*g.fee,c.push({tx:g});const h=(0,s.da)({from:d,appIndex:(0,o.s)(n),rekeyTo:i,suggestedParams:a});return h.fee=0,c.push({tx:h,signer:{address:r.address(),signTxn:e=>Promise.resolve((0,s.db)(e,r).blob)}}),{accounts:[d],txs:c}}static async submitVAAHeader(t,n,r,a,i,d){d=d??await t.getTransactionParams().do();let c=[];const p=f.forMessageId(r,{chain:a.emitterChain,sequence:a.sequence,emitter:a.emitterAddress}),{accounts:g,txs:h}=await e.maybeCreateStorageTx(t,i,r,p,d);c.push(...h);const u=f.forGuardianSet(n,a.guardianSet),{accounts:[A],txs:l}=await e.maybeCreateStorageTx(t,i,n,u,d);c.push(...l);let m=[...g,A];const y=await f.decodeLocalState(t,n,A),I=(0,s.cF)(a.hash),w=a.signatures.length,b=Math.ceil(w/e.MAX_SIGS_PER_TXN),x=new s.d2(e.ALGO_VERIFY);for(let f=0;f<b;f++){const t=f*e.MAX_SIGS_PER_TXN,r=a.signatures.slice(t,t+e.MAX_SIGS_PER_TXN),i=20*r.length,p=new Uint8Array(i);for(let e=0;e<r.length;e++){const t=r[e],n=y.slice(20*t.guardianIndex+1,20*(t.guardianIndex+1)+1);p.set(n,20*e)}const g=(0,s.d5)({appArgs:[e.verifySigs,s.b3.concat(...r.map((e=>s.b3.concat(new Uint8Array([e.guardianIndex]),e.signature.encode())))),p,I],accounts:m,appIndex:(0,o.s)(n),from:e.ALGO_VERIFY_HASH,onComplete:s.d6.NoOpOC,suggestedParams:d});g.fee=0,c.push({tx:g,signer:{address:x.address(),signTxn:e=>Promise.resolve((0,s.db)(e,x).blob)}})}const B=(0,s.d5)({appArgs:[e.verifyVaa,(0,s.cw)(a)],accounts:m,appIndex:(0,o.s)(n),from:i,onComplete:s.d6.NoOpOC,suggestedParams:d});return B.fee=B.fee*(2+b),c.push({tx:B}),{accounts:m,txs:c}}createUnsignedTx(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return new c(e,this.network,this.chain,t,n)}};d(A,"MAX_SIGS_PER_TXN",6),d(A,"ALGO_VERIFY_HASH","EZATROXX2HISIRZDRGXW4LRQ46Z6IUJYYIHU3PJGP7P5IQDPKVX42N767A"),d(A,"ALGO_VERIFY",new Uint8Array([6,32,4,1,0,32,20,38,1,0,49,32,50,3,18,68,49,1,35,18,68,49,16,129,6,18,68,54,26,1,54,26,3,54,26,2,136,0,3,68,34,67,53,2,53,1,53,0,40,53,240,40,53,241,52,0,21,53,5,35,53,3,35,53,4,52,3,52,5,12,65,0,68,52,1,52,0,52,3,129,65,8,34,88,23,52,0,52,3,34,8,36,88,52,0,52,3,129,33,8,36,88,7,0,53,241,53,240,52,2,52,4,37,88,52,240,52,241,80,2,87,12,20,18,68,52,3,129,66,8,53,3,52,4,37,8,53,4,66,255,180,34,137])),d(A,"feeKey",s.b2.encode("MessageFee")),d(A,"verifyVaa",s.b3.encode("verifyVAA")),d(A,"verifySigs",s.b3.encode("verifySigs")),d(A,"publishMessage",s.b3.encode("publishMessage"));let l=A;(0,a.r)("Algorand","WormholeCore",l);const m=Object.freeze(Object.defineProperty({__proto__:null,AlgorandWormholeCore:l,BITS_PER_BYTE:8,BITS_PER_KEY:g,MAX_BITS:h,MAX_BYTES:1905,MAX_BYTES_PER_KEY:127,MAX_KEYS:15,SEED_AMT:p,StorageLogicSig:f,varint:u},Symbol.toStringTag,{value:"Module"}))}}]);
//# sourceMappingURL=8971.d424e358.chunk.js.map