/*! For license information please see 590.343a6140.chunk.js.LICENSE.txt */
"use strict";(self.webpackChunkmultichain_poc=self.webpackChunkmultichain_poc||[]).push([[590],{590:(t,e,n)=>{n.r(e),n.d(e,{EvmPorticoBridge:()=>zr});var r=n(7126),s=n(3412),i=(n(436),n(418)),a=n(6310),o=Object.defineProperty,c=(t,e,n)=>(((t,e,n)=>{e in t?o(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n})(t,"symbol"!=typeof e?e+"":e,n),n),u=(t,e,n)=>{if(!e.has(t))throw TypeError("Cannot "+n)},l=(t,e,n)=>(u(t,e,"read from private field"),n?n.call(t):e.get(t)),h=(t,e,n)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,n)},f=(t,e,n,r)=>(u(t,e,"write to private field"),r?r.call(t,n):e.set(t,n),n),d=(t,e,n)=>(u(t,e,"access private method"),n);const p="6.12.1";function g(t,e,n){const r=e.split("|").map((t=>t.trim()));for(let i=0;i<r.length;i++)switch(e){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof t===e)return}const s=new Error(`invalid value for type ${e}`);throw s.code="INVALID_ARGUMENT",s.argument=`value.${n}`,s.value=t,s}async function m(t){const e=Object.keys(t);return(await Promise.all(e.map((e=>Promise.resolve(t[e]))))).reduce(((t,n,r)=>(t[e[r]]=n,t)),{})}function y(t,e,n){for(let r in e){let s=e[r];const i=n?n[r]:null;i&&g(s,i,r),Object.defineProperty(t,r,{enumerable:!0,value:s,writable:!1})}}function w(t){if(null==t)return"null";if(Array.isArray(t))return"[ "+t.map(w).join(", ")+" ]";if(t instanceof Uint8Array){const e="0123456789abcdef";let n="0x";for(let r=0;r<t.length;r++)n+=e[t[r]>>4],n+=e[15&t[r]];return n}if("object"==typeof t&&"function"==typeof t.toJSON)return w(t.toJSON());switch(typeof t){case"boolean":case"symbol":case"number":return t.toString();case"bigint":return BigInt(t).toString();case"string":return JSON.stringify(t);case"object":{const e=Object.keys(t);return e.sort(),"{ "+e.map((e=>`${w(e)}: ${w(t[e])}`)).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"}function b(t,e){return t&&t.code===e}function v(t){return b(t,"CALL_EXCEPTION")}function E(t,e,n){let r,s=t;{const r=[];if(n){if("message"in n||"code"in n||"name"in n)throw new Error(`value will overwrite populated values: ${w(n)}`);for(const t in n){if("shortMessage"===t)continue;const e=n[t];r.push(t+"="+w(e))}}r.push(`code=${e}`),r.push(`version=${p}`),r.length&&(t+=" ("+r.join(", ")+")")}switch(e){case"INVALID_ARGUMENT":r=new TypeError(t);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":r=new RangeError(t);break;default:r=new Error(t)}return y(r,{code:e}),n&&Object.assign(r,n),null==r.shortMessage&&y(r,{shortMessage:s}),r}function k(t,e,n,r){if(!t)throw E(e,n,r)}function N(t,e,n,r){k(t,e,"INVALID_ARGUMENT",{argument:n,value:r})}function O(t,e,n){null==n&&(n=""),n&&(n=": "+n),k(t>=e,"missing arguemnt"+n,"MISSING_ARGUMENT",{count:t,expectedCount:e}),k(t<=e,"too many arguments"+n,"UNEXPECTED_ARGUMENT",{count:t,expectedCount:e})}function A(t,e,n){if(null==n&&(n=""),t!==e){let t=n,e="new";n&&(t+=".",e+=" "+n),k(!1,`private constructor; use ${t}from* methods`,"UNSUPPORTED_OPERATION",{operation:e})}}function x(t,e,n){if(t instanceof Uint8Array)return n?new Uint8Array(t):t;if("string"==typeof t&&t.match(/^0x([0-9a-f][0-9a-f])*$/i)){const e=new Uint8Array((t.length-2)/2);let n=2;for(let r=0;r<e.length;r++)e[r]=parseInt(t.substring(n,n+2),16),n+=2;return e}N(!1,"invalid BytesLike value",e||"value",t)}function T(t,e){return x(t,e,!1)}function P(t,e){return x(t,e,!0)}function R(t,e){return!("string"!=typeof t||!t.match(/^0x[0-9A-Fa-f]*$/)||"number"==typeof e&&t.length!==2+2*e||!0===e&&t.length%2!==0)}["NFD","NFC","NFKD","NFKC"].reduce(((t,e)=>{try{if("test"!=="test".normalize(e))throw new Error("bad");if("NFD"===e&&"e\u0301"!=="\xe9".normalize("NFD"))throw new Error("broken");t.push(e)}catch{}return t}),[]);const U="0123456789abcdef";function I(t){const e=T(t);let n="0x";for(let r=0;r<e.length;r++){const t=e[r];n+=U[(240&t)>>4]+U[15&t]}return n}function S(t){return"0x"+t.map((t=>I(t).substring(2))).join("")}function _(t,e,n){const r=T(t);return null!=n&&n>r.length&&k(!1,"cannot slice beyond data bounds","BUFFER_OVERRUN",{buffer:r,length:r.length,offset:n}),I(r.slice(e??0,n??r.length))}function F(t,e,n){const r=T(t);k(e>=r.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(r),length:e,offset:e+1});const s=new Uint8Array(e);return s.fill(0),n?s.set(r,e-r.length):s.set(r,0),I(s)}const C=BigInt(0),L=BigInt(1),B=9007199254740991;function j(t,e){const n=D(t,"value"),r=BigInt(V(e,"bits"));return n&(L<<r)-L}function $(t,e){switch(typeof t){case"bigint":return t;case"number":return N(Number.isInteger(t),"underflow",e||"value",t),N(t>=-B&&t<=B,"overflow",e||"value",t),BigInt(t);case"string":try{if(""===t)throw new Error("empty string");return"-"===t[0]&&"-"!==t[1]?-BigInt(t.substring(1)):BigInt(t)}catch(n){N(!1,`invalid BigNumberish string: ${n.message}`,e||"value",t)}}N(!1,"invalid BigNumberish value",e||"value",t)}function D(t,e){const n=$(t,e);return k(n>=C,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:t}),n}const M="0123456789abcdef";function G(t){if(t instanceof Uint8Array){let e="0x0";for(const n of t)e+=M[n>>4],e+=M[15&n];return BigInt(e)}return $(t)}function V(t,e){switch(typeof t){case"bigint":return N(t>=-B&&t<=B,"overflow",e||"value",t),Number(t);case"number":return N(Number.isInteger(t),"underflow",e||"value",t),N(t>=-B&&t<=B,"overflow",e||"value",t),t;case"string":try{if(""===t)throw new Error("empty string");return V(BigInt(t),e)}catch(n){N(!1,`invalid numeric string: ${n.message}`,e||"value",t)}}N(!1,"invalid numeric value",e||"value",t)}function W(t,e){let n=D(t,"value").toString(16);if(null==e)n.length%2&&(n="0"+n);else{const r=V(e,"width");for(k(2*r>=n.length,`value exceeds width (${r} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:t});n.length<2*r;)n="0"+n}return"0x"+n}var H;class z{constructor(t,e,n){c(this,"filter"),c(this,"emitter"),h(this,H,void 0),f(this,H,e),y(this,{emitter:t,filter:n})}async removeListener(){null!=l(this,H)&&await this.emitter.off(this.filter,l(this,H))}}function J(t,e,n,r,s){if("BAD_PREFIX"===t||"UNEXPECTED_CONTINUE"===t){let t=0;for(let r=e+1;r<n.length&&n[r]>>6===2;r++)t++;return t}return"OVERRUN"===t?n.length-e-1:0}H=new WeakMap;const K=Object.freeze({error:function(t,e,n,r,s){N(!1,`invalid codepoint at offset ${e}; ${t}`,"bytes",n)},ignore:J,replace:function(t,e,n,r,s){return"OVERLONG"===t?(N("number"==typeof s,"invalid bad code point for replacement","badCodepoint",s),r.push(s),0):(r.push(65533),J(t,e,n))}});function q(t,e){N("string"==typeof t,"invalid string value","str",t);let n=[];for(let r=0;r<t.length;r++){const e=t.charCodeAt(r);if(e<128)n.push(e);else if(e<2048)n.push(e>>6|192),n.push(63&e|128);else if(55296==(64512&e)){r++;const s=t.charCodeAt(r);N(r<t.length&&56320===(64512&s),"invalid surrogate pair","str",t);const i=65536+((1023&e)<<10)+(1023&s);n.push(i>>18|240),n.push(i>>12&63|128),n.push(i>>6&63|128),n.push(63&i|128)}else n.push(e>>12|224),n.push(e>>6&63|128),n.push(63&e|128)}return new Uint8Array(n)}function X(t,e){return function(t){return t.map((t=>t<=65535?String.fromCharCode(t):(t-=65536,String.fromCharCode(55296+(t>>10&1023),56320+(1023&t))))).join("")}(function(t,e){null==e&&(e=K.error);const n=T(t,"bytes"),r=[];let s=0;for(;s<n.length;){const t=n[s++];if(!(t>>7)){r.push(t);continue}let i=null,a=null;if(192===(224&t))i=1,a=127;else if(224===(240&t))i=2,a=2047;else{if(240!==(248&t)){s+=e(128===(192&t)?"UNEXPECTED_CONTINUE":"BAD_PREFIX",s-1,n,r);continue}i=3,a=65535}if(s-1+i>=n.length){s+=e("OVERRUN",s-1,n,r);continue}let o=t&(1<<8-i-1)-1;for(let c=0;c<i;c++){let t=n[s];if(128!=(192&t)){s+=e("MISSING_CONTINUE",s,n,r),o=null;break}o=o<<6|63&t,s++}if(null!==o){if(o>1114111){s+=e("OUT_OF_RANGE",s-1-i,n,r,o);continue}if(o>=55296&&o<=57343){s+=e("UTF16_SURROGATE",s-1-i,n,r,o);continue}if(o<=a){s+=e("OVERLONG",s-1-i,n,r,o);continue}r.push(o)}}return r}(t,e))}const Y=32,Z=new Uint8Array(Y),Q=["then"],tt={};function et(t,e){const n=new Error(`deferred error during ABI decoding triggered accessing ${t}`);throw n.error=e,n}var nt;nt=new WeakMap;let rt=class t extends Array{constructor(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];const r=e[0];let s=e[1],i=(e[2]||[]).slice(),a=!0;r!==tt&&(s=e,i=[],a=!1),super(s.length),h(this,nt,void 0),s.forEach(((t,e)=>{this[e]=t}));const o=i.reduce(((t,e)=>("string"==typeof e&&t.set(e,(t.get(e)||0)+1),t)),new Map);if(f(this,nt,Object.freeze(s.map(((t,e)=>{const n=i[e];return null!=n&&1===o.get(n)?n:null})))),a)return Object.freeze(this),new Proxy(this,{get:(t,e,n)=>{if("string"==typeof e){if(e.match(/^[0-9]+$/)){const n=V(e,"%index");if(n<0||n>=this.length)throw new RangeError("out of result range");const r=t[n];return r instanceof Error&&et(`index ${n}`,r),r}if(Q.indexOf(e)>=0)return Reflect.get(t,e,n);const r=t[e];if(r instanceof Function)return function(){for(var e=arguments.length,s=new Array(e),i=0;i<e;i++)s[i]=arguments[i];return r.apply(this===n?t:this,s)};if(!(e in t))return t.getValue.apply(this===n?t:this,[e])}return Reflect.get(t,e,n)}})}toArray(e){const n=[];return this.forEach(((r,s)=>{r instanceof Error&&et(`index ${s}`,r),e&&r instanceof t&&(r=r.toArray(e)),n.push(r)})),n}toObject(e){return l(this,nt).reduce(((n,r,s)=>{if(k(null!=r,"value at index ${ index } unnamed","UNSUPPORTED_OPERATION",{operation:"toObject()"}),!(r in n)){let s=this.getValue(r);e&&s instanceof t&&(s=s.toObject(e)),n[r]=s}return n}),{})}slice(e,n){null==e&&(e=0),e<0&&((e+=this.length)<0&&(e=0)),null==n&&(n=this.length),n<0&&((n+=this.length)<0&&(n=0)),n>this.length&&(n=this.length);const r=[],s=[];for(let t=e;t<n;t++)r.push(this[t]),s.push(l(this,nt)[t]);return new t(tt,r,s)}filter(e,n){const r=[],s=[];for(let t=0;t<this.length;t++){const i=this[t];i instanceof Error&&et(`index ${t}`,i),e.call(n,i,t,this)&&(r.push(i),s.push(l(this,nt)[t]))}return new t(tt,r,s)}map(t,e){const n=[];for(let r=0;r<this.length;r++){const s=this[r];s instanceof Error&&et(`index ${r}`,s),n.push(t.call(e,s,r,this))}return n}getValue(t){const e=l(this,nt).indexOf(t);if(-1===e)return;const n=this[e];return n instanceof Error&&et(`property ${JSON.stringify(t)}`,n.error),n}static fromItems(e,n){return new t(tt,e,n)}};function st(t){let e=function(t){const e=D(t,"value");if(e===C)return new Uint8Array([]);let n=e.toString(16);n.length%2&&(n="0"+n);const r=new Uint8Array(n.length/2);for(let s=0;s<r.length;s++){const t=2*s;r[s]=parseInt(n.substring(t,t+2),16)}return r}(t);return k(e.length<=Y,"value out-of-bounds","BUFFER_OVERRUN",{buffer:e,length:Y,offset:e.length}),e.length!==Y&&(e=P(S([Z.slice(e.length%Y),e]))),e}class it{constructor(t,e,n,r){c(this,"name"),c(this,"type"),c(this,"localName"),c(this,"dynamic"),y(this,{name:t,type:e,localName:n,dynamic:r},{name:"string",type:"string",localName:"string",dynamic:"boolean"})}_throwError(t,e){N(!1,t,this.localName,e)}}var at,ot,ct,ut,lt,ht,ft,dt,pt,gt,mt,yt,wt;class bt{constructor(){h(this,ct),h(this,at,void 0),h(this,ot,void 0),f(this,at,[]),f(this,ot,0)}get data(){return S(l(this,at))}get length(){return l(this,ot)}appendWriter(t){return d(this,ct,ut).call(this,P(t.data))}writeBytes(t){let e=P(t);const n=e.length%Y;return n&&(e=P(S([e,Z.slice(n)]))),d(this,ct,ut).call(this,e)}writeValue(t){return d(this,ct,ut).call(this,st(t))}writeUpdatableValue(){const t=l(this,at).length;return l(this,at).push(Z),f(this,ot,l(this,ot)+Y),e=>{l(this,at)[t]=st(e)}}}at=new WeakMap,ot=new WeakMap,ct=new WeakSet,ut=function(t){return l(this,at).push(t),f(this,ot,l(this,ot)+t.length),t.length};lt=new WeakMap,ht=new WeakMap,ft=new WeakMap,dt=new WeakMap,pt=new WeakMap,gt=new WeakSet,mt=function(t){var e;if(l(this,dt))return d(e=l(this,dt),gt,mt).call(e,t);f(this,ft,l(this,ft)+t),k(l(this,pt)<1||l(this,ft)<=l(this,pt)*this.dataLength,`compressed ABI data exceeds inflation ratio of ${l(this,pt)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`,"BUFFER_OVERRUN",{buffer:P(l(this,lt)),offset:l(this,ht),length:t,info:{bytesRead:l(this,ft),dataLength:this.dataLength}})},yt=new WeakSet,wt=function(t,e,n){let r=Math.ceil(e/Y)*Y;return l(this,ht)+r>l(this,lt).length&&(this.allowLoose&&n&&l(this,ht)+e<=l(this,lt).length?r=e:k(!1,"data out-of-bounds","BUFFER_OVERRUN",{buffer:P(l(this,lt)),length:l(this,lt).length,offset:l(this,ht)+r})),l(this,lt).slice(l(this,ht),l(this,ht)+r)};let vt=class t{constructor(t,e,n){h(this,gt),h(this,yt),c(this,"allowLoose"),h(this,lt,void 0),h(this,ht,void 0),h(this,ft,void 0),h(this,dt,void 0),h(this,pt,void 0),y(this,{allowLoose:!!e}),f(this,lt,P(t)),f(this,ft,0),f(this,dt,null),f(this,pt,n??1024),f(this,ht,0)}get data(){return I(l(this,lt))}get dataLength(){return l(this,lt).length}get consumed(){return l(this,ht)}get bytes(){return new Uint8Array(l(this,lt))}subReader(e){const n=new t(l(this,lt).slice(l(this,ht)+e),this.allowLoose,l(this,pt));return f(n,dt,this),n}readBytes(t,e){let n=d(this,yt,wt).call(this,0,t,!!e);return d(this,gt,mt).call(this,t),f(this,ht,l(this,ht)+n.length),n.slice(0,t)}readValue(){return G(this.readBytes(Y))}readIndex(){return V(G(this.readBytes(Y)))}};function Et(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function kt(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];if(n.length>0&&!n.includes(t.length))throw new Error(`Expected Uint8Array of length ${n}, not of length=${t.length}`)}function Nt(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}const Ot=t=>t instanceof Uint8Array;if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");function At(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!Ot(t))throw new Error("expected Uint8Array, got "+typeof t);return t}class xt{clone(){return this._cloneInto()}}const Tt=BigInt(2**32-1),Pt=BigInt(32);function Rt(t){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?{h:Number(t&Tt),l:Number(t>>Pt&Tt)}:{h:0|Number(t>>Pt&Tt),l:0|Number(t&Tt)}}function Ut(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let s=0;s<t.length;s++){const{h:i,l:a}=Rt(t[s],e);[n[s],r[s]]=[i,a]}return[n,r]}const[It,St,_t]=[[],[],[]],Ft=BigInt(0),Ct=BigInt(1),Lt=BigInt(2),Bt=BigInt(7),jt=BigInt(256),$t=BigInt(113);for(let Jr=0,Kr=Ct,qr=1,Xr=0;Jr<24;Jr++){[qr,Xr]=[Xr,(2*qr+3*Xr)%5],It.push(2*(5*Xr+qr)),St.push((Jr+1)*(Jr+2)/2%64);let t=Ft;for(let e=0;e<7;e++)Kr=(Kr<<Ct^(Kr>>Bt)*$t)%jt,Kr&Lt&&(t^=Ct<<(Ct<<BigInt(e))-Ct);_t.push(t)}const[Dt,Mt]=Ut(_t,!0),Gt=(t,e,n)=>n>32?((t,e,n)=>e<<n-32|t>>>64-n)(t,e,n):((t,e,n)=>t<<n|e>>>32-n)(t,e,n),Vt=(t,e,n)=>n>32?((t,e,n)=>t<<n-32|e>>>64-n)(t,e,n):((t,e,n)=>e<<n|t>>>32-n)(t,e,n);class Wt extends xt{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:24;if(super(),this.blockLen=t,this.suffix=e,this.outputLen=n,this.enableXOF=r,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Et(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var i;this.state=new Uint8Array(200),this.state32=(i=this.state,new Uint32Array(i.buffer,i.byteOffset,Math.floor(i.byteLength/4)))}keccak(){(function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:24;const n=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let r=0;r<10;r++)n[r]=t[r]^t[r+10]^t[r+20]^t[r+30]^t[r+40];for(let r=0;r<10;r+=2){const e=(r+8)%10,s=(r+2)%10,i=n[s],a=n[s+1],o=Gt(i,a,1)^n[e],c=Vt(i,a,1)^n[e+1];for(let n=0;n<50;n+=10)t[r+n]^=o,t[r+n+1]^=c}let e=t[2],s=t[3];for(let n=0;n<24;n++){const r=St[n],i=Gt(e,s,r),a=Vt(e,s,r),o=It[n];e=t[o],s=t[o+1],t[o]=i,t[o+1]=a}for(let r=0;r<50;r+=10){for(let e=0;e<10;e++)n[e]=t[r+e];for(let e=0;e<10;e++)t[r+e]^=~n[(e+2)%10]&n[(e+4)%10]}t[0]^=Dt[r],t[1]^=Mt[r]}n.fill(0)})(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){Nt(this);const{blockLen:e,state:n}=this,r=(t=At(t)).length;for(let s=0;s<r;){const i=Math.min(e-this.pos,r-s);for(let e=0;e<i;e++)n[this.pos++]^=t[s++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:n,blockLen:r}=this;t[n]^=e,128&e&&n===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){Nt(this,!1),kt(t),this.finish();const e=this.state,{blockLen:n}=this;for(let r=0,s=t.length;r<s;){this.posOut>=n&&this.keccak();const i=Math.min(n-this.posOut,s-r);t.set(e.subarray(this.posOut,this.posOut+i),r),this.posOut+=i,r+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return Et(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(function(t,e){kt(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:n,outputLen:r,rounds:s,enableXOF:i}=this;return t||(t=new Wt(e,n,r,i,s)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=n,t.outputLen=r,t.enableXOF=i,t.destroyed=this.destroyed,t}}const Ht=((t,e,n)=>function(t){const e=e=>t().update(At(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}((()=>new Wt(e,t,n))))(1,136,32);let zt=!1;const Jt=function(t){return Ht(t)};let Kt=Jt;function qt(t){const e=T(t,"data");return I(Kt(e))}qt._=Jt,qt.lock=function(){zt=!0},qt.register=function(t){if(zt)throw new TypeError("keccak256 is locked");Kt=t},Object.freeze(qt);const Xt=BigInt(0),Yt=BigInt(36);function Zt(t){const e=(t=t.toLowerCase()).substring(2).split(""),n=new Uint8Array(40);for(let s=0;s<40;s++)n[s]=e[s].charCodeAt(0);const r=T(qt(n));for(let s=0;s<40;s+=2)r[s>>1]>>4>=8&&(e[s]=e[s].toUpperCase()),(15&r[s>>1])>=8&&(e[s+1]=e[s+1].toUpperCase());return"0x"+e.join("")}const Qt={};for(let Jr=0;Jr<10;Jr++)Qt[String(Jr)]=String(Jr);for(let Jr=0;Jr<26;Jr++)Qt[String.fromCharCode(65+Jr)]=String(10+Jr);const te=15;const ee=function(){const t={};for(let e=0;e<36;e++){t["0123456789abcdefghijklmnopqrstuvwxyz"[e]]=BigInt(e)}return t}();function ne(t){if(N("string"==typeof t,"invalid address","address",t),t.match(/^(0x)?[0-9a-fA-F]{40}$/)){t.startsWith("0x")||(t="0x"+t);const e=Zt(t);return N(!t.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||e===t,"bad address checksum","address",t),e}if(t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){N(t.substring(2,4)===function(t){let e=(t=(t=t.toUpperCase()).substring(4)+t.substring(0,2)+"00").split("").map((t=>Qt[t])).join("");for(;e.length>=te;){let t=e.substring(0,te);e=parseInt(t,10)%97+e.substring(t.length)}let n=String(98-parseInt(e,10)%97);for(;n.length<2;)n="0"+n;return n}(t),"bad icap checksum","address",t);let e=function(t){t=t.toLowerCase();let e=Xt;for(let n=0;n<t.length;n++)e=e*Yt+ee[t[n]];return e}(t.substring(4)).toString(16);for(;e.length<40;)e="0"+e;return Zt("0x"+e)}N(!1,"invalid address","address",t)}function re(t){return t&&"function"==typeof t.getAddress}async function se(t,e){const n=await e;return(null==n||"0x0000000000000000000000000000000000000000"===n)&&(k("string"!=typeof t,"unconfigured name","UNCONFIGURED_NAME",{value:t}),N(!1,"invalid AddressLike value; did not resolve to a value address","target",t)),ne(n)}function ie(t,e){return"string"==typeof t?t.match(/^0x[0-9a-f]{40}$/i)?ne(t):(k(null!=e,"ENS resolution requires a provider","UNSUPPORTED_OPERATION",{operation:"resolveName"}),se(t,e.resolveName(t))):re(t)?se(t,t.getAddress()):t&&"function"==typeof t.then?se(t,t):void N(!1,"unsupported addressable value","target",t)}const ae={};function oe(t,e){let n=!1;return e<0&&(n=!0,e*=-1),new he(ae,`${n?"":"u"}int${e}`,t,{signed:n,width:e})}function ce(t,e){return new he(ae,`bytes${e||""}`,t,{size:e})}const ue=Symbol.for("_ethers_typed");var le;le=new WeakMap;let he=class t{constructor(t,e,n,r){c(this,"type"),c(this,"value"),h(this,le,void 0),c(this,"_typedSymbol"),null==r&&(r=null),A(ae,t,"Typed"),y(this,{_typedSymbol:ue,type:e,value:n}),f(this,le,r),this.format()}format(){if("array"===this.type)throw new Error("");if("dynamicArray"===this.type)throw new Error("");return"tuple"===this.type?`tuple(${this.value.map((t=>t.format())).join(",")})`:this.type}defaultValue(){return 0}minValue(){return 0}maxValue(){return 0}isBigInt(){return!!this.type.match(/^u?int[0-9]+$/)}isData(){return this.type.startsWith("bytes")}isString(){return"string"===this.type}get tupleName(){if("tuple"!==this.type)throw TypeError("not a tuple");return l(this,le)}get arrayLength(){if("array"!==this.type)throw TypeError("not an array");return!0===l(this,le)?-1:!1===l(this,le)?this.value.length:null}static from(e,n){return new t(ae,e,n)}static uint8(t){return oe(t,8)}static uint16(t){return oe(t,16)}static uint24(t){return oe(t,24)}static uint32(t){return oe(t,32)}static uint40(t){return oe(t,40)}static uint48(t){return oe(t,48)}static uint56(t){return oe(t,56)}static uint64(t){return oe(t,64)}static uint72(t){return oe(t,72)}static uint80(t){return oe(t,80)}static uint88(t){return oe(t,88)}static uint96(t){return oe(t,96)}static uint104(t){return oe(t,104)}static uint112(t){return oe(t,112)}static uint120(t){return oe(t,120)}static uint128(t){return oe(t,128)}static uint136(t){return oe(t,136)}static uint144(t){return oe(t,144)}static uint152(t){return oe(t,152)}static uint160(t){return oe(t,160)}static uint168(t){return oe(t,168)}static uint176(t){return oe(t,176)}static uint184(t){return oe(t,184)}static uint192(t){return oe(t,192)}static uint200(t){return oe(t,200)}static uint208(t){return oe(t,208)}static uint216(t){return oe(t,216)}static uint224(t){return oe(t,224)}static uint232(t){return oe(t,232)}static uint240(t){return oe(t,240)}static uint248(t){return oe(t,248)}static uint256(t){return oe(t,256)}static uint(t){return oe(t,256)}static int8(t){return oe(t,-8)}static int16(t){return oe(t,-16)}static int24(t){return oe(t,-24)}static int32(t){return oe(t,-32)}static int40(t){return oe(t,-40)}static int48(t){return oe(t,-48)}static int56(t){return oe(t,-56)}static int64(t){return oe(t,-64)}static int72(t){return oe(t,-72)}static int80(t){return oe(t,-80)}static int88(t){return oe(t,-88)}static int96(t){return oe(t,-96)}static int104(t){return oe(t,-104)}static int112(t){return oe(t,-112)}static int120(t){return oe(t,-120)}static int128(t){return oe(t,-128)}static int136(t){return oe(t,-136)}static int144(t){return oe(t,-144)}static int152(t){return oe(t,-152)}static int160(t){return oe(t,-160)}static int168(t){return oe(t,-168)}static int176(t){return oe(t,-176)}static int184(t){return oe(t,-184)}static int192(t){return oe(t,-192)}static int200(t){return oe(t,-200)}static int208(t){return oe(t,-208)}static int216(t){return oe(t,-216)}static int224(t){return oe(t,-224)}static int232(t){return oe(t,-232)}static int240(t){return oe(t,-240)}static int248(t){return oe(t,-248)}static int256(t){return oe(t,-256)}static int(t){return oe(t,-256)}static bytes1(t){return ce(t,1)}static bytes2(t){return ce(t,2)}static bytes3(t){return ce(t,3)}static bytes4(t){return ce(t,4)}static bytes5(t){return ce(t,5)}static bytes6(t){return ce(t,6)}static bytes7(t){return ce(t,7)}static bytes8(t){return ce(t,8)}static bytes9(t){return ce(t,9)}static bytes10(t){return ce(t,10)}static bytes11(t){return ce(t,11)}static bytes12(t){return ce(t,12)}static bytes13(t){return ce(t,13)}static bytes14(t){return ce(t,14)}static bytes15(t){return ce(t,15)}static bytes16(t){return ce(t,16)}static bytes17(t){return ce(t,17)}static bytes18(t){return ce(t,18)}static bytes19(t){return ce(t,19)}static bytes20(t){return ce(t,20)}static bytes21(t){return ce(t,21)}static bytes22(t){return ce(t,22)}static bytes23(t){return ce(t,23)}static bytes24(t){return ce(t,24)}static bytes25(t){return ce(t,25)}static bytes26(t){return ce(t,26)}static bytes27(t){return ce(t,27)}static bytes28(t){return ce(t,28)}static bytes29(t){return ce(t,29)}static bytes30(t){return ce(t,30)}static bytes31(t){return ce(t,31)}static bytes32(t){return ce(t,32)}static address(e){return new t(ae,"address",e)}static bool(e){return new t(ae,"bool",!!e)}static bytes(e){return new t(ae,"bytes",e)}static string(e){return new t(ae,"string",e)}static array(t,e){throw new Error("not implemented yet")}static tuple(t,e){throw new Error("not implemented yet")}static overrides(e){return new t(ae,"overrides",Object.assign({},e))}static isTyped(t){return t&&"object"==typeof t&&"_typedSymbol"in t&&t._typedSymbol===ue}static dereference(e,n){if(t.isTyped(e)){if(e.type!==n)throw new Error(`invalid type: expecetd ${n}, got ${e.type}`);return e.value}return e}};class fe extends it{constructor(t){super("address","address",t,!1)}defaultValue(){return"0x0000000000000000000000000000000000000000"}encode(t,e){let n=he.dereference(e,"string");try{n=ne(n)}catch(r){return this._throwError(r.message,e)}return t.writeValue(n)}decode(t){return ne(W(t.readValue(),20))}}class de extends it{constructor(t){super(t.name,t.type,"_",t.dynamic),c(this,"coder"),this.coder=t}defaultValue(){return this.coder.defaultValue()}encode(t,e){return this.coder.encode(t,e)}decode(t){return this.coder.decode(t)}}function pe(t,e,n){let r=[];if(Array.isArray(n))r=n;else if(n&&"object"==typeof n){let t={};r=e.map((e=>{const r=e.localName;return k(r,"cannot encode object for signature with missing names","INVALID_ARGUMENT",{argument:"values",info:{coder:e},value:n}),k(!t[r],"cannot encode object for signature with duplicate names","INVALID_ARGUMENT",{argument:"values",info:{coder:e},value:n}),t[r]=!0,n[r]}))}else N(!1,"invalid tuple value","tuple",n);N(e.length===r.length,"types/value length mismatch","tuple",n);let s=new bt,i=new bt,a=[];e.forEach(((t,e)=>{let n=r[e];if(t.dynamic){let e=i.length;t.encode(i,n);let r=s.writeUpdatableValue();a.push((t=>{r(t+e)}))}else t.encode(s,n)})),a.forEach((t=>{t(s.length)}));let o=t.appendWriter(s);return o+=t.appendWriter(i),o}function ge(t,e){let n=[],r=[],s=t.subReader(0);return e.forEach((e=>{let i=null;if(e.dynamic){let n=t.readIndex(),r=s.subReader(n);try{i=e.decode(r)}catch(a){if(b(a,"BUFFER_OVERRUN"))throw a;i=a,i.baseType=e.name,i.name=e.localName,i.type=e.type}}else try{i=e.decode(t)}catch(o){if(b(o,"BUFFER_OVERRUN"))throw o;i=o,i.baseType=e.name,i.name=e.localName,i.type=e.type}if(null==i)throw new Error("investigate");n.push(i),r.push(e.localName||null)})),rt.fromItems(n,r)}class me extends it{constructor(t,e,n){super("array",t.type+"["+(e>=0?e:"")+"]",n,-1===e||t.dynamic),c(this,"coder"),c(this,"length"),y(this,{coder:t,length:e})}defaultValue(){const t=this.coder.defaultValue(),e=[];for(let n=0;n<this.length;n++)e.push(t);return e}encode(t,e){const n=he.dereference(e,"array");Array.isArray(n)||this._throwError("expected array value",n);let r=this.length;-1===r&&(r=n.length,t.writeValue(n.length)),O(n.length,r,"coder array"+(this.localName?" "+this.localName:""));let s=[];for(let i=0;i<n.length;i++)s.push(this.coder);return pe(t,s,n)}decode(t){let e=this.length;-1===e&&(e=t.readIndex(),k(e*Y<=t.dataLength,"insufficient data length","BUFFER_OVERRUN",{buffer:t.bytes,offset:e*Y,length:t.dataLength}));let n=[];for(let r=0;r<e;r++)n.push(new de(this.coder));return ge(t,n)}}class ye extends it{constructor(t){super("bool","bool",t,!1)}defaultValue(){return!1}encode(t,e){const n=he.dereference(e,"bool");return t.writeValue(n?1:0)}decode(t){return!!t.readValue()}}class we extends it{constructor(t,e){super(t,t,e,!0)}defaultValue(){return"0x"}encode(t,e){e=P(e);let n=t.writeValue(e.length);return n+=t.writeBytes(e),n}decode(t){return t.readBytes(t.readIndex(),!0)}}class be extends we{constructor(t){super("bytes",t)}decode(t){return I(super.decode(t))}}class ve extends it{constructor(t,e){let n="bytes"+String(t);super(n,n,e,!1),c(this,"size"),y(this,{size:t},{size:"number"})}defaultValue(){return"0x0000000000000000000000000000000000000000000000000000000000000000".substring(0,2+2*this.size)}encode(t,e){let n=P(he.dereference(e,this.type));return n.length!==this.size&&this._throwError("incorrect data length",e),t.writeBytes(n)}decode(t){return I(t.readBytes(this.size))}}const Ee=new Uint8Array([]);class ke extends it{constructor(t){super("null","",t,!1)}defaultValue(){return null}encode(t,e){return null!=e&&this._throwError("not null",e),t.writeBytes(Ee)}decode(t){return t.readBytes(0),null}}const Ne=BigInt(0),Oe=BigInt(1),Ae=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");class xe extends it{constructor(t,e,n){const r=(e?"int":"uint")+8*t;super(r,r,n,!1),c(this,"size"),c(this,"signed"),y(this,{size:t,signed:e},{size:"number",signed:"boolean"})}defaultValue(){return 0}encode(t,e){let n=$(he.dereference(e,this.type)),r=j(Ae,256);if(this.signed){let t=j(r,8*this.size-1);(n>t||n<-(t+Oe))&&this._throwError("value out-of-bounds",e),n=function(t,e){let n=$(t,"value");const r=BigInt(V(e,"width")),s=L<<r-L;if(n<C)return n=-n,k(n<=s,"too low","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:t}),(~n&(L<<r)-L)+L;return k(n<s,"too high","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:t}),n}(n,256)}else(n<Ne||n>j(r,8*this.size))&&this._throwError("value out-of-bounds",e);return t.writeValue(n)}decode(t){let e=j(t.readValue(),8*this.size);return this.signed&&(e=function(t,e){const n=D(t,"value"),r=BigInt(V(e,"width"));if(k(n>>r===C,"overflow","NUMERIC_FAULT",{operation:"fromTwos",fault:"overflow",value:t}),n>>r-L)return-((~n&(L<<r)-L)+L);return n}(e,8*this.size)),e}}class Te extends we{constructor(t){super("string",t)}defaultValue(){return""}encode(t,e){return super.encode(t,q(he.dereference(e,"string")))}decode(t){return X(super.decode(t))}}class Pe extends it{constructor(t,e){let n=!1;const r=[];t.forEach((t=>{t.dynamic&&(n=!0),r.push(t.type)}));super("tuple","tuple("+r.join(",")+")",e,n),c(this,"coders"),y(this,{coders:Object.freeze(t.slice())})}defaultValue(){const t=[];this.coders.forEach((e=>{t.push(e.defaultValue())}));const e=this.coders.reduce(((t,e)=>{const n=e.localName;return n&&(t[n]||(t[n]=0),t[n]++),t}),{});return this.coders.forEach(((n,r)=>{let s=n.localName;!s||1!==e[s]||("length"===s&&(s="_length"),null==t[s]&&(t[s]=t[r]))})),Object.freeze(t)}encode(t,e){const n=he.dereference(e,"tuple");return pe(t,this.coders,n)}decode(t){return ge(t,this.coders)}}function Re(t){return qt(q(t))}function Ue(t,e){return{address:ne(t),storageKeys:e.map(((t,e)=>(N(R(t,32),"invalid slot",`storageKeys[${e}]`,t),t.toLowerCase())))}}function Ie(t){const e=new Set;return t.forEach((t=>e.add(t))),Object.freeze(e)}const Se=Ie("external public payable override".split(" ")),_e="constant external internal payable private public pure view override",Fe=Ie(_e.split(" ")),Ce="constructor error event fallback function receive struct",Le=Ie(Ce.split(" ")),Be="calldata memory storage payable indexed",je=Ie(Be.split(" ")),$e=Ie([Ce,Be,"tuple returns",_e].join(" ").split(" ")),De={"(":"OPEN_PAREN",")":"CLOSE_PAREN","[":"OPEN_BRACKET","]":"CLOSE_BRACKET",",":"COMMA","@":"AT"},Me=new RegExp("^(\\s*)"),Ge=new RegExp("^([0-9]+)"),Ve=new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),We=new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),He=new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");var ze,Je,Ke,qe;const Xe=class t{constructor(t){h(this,Ke),h(this,ze,void 0),h(this,Je,void 0),f(this,ze,0),f(this,Je,t.slice())}get offset(){return l(this,ze)}get length(){return l(this,Je).length-l(this,ze)}clone(){return new t(l(this,Je))}reset(){f(this,ze,0)}popKeyword(t){const e=this.peek();if("KEYWORD"!==e.type||!t.has(e.text))throw new Error(`expected keyword ${e.text}`);return this.pop().text}popType(t){if(this.peek().type!==t){const e=this.peek();throw new Error(`expected ${t}; got ${e.type} ${JSON.stringify(e.text)}`)}return this.pop().text}popParen(){const t=this.peek();if("OPEN_PAREN"!==t.type)throw new Error("bad start");const e=d(this,Ke,qe).call(this,l(this,ze)+1,t.match+1);return f(this,ze,t.match+1),e}popParams(){const t=this.peek();if("OPEN_PAREN"!==t.type)throw new Error("bad start");const e=[];for(;l(this,ze)<t.match-1;){const t=this.peek().linkNext;e.push(d(this,Ke,qe).call(this,l(this,ze)+1,t)),f(this,ze,t)}return f(this,ze,t.match+1),e}peek(){if(l(this,ze)>=l(this,Je).length)throw new Error("out-of-bounds");return l(this,Je)[l(this,ze)]}peekKeyword(t){const e=this.peekType("KEYWORD");return null!=e&&t.has(e)?e:null}peekType(t){if(0===this.length)return null;const e=this.peek();return e.type===t?e.text:null}pop(){const t=this.peek();return((t,e,n,r)=>({set _(r){f(t,e,r,n)},get _(){return l(t,e,r)}}))(this,ze)._++,t}toString(){const t=[];for(let e=l(this,ze);e<l(this,Je).length;e++){const n=l(this,Je)[e];t.push(`${n.type}:${n.text}`)}return`<TokenString ${t.join(" ")}>`}};ze=new WeakMap,Je=new WeakMap,Ke=new WeakSet,qe=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Xe(l(this,Je).slice(t,e).map((e=>Object.freeze(Object.assign({},e,{match:e.match-t,linkBack:e.linkBack-t,linkNext:e.linkNext-t})))))};let Ye=Xe;function Ze(t){const e=[],n=e=>{const n=i<t.length?JSON.stringify(t[i]):"$EOI";throw new Error(`invalid token ${n} at ${i}: ${e}`)};let r=[],s=[],i=0;for(;i<t.length;){let a=t.substring(i),o=a.match(Me);o&&(i+=o[1].length,a=t.substring(i));const c={depth:r.length,linkBack:-1,linkNext:-1,match:-1,type:"",text:"",offset:i,value:-1};e.push(c);let u=De[a[0]]||"";if(u){if(c.type=u,c.text=a[0],i++,"OPEN_PAREN"===u)r.push(e.length-1),s.push(e.length-1);else if("CLOSE_PAREN"==u)0===r.length&&n("no matching open bracket"),c.match=r.pop(),e[c.match].match=e.length-1,c.depth--,c.linkBack=s.pop(),e[c.linkBack].linkNext=e.length-1;else if("COMMA"===u)c.linkBack=s.pop(),e[c.linkBack].linkNext=e.length-1,s.push(e.length-1);else if("OPEN_BRACKET"===u)c.type="BRACKET";else if("CLOSE_BRACKET"===u){let t=e.pop().text;if(e.length>0&&"NUMBER"===e[e.length-1].type){const n=e.pop().text;t=n+t,e[e.length-1].value=V(n)}if(0===e.length||"BRACKET"!==e[e.length-1].type)throw new Error("missing opening bracket");e[e.length-1].text+=t}}else if(o=a.match(Ve),o){if(c.text=o[1],i+=c.text.length,$e.has(c.text)){c.type="KEYWORD";continue}if(c.text.match(He)){c.type="TYPE";continue}c.type="ID"}else{if(o=a.match(Ge),!o)throw new Error(`unexpected token ${JSON.stringify(a[0])} at position ${i}`);c.text=o[1],c.type="NUMBER",i+=c.text.length}}return new Ye(e.map((t=>Object.freeze(t))))}function Qe(t,e){let n=[];for(const r in e.keys())t.has(r)&&n.push(r);if(n.length>1)throw new Error(`conflicting types: ${n.join(", ")}`)}function tn(t,e){if(e.peekKeyword(Le)){const n=e.pop().text;if(n!==t)throw new Error(`expected ${t}, got ${n}`)}return e.popType("ID")}function en(t,e){const n=new Set;for(;;){const r=t.peekType("KEYWORD");if(null==r||e&&!e.has(r))break;if(t.pop(),n.has(r))throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);n.add(r)}return Object.freeze(n)}function nn(t){let e=en(t,Fe);return Qe(e,Ie("constant payable nonpayable".split(" "))),Qe(e,Ie("pure view payable nonpayable".split(" "))),e.has("view")?"view":e.has("pure")?"pure":e.has("payable")?"payable":e.has("nonpayable")?"nonpayable":e.has("constant")?"view":"nonpayable"}function rn(t,e){return t.popParams().map((t=>vn.from(t,e)))}function sn(t){if(t.peekType("AT")){if(t.pop(),t.peekType("NUMBER"))return $(t.pop().text);throw new Error("invalid gas")}return null}function an(t){if(t.length)throw new Error(`unexpected tokens at offset ${t.offset}: ${t.toString()}`)}const on=new RegExp(/^(.*)\[([0-9]*)\]$/);function cn(t){const e=t.match(He);if(N(e,"invalid type","type",t),"uint"===t)return"uint256";if("int"===t)return"int256";if(e[2]){const n=parseInt(e[2]);N(0!==n&&n<=32,"invalid bytes length","type",t)}else if(e[3]){const n=parseInt(e[3]);N(0!==n&&n<=256&&n%8===0,"invalid numeric width","type",t)}return t}const un={},ln=Symbol.for("_ethers_internal"),hn="_ParamTypeInternal",fn="_ErrorInternal",dn="_EventInternal",pn="_ConstructorInternal",gn="_FallbackInternal",mn="_FunctionInternal",yn="_StructInternal";var wn,bn;wn=new WeakSet,bn=function(t,e,n,r){if(this.isArray()){if(!Array.isArray(e))throw new Error("invalid array value");if(-1!==this.arrayLength&&e.length!==this.arrayLength)throw new Error("array is wrong length");const s=this.arrayChildren,i=e.slice();return i.forEach(((e,r)=>{var a;d(a=s,wn,bn).call(a,t,e,n,(t=>{i[r]=t}))})),void r(i)}if(this.isTuple()){const s=this.components;let i;if(Array.isArray(e))i=e.slice();else{if(null==e||"object"!=typeof e)throw new Error("invalid tuple value");i=s.map((t=>{if(!t.name)throw new Error("cannot use object value with unnamed components");if(!(t.name in e))throw new Error(`missing value for component ${t.name}`);return e[t.name]}))}if(i.length!==this.components.length)throw new Error("array is wrong length");return i.forEach(((e,r)=>{var a;d(a=s[r],wn,bn).call(a,t,e,n,(t=>{i[r]=t}))})),void r(i)}const s=n(this.type,e);s.then?t.push(async function(){r(await s)}()):r(s)};let vn=class t{constructor(t,e,n,r,s,i,a,o){if(h(this,wn),c(this,"name"),c(this,"type"),c(this,"baseType"),c(this,"indexed"),c(this,"components"),c(this,"arrayLength"),c(this,"arrayChildren"),A(t,un,"ParamType"),Object.defineProperty(this,ln,{value:hn}),i&&(i=Object.freeze(i.slice())),"array"===r){if(null==a||null==o)throw new Error("")}else if(null!=a||null!=o)throw new Error("");if("tuple"===r){if(null==i)throw new Error("")}else if(null!=i)throw new Error("");y(this,{name:e,type:n,baseType:r,indexed:s,components:i,arrayLength:a,arrayChildren:o})}format(t){if(null==t&&(t="sighash"),"json"===t){const e=this.name||"";if(this.isArray()){const t=JSON.parse(this.arrayChildren.format("json"));return t.name=e,t.type+=`[${this.arrayLength<0?"":String(this.arrayLength)}]`,JSON.stringify(t)}const n={type:"tuple"===this.baseType?"tuple":this.type,name:e};return"boolean"==typeof this.indexed&&(n.indexed=this.indexed),this.isTuple()&&(n.components=this.components.map((e=>JSON.parse(e.format(t))))),JSON.stringify(n)}let e="";return this.isArray()?(e+=this.arrayChildren.format(t),e+=`[${this.arrayLength<0?"":String(this.arrayLength)}]`):this.isTuple()?e+="("+this.components.map((e=>e.format(t))).join("full"===t?", ":",")+")":e+=this.type,"sighash"!==t&&(!0===this.indexed&&(e+=" indexed"),"full"===t&&this.name&&(e+=" "+this.name)),e}isArray(){return"array"===this.baseType}isTuple(){return"tuple"===this.baseType}isIndexable(){return null!=this.indexed}walk(t,e){if(this.isArray()){if(!Array.isArray(t))throw new Error("invalid array value");if(-1!==this.arrayLength&&t.length!==this.arrayLength)throw new Error("array is wrong length");const n=this;return t.map((t=>n.arrayChildren.walk(t,e)))}if(this.isTuple()){if(!Array.isArray(t))throw new Error("invalid tuple value");if(t.length!==this.components.length)throw new Error("array is wrong length");const n=this;return t.map(((t,r)=>n.components[r].walk(t,e)))}return e(this.type,t)}async walkAsync(t,e){const n=[],r=[t];return d(this,wn,bn).call(this,n,t,e,(t=>{r[0]=t})),n.length&&await Promise.all(n),r[0]}static from(e,n){if(t.isParamType(e))return e;if("string"==typeof e)try{return t.from(Ze(e),n)}catch{N(!1,"invalid param type","obj",e)}else if(e instanceof Ye){let r="",s="",i=null;en(e,Ie(["tuple"])).has("tuple")||e.peekType("OPEN_PAREN")?(s="tuple",i=e.popParams().map((e=>t.from(e))),r=`tuple(${i.map((t=>t.format())).join(",")})`):(r=cn(e.popType("TYPE")),s=r);let a=null,o=null;for(;e.length&&e.peekType("BRACKET");){const n=e.pop();a=new t(un,"",r,s,null,i,o,a),o=n.value,r+=n.text,s="array",i=null}let c=null;if(en(e,je).has("indexed")){if(!n)throw new Error("");c=!0}const u=e.peekType("ID")?e.pop().text:"";if(e.length)throw new Error("leftover tokens");return new t(un,u,r,s,c,i,o,a)}const r=e.name;N(!r||"string"==typeof r&&r.match(We),"invalid name","obj.name",r);let s=e.indexed;null!=s&&(N(n,"parameter cannot be indexed","obj.indexed",e.indexed),s=!!s);let i=e.type,a=i.match(on);if(a){const n=parseInt(a[2]||"-1"),o=t.from({type:a[1],components:e.components});return new t(un,r||"",i,"array",s,null,n,o)}if("tuple"===i||i.startsWith("tuple(")||i.startsWith("(")){const n=null!=e.components?e.components.map((e=>t.from(e))):null;return new t(un,r||"",i,"tuple",s,n,null,null)}return i=cn(e.type),new t(un,r||"",i,i,s,null,null,null)}static isParamType(t){return t&&t[ln]===hn}};class En{constructor(t,e,n){c(this,"type"),c(this,"inputs"),A(t,un,"Fragment"),y(this,{type:e,inputs:n=Object.freeze(n.slice())})}static from(t){if("string"==typeof t){try{En.from(JSON.parse(t))}catch{}return En.from(Ze(t))}if(t instanceof Ye)switch(t.peekKeyword(Le)){case"constructor":return xn.from(t);case"error":return On.from(t);case"event":return An.from(t);case"fallback":case"receive":return Tn.from(t);case"function":return Pn.from(t);case"struct":return Rn.from(t)}else if("object"==typeof t){switch(t.type){case"constructor":return xn.from(t);case"error":return On.from(t);case"event":return An.from(t);case"fallback":case"receive":return Tn.from(t);case"function":return Pn.from(t);case"struct":return Rn.from(t)}k(!1,`unsupported type: ${t.type}`,"UNSUPPORTED_OPERATION",{operation:"Fragment.from"})}N(!1,"unsupported frgament object","obj",t)}static isConstructor(t){return xn.isFragment(t)}static isError(t){return On.isFragment(t)}static isEvent(t){return An.isFragment(t)}static isFunction(t){return Pn.isFragment(t)}static isStruct(t){return Rn.isFragment(t)}}class kn extends En{constructor(t,e,n,r){super(t,e,r),c(this,"name"),N("string"==typeof n&&n.match(We),"invalid identifier","name",n),r=Object.freeze(r.slice()),y(this,{name:n})}}function Nn(t,e){return"("+e.map((e=>e.format(t))).join("full"===t?", ":",")+")"}class On extends kn{constructor(t,e,n){super(t,"error",e,n),Object.defineProperty(this,ln,{value:fn})}get selector(){return Re(this.format("sighash")).substring(0,10)}format(t){if(null==t&&(t="sighash"),"json"===t)return JSON.stringify({type:"error",name:this.name,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});const e=[];return"sighash"!==t&&e.push("error"),e.push(this.name+Nn(t,this.inputs)),e.join(" ")}static from(t){if(On.isFragment(t))return t;if("string"==typeof t)return On.from(Ze(t));if(t instanceof Ye){const e=tn("error",t),n=rn(t);return an(t),new On(un,e,n)}return new On(un,t.name,t.inputs?t.inputs.map(vn.from):[])}static isFragment(t){return t&&t[ln]===fn}}class An extends kn{constructor(t,e,n,r){super(t,"event",e,n),c(this,"anonymous"),Object.defineProperty(this,ln,{value:dn}),y(this,{anonymous:r})}get topicHash(){return Re(this.format("sighash"))}format(t){if(null==t&&(t="sighash"),"json"===t)return JSON.stringify({type:"event",anonymous:this.anonymous,name:this.name,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});const e=[];return"sighash"!==t&&e.push("event"),e.push(this.name+Nn(t,this.inputs)),"sighash"!==t&&this.anonymous&&e.push("anonymous"),e.join(" ")}static getTopicHash(t,e){return e=(e||[]).map((t=>vn.from(t))),new An(un,t,e,!1).topicHash}static from(t){if(An.isFragment(t))return t;if("string"==typeof t)try{return An.from(Ze(t))}catch{N(!1,"invalid event fragment","obj",t)}else if(t instanceof Ye){const e=tn("event",t),n=rn(t,!0),r=!!en(t,Ie(["anonymous"])).has("anonymous");return an(t),new An(un,e,n,r)}return new An(un,t.name,t.inputs?t.inputs.map((t=>vn.from(t,!0))):[],!!t.anonymous)}static isFragment(t){return t&&t[ln]===dn}}class xn extends En{constructor(t,e,n,r,s){super(t,e,n),c(this,"payable"),c(this,"gas"),Object.defineProperty(this,ln,{value:pn}),y(this,{payable:r,gas:s})}format(t){if(k(null!=t&&"sighash"!==t,"cannot format a constructor for sighash","UNSUPPORTED_OPERATION",{operation:"format(sighash)"}),"json"===t)return JSON.stringify({type:"constructor",stateMutability:this.payable?"payable":"undefined",payable:this.payable,gas:null!=this.gas?this.gas:void 0,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});const e=[`constructor${Nn(t,this.inputs)}`];return this.payable&&e.push("payable"),null!=this.gas&&e.push(`@${this.gas.toString()}`),e.join(" ")}static from(t){if(xn.isFragment(t))return t;if("string"==typeof t)try{return xn.from(Ze(t))}catch{N(!1,"invalid constuctor fragment","obj",t)}else if(t instanceof Ye){en(t,Ie(["constructor"]));const e=rn(t),n=!!en(t,Se).has("payable"),r=sn(t);return an(t),new xn(un,"constructor",e,n,r)}return new xn(un,"constructor",t.inputs?t.inputs.map(vn.from):[],!!t.payable,null!=t.gas?t.gas:null)}static isFragment(t){return t&&t[ln]===pn}}class Tn extends En{constructor(t,e,n){super(t,"fallback",e),c(this,"payable"),Object.defineProperty(this,ln,{value:gn}),y(this,{payable:n})}format(t){const e=0===this.inputs.length?"receive":"fallback";if("json"===t){const t=this.payable?"payable":"nonpayable";return JSON.stringify({type:e,stateMutability:t})}return`${e}()${this.payable?" payable":""}`}static from(t){if(Tn.isFragment(t))return t;if("string"==typeof t)try{return Tn.from(Ze(t))}catch{N(!1,"invalid fallback fragment","obj",t)}else if(t instanceof Ye){const e=t.toString();if(N(t.peekKeyword(Ie(["fallback","receive"])),"type must be fallback or receive","obj",e),"receive"===t.popKeyword(Ie(["fallback","receive"]))){const e=rn(t);return N(0===e.length,"receive cannot have arguments","obj.inputs",e),en(t,Ie(["payable"])),an(t),new Tn(un,[],!0)}let n=rn(t);n.length?N(1===n.length&&"bytes"===n[0].type,"invalid fallback inputs","obj.inputs",n.map((t=>t.format("minimal"))).join(", ")):n=[vn.from("bytes")];const r=nn(t);if(N("nonpayable"===r||"payable"===r,"fallback cannot be constants","obj.stateMutability",r),en(t,Ie(["returns"])).has("returns")){const e=rn(t);N(1===e.length&&"bytes"===e[0].type,"invalid fallback outputs","obj.outputs",e.map((t=>t.format("minimal"))).join(", "))}return an(t),new Tn(un,n,"payable"===r)}if("receive"===t.type)return new Tn(un,[],!0);if("fallback"===t.type){const e=[vn.from("bytes")],n="payable"===t.stateMutability;return new Tn(un,e,n)}N(!1,"invalid fallback description","obj",t)}static isFragment(t){return t&&t[ln]===gn}}class Pn extends kn{constructor(t,e,n,r,s,i){super(t,"function",e,r),c(this,"constant"),c(this,"outputs"),c(this,"stateMutability"),c(this,"payable"),c(this,"gas"),Object.defineProperty(this,ln,{value:mn}),y(this,{constant:"view"===n||"pure"===n,gas:i,outputs:s=Object.freeze(s.slice()),payable:"payable"===n,stateMutability:n})}get selector(){return Re(this.format("sighash")).substring(0,10)}format(t){if(null==t&&(t="sighash"),"json"===t)return JSON.stringify({type:"function",name:this.name,constant:this.constant,stateMutability:"nonpayable"!==this.stateMutability?this.stateMutability:void 0,payable:this.payable,gas:null!=this.gas?this.gas:void 0,inputs:this.inputs.map((e=>JSON.parse(e.format(t)))),outputs:this.outputs.map((e=>JSON.parse(e.format(t))))});const e=[];return"sighash"!==t&&e.push("function"),e.push(this.name+Nn(t,this.inputs)),"sighash"!==t&&("nonpayable"!==this.stateMutability&&e.push(this.stateMutability),this.outputs&&this.outputs.length&&(e.push("returns"),e.push(Nn(t,this.outputs))),null!=this.gas&&e.push(`@${this.gas.toString()}`)),e.join(" ")}static getSelector(t,e){return e=(e||[]).map((t=>vn.from(t))),new Pn(un,t,"view",e,[],null).selector}static from(t){if(Pn.isFragment(t))return t;if("string"==typeof t)try{return Pn.from(Ze(t))}catch{N(!1,"invalid function fragment","obj",t)}else if(t instanceof Ye){const e=tn("function",t),n=rn(t),r=nn(t);let s=[];en(t,Ie(["returns"])).has("returns")&&(s=rn(t));const i=sn(t);return an(t),new Pn(un,e,r,n,s,i)}let e=t.stateMutability;return null==e&&(e="payable","boolean"==typeof t.constant?(e="view",t.constant||(e="payable","boolean"==typeof t.payable&&!t.payable&&(e="nonpayable"))):"boolean"==typeof t.payable&&!t.payable&&(e="nonpayable")),new Pn(un,t.name,e,t.inputs?t.inputs.map(vn.from):[],t.outputs?t.outputs.map(vn.from):[],null!=t.gas?t.gas:null)}static isFragment(t){return t&&t[ln]===mn}}class Rn extends kn{constructor(t,e,n){super(t,"struct",e,n),Object.defineProperty(this,ln,{value:yn})}format(){throw new Error("@TODO")}static from(t){if("string"==typeof t)try{return Rn.from(Ze(t))}catch{N(!1,"invalid struct fragment","obj",t)}else if(t instanceof Ye){const e=tn("struct",t),n=rn(t);return an(t),new Rn(un,e,n)}return new Rn(un,t.name,t.inputs?t.inputs.map(vn.from):[])}static isFragment(t){return t&&t[ln]===yn}}const Un=new Map;Un.set(0,"GENERIC_PANIC"),Un.set(1,"ASSERT_FALSE"),Un.set(17,"OVERFLOW"),Un.set(18,"DIVIDE_BY_ZERO"),Un.set(33,"ENUM_RANGE_ERROR"),Un.set(34,"BAD_STORAGE_DATA"),Un.set(49,"STACK_UNDERFLOW"),Un.set(50,"ARRAY_RANGE_ERROR"),Un.set(65,"OUT_OF_MEMORY"),Un.set(81,"UNINITIALIZED_FUNCTION_CALL");const In=new RegExp(/^bytes([0-9]*)$/),Sn=new RegExp(/^(u?int)([0-9]*)$/);let _n=null,Fn=1024;var Cn,Ln;Cn=new WeakSet,Ln=function(t){if(t.isArray())return new me(d(this,Cn,Ln).call(this,t.arrayChildren),t.arrayLength,t.name);if(t.isTuple())return new Pe(t.components.map((t=>d(this,Cn,Ln).call(this,t))),t.name);switch(t.baseType){case"address":return new fe(t.name);case"bool":return new ye(t.name);case"string":return new Te(t.name);case"bytes":return new be(t.name);case"":return new ke(t.name)}let e=t.type.match(Sn);if(e){let n=parseInt(e[2]||"256");return N(0!==n&&n<=256&&n%8===0,"invalid "+e[1]+" bit length","param",t),new xe(n/8,"int"===e[1],t.name)}if(e=t.type.match(In),e){let n=parseInt(e[1]);return N(0!==n&&n<=32,"invalid bytes length","param",t),new ve(n,t.name)}N(!1,"invalid type","type",t.type)};let Bn=class t{constructor(){h(this,Cn)}getDefaultValue(t){const e=t.map((t=>d(this,Cn,Ln).call(this,vn.from(t))));return new Pe(e,"_").defaultValue()}encode(t,e){O(e.length,t.length,"types/values length mismatch");const n=t.map((t=>d(this,Cn,Ln).call(this,vn.from(t)))),r=new Pe(n,"_"),s=new bt;return r.encode(s,e),s.data}decode(t,e,n){const r=t.map((t=>d(this,Cn,Ln).call(this,vn.from(t))));return new Pe(r,"_").decode(new vt(e,n,Fn))}static _setDefaultMaxInflation(t){N("number"==typeof t&&Number.isInteger(t),"invalid defaultMaxInflation factor","value",t),Fn=t}static defaultAbiCoder(){return null==_n&&(_n=new t),_n}static getBuiltinCallException(e,n,r){return function(t,e,n,r){let s="missing revert data",i=null,a=null;if(n){s="execution reverted";const t=T(n);if(n=I(n),0===t.length)s+=" (no data present; likely require(false) occurred",i="require(false)";else if(t.length%32!==4)s+=" (could not decode reason; invalid data length)";else if("0x08c379a0"===I(t.slice(0,4)))try{i=r.decode(["string"],t.slice(4))[0],a={signature:"Error(string)",name:"Error",args:[i]},s+=`: ${JSON.stringify(i)}`}catch{s+=" (could not decode reason; invalid string data)"}else if("0x4e487b71"===I(t.slice(0,4)))try{const e=Number(r.decode(["uint256"],t.slice(4))[0]);a={signature:"Panic(uint256)",name:"Panic",args:[e]},i=`Panic due to ${Un.get(e)||"UNKNOWN"}(${e})`,s+=`: ${i}`}catch{s+=" (could not decode panic code)"}else s+=" (unknown custom error)"}const o={to:e.to?ne(e.to):null,data:e.data||"0x"};return e.from&&(o.from=ne(e.from)),E(s,"CALL_EXCEPTION",{action:t,data:n,reason:i,transaction:o,invocation:null,revert:a})}(e,n,r,t.defaultAbiCoder())}};class jn{constructor(t,e,n){c(this,"fragment"),c(this,"name"),c(this,"signature"),c(this,"topic"),c(this,"args");const r=t.name,s=t.format();y(this,{fragment:t,name:r,signature:s,topic:e,args:n})}}class $n{constructor(t,e,n,r){c(this,"fragment"),c(this,"name"),c(this,"args"),c(this,"signature"),c(this,"selector"),c(this,"value");const s=t.name,i=t.format();y(this,{fragment:t,name:s,args:n,signature:i,selector:e,value:r})}}class Dn{constructor(t,e,n){c(this,"fragment"),c(this,"name"),c(this,"args"),c(this,"signature"),c(this,"selector");const r=t.name,s=t.format();y(this,{fragment:t,name:r,args:n,signature:s,selector:e})}}class Mn{constructor(t){c(this,"hash"),c(this,"_isIndexed"),y(this,{hash:t,_isIndexed:!0})}static isIndexed(t){return!(!t||!t._isIndexed)}}const Gn={0:"generic panic",1:"assert(false)",17:"arithmetic overflow",18:"division or modulo by zero",33:"enum overflow",34:"invalid encoded storage byte array accessed",49:"out-of-bounds array access; popping on an empty array",50:"out-of-bounds access of an array or bytesN",65:"out of memory",81:"uninitialized function"},Vn={"0x08c379a0":{signature:"Error(string)",name:"Error",inputs:["string"],reason:t=>`reverted with reason string ${JSON.stringify(t)}`},"0x4e487b71":{signature:"Panic(uint256)",name:"Panic",inputs:["uint256"],reason:t=>{let e="unknown panic code";return t>=0&&t<=255&&Gn[t.toString()]&&(e=Gn[t.toString()]),`reverted with panic code 0x${t.toString(16)} (${e})`}}};var Wn,Hn,zn,Jn,Kn,qn,Xn,Yn;Wn=new WeakMap,Hn=new WeakMap,zn=new WeakMap,Jn=new WeakMap,Kn=new WeakSet,qn=function(t,e,n){if(R(t)){const e=t.toLowerCase();for(const t of l(this,zn).values())if(e===t.selector)return t;return null}if(-1===t.indexOf("(")){const r=[];for(const[e,n]of l(this,zn))e.split("(")[0]===t&&r.push(n);if(e){const t=e.length>0?e[e.length-1]:null;let n=e.length,s=!0;he.isTyped(t)&&"overrides"===t.type&&(s=!1,n--);for(let e=r.length-1;e>=0;e--){const t=r[e].inputs.length;t!==n&&(!s||t!==n-1)&&r.splice(e,1)}for(let i=r.length-1;i>=0;i--){const t=r[i].inputs;for(let n=0;n<e.length;n++)if(he.isTyped(e[n])){if(n>=t.length){if("overrides"===e[n].type)continue;r.splice(i,1);break}if(e[n].type!==t[n].baseType){r.splice(i,1);break}}}}if(1===r.length&&e&&e.length!==r[0].inputs.length){const t=e[e.length-1];(null==t||Array.isArray(t)||"object"!=typeof t)&&r.splice(0,1)}if(0===r.length)return null;if(r.length>1&&n){N(!1,`ambiguous function description (i.e. matches ${r.map((t=>JSON.stringify(t.format()))).join(", ")})`,"key",t)}return r[0]}return l(this,zn).get(Pn.from(t).format())||null},Xn=new WeakSet,Yn=function(t,e,n){if(R(t)){const e=t.toLowerCase();for(const t of l(this,Hn).values())if(e===t.topicHash)return t;return null}if(-1===t.indexOf("(")){const r=[];for(const[e,n]of l(this,Hn))e.split("(")[0]===t&&r.push(n);if(e){for(let t=r.length-1;t>=0;t--)r[t].inputs.length<e.length&&r.splice(t,1);for(let t=r.length-1;t>=0;t--){const n=r[t].inputs;for(let s=0;s<e.length;s++)if(he.isTyped(e[s])&&e[s].type!==n[s].baseType){r.splice(t,1);break}}}if(0===r.length)return null;if(r.length>1&&n){N(!1,`ambiguous event description (i.e. matches ${r.map((t=>JSON.stringify(t.format()))).join(", ")})`,"key",t)}return r[0]}return l(this,Hn).get(An.from(t).format())||null};let Zn=class t{constructor(t){h(this,Kn),h(this,Xn),c(this,"fragments"),c(this,"deploy"),c(this,"fallback"),c(this,"receive"),h(this,Wn,void 0),h(this,Hn,void 0),h(this,zn,void 0),h(this,Jn,void 0);let e=[];e="string"==typeof t?JSON.parse(t):t,f(this,zn,new Map),f(this,Wn,new Map),f(this,Hn,new Map);const n=[];for(const a of e)try{n.push(En.from(a))}catch(i){console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`,i.message)}y(this,{fragments:Object.freeze(n)});let r=null,s=!1;f(this,Jn,this.getAbiCoder()),this.fragments.forEach(((t,e)=>{let n;switch(t.type){case"constructor":return this.deploy?void console.log("duplicate definition - constructor"):void y(this,{deploy:t});case"fallback":return void(0===t.inputs.length?s=!0:(N(!r||t.payable!==r.payable,"conflicting fallback fragments",`fragments[${e}]`,t),r=t,s=r.payable));case"function":n=l(this,zn);break;case"event":n=l(this,Hn);break;case"error":n=l(this,Wn);break;default:return}const i=t.format();n.has(i)||n.set(i,t)})),this.deploy||y(this,{deploy:xn.from("constructor()")}),y(this,{fallback:r,receive:s})}format(t){const e=t?"minimal":"full";return this.fragments.map((t=>t.format(e)))}formatJson(){const t=this.fragments.map((t=>t.format("json")));return JSON.stringify(t.map((t=>JSON.parse(t))))}getAbiCoder(){return Bn.defaultAbiCoder()}getFunctionName(t){const e=d(this,Kn,qn).call(this,t,null,!1);return N(e,"no matching function","key",t),e.name}hasFunction(t){return!!d(this,Kn,qn).call(this,t,null,!1)}getFunction(t,e){return d(this,Kn,qn).call(this,t,e||null,!0)}forEachFunction(t){const e=Array.from(l(this,zn).keys());e.sort(((t,e)=>t.localeCompare(e)));for(let n=0;n<e.length;n++){const r=e[n];t(l(this,zn).get(r),n)}}getEventName(t){const e=d(this,Xn,Yn).call(this,t,null,!1);return N(e,"no matching event","key",t),e.name}hasEvent(t){return!!d(this,Xn,Yn).call(this,t,null,!1)}getEvent(t,e){return d(this,Xn,Yn).call(this,t,e||null,!0)}forEachEvent(t){const e=Array.from(l(this,Hn).keys());e.sort(((t,e)=>t.localeCompare(e)));for(let n=0;n<e.length;n++){const r=e[n];t(l(this,Hn).get(r),n)}}getError(t,e){if(R(t)){const e=t.toLowerCase();if(Vn[e])return On.from(Vn[e].signature);for(const t of l(this,Wn).values())if(e===t.selector)return t;return null}if(-1===t.indexOf("(")){const e=[];for(const[n,r]of l(this,Wn))n.split("(")[0]===t&&e.push(r);if(0===e.length)return"Error"===t?On.from("error Error(string)"):"Panic"===t?On.from("error Panic(uint256)"):null;if(e.length>1){N(!1,`ambiguous error description (i.e. ${e.map((t=>JSON.stringify(t.format()))).join(", ")})`,"name",t)}return e[0]}if("Error(string)"===(t=On.from(t).format()))return On.from("error Error(string)");if("Panic(uint256)"===t)return On.from("error Panic(uint256)");return l(this,Wn).get(t)||null}forEachError(t){const e=Array.from(l(this,Wn).keys());e.sort(((t,e)=>t.localeCompare(e)));for(let n=0;n<e.length;n++){const r=e[n];t(l(this,Wn).get(r),n)}}_decodeParams(t,e){return l(this,Jn).decode(t,e)}_encodeParams(t,e){return l(this,Jn).encode(t,e)}encodeDeploy(t){return this._encodeParams(this.deploy.inputs,t||[])}decodeErrorResult(t,e){if("string"==typeof t){const e=this.getError(t);N(e,"unknown error","fragment",t),t=e}return N(_(e,0,4)===t.selector,`data signature does not match error ${t.name}.`,"data",e),this._decodeParams(t.inputs,_(e,4))}encodeErrorResult(t,e){if("string"==typeof t){const e=this.getError(t);N(e,"unknown error","fragment",t),t=e}return S([t.selector,this._encodeParams(t.inputs,e||[])])}decodeFunctionData(t,e){if("string"==typeof t){const e=this.getFunction(t);N(e,"unknown function","fragment",t),t=e}return N(_(e,0,4)===t.selector,`data signature does not match function ${t.name}.`,"data",e),this._decodeParams(t.inputs,_(e,4))}encodeFunctionData(t,e){if("string"==typeof t){const e=this.getFunction(t);N(e,"unknown function","fragment",t),t=e}return S([t.selector,this._encodeParams(t.inputs,e||[])])}decodeFunctionResult(t,e){if("string"==typeof t){const e=this.getFunction(t);N(e,"unknown function","fragment",t),t=e}let n="invalid length for result data";const r=P(e);if(r.length%32===0)try{return l(this,Jn).decode(t.outputs,r)}catch{n="could not decode result data"}k(!1,n,"BAD_DATA",{value:I(r),info:{method:t.name,signature:t.format()}})}makeError(t,e){const n=T(t,"data"),r=Bn.getBuiltinCallException("call",e,n);if(r.message.startsWith("execution reverted (unknown custom error)")){const t=I(n.slice(0,4)),e=this.getError(t);if(e)try{const t=l(this,Jn).decode(e.inputs,n.slice(4));r.revert={name:e.name,signature:e.format(),args:t},r.reason=r.revert.signature,r.message=`execution reverted: ${r.reason}`}catch{r.message="execution reverted (coult not decode custom error)"}}const s=this.parseTransaction(e);return s&&(r.invocation={method:s.name,signature:s.signature,args:s.args}),r}encodeFunctionResult(t,e){if("string"==typeof t){const e=this.getFunction(t);N(e,"unknown function","fragment",t),t=e}return I(l(this,Jn).encode(t.outputs,e||[]))}encodeFilterTopics(t,e){if("string"==typeof t){const e=this.getEvent(t);N(e,"unknown event","eventFragment",t),t=e}k(e.length<=t.inputs.length,`too many arguments for ${t.format()}`,"UNEXPECTED_ARGUMENT",{count:e.length,expectedCount:t.inputs.length});const n=[];t.anonymous||n.push(t.topicHash);const r=(t,e)=>"string"===t.type?Re(e):"bytes"===t.type?qt(I(e)):("bool"===t.type&&"boolean"==typeof e?e=e?"0x01":"0x00":t.type.match(/^u?int/)?e=W(e):t.type.match(/^bytes/)?e=function(t,e){return F(t,e,!1)}(e,32):"address"===t.type&&l(this,Jn).encode(["address"],[e]),function(t,e){return F(t,e,!0)}(I(e),32));for(e.forEach(((e,s)=>{const i=t.inputs[s];i.indexed?null==e?n.push(null):"array"===i.baseType||"tuple"===i.baseType?N(!1,"filtering with tuples or arrays not supported","contract."+i.name,e):Array.isArray(e)?n.push(e.map((t=>r(i,t)))):n.push(r(i,e)):N(null==e,"cannot filter non-indexed parameters; must be null","contract."+i.name,e)}));n.length&&null===n[n.length-1];)n.pop();return n}encodeEventLog(t,e){if("string"==typeof t){const e=this.getEvent(t);N(e,"unknown event","eventFragment",t),t=e}const n=[],r=[],s=[];return t.anonymous||n.push(t.topicHash),N(e.length===t.inputs.length,"event arguments/values mismatch","values",e),t.inputs.forEach(((t,i)=>{const a=e[i];if(t.indexed)if("string"===t.type)n.push(Re(a));else if("bytes"===t.type)n.push(qt(a));else{if("tuple"===t.baseType||"array"===t.baseType)throw new Error("not implemented");n.push(l(this,Jn).encode([t.type],[a]))}else r.push(t),s.push(a)})),{data:l(this,Jn).encode(r,s),topics:n}}decodeEventLog(t,e,n){if("string"==typeof t){const e=this.getEvent(t);N(e,"unknown event","eventFragment",t),t=e}if(null!=n&&!t.anonymous){const e=t.topicHash;N(R(n[0],32)&&n[0].toLowerCase()===e,"fragment/topic mismatch","topics[0]",n[0]),n=n.slice(1)}const r=[],s=[],i=[];t.inputs.forEach(((t,e)=>{t.indexed?"string"===t.type||"bytes"===t.type||"tuple"===t.baseType||"array"===t.baseType?(r.push(vn.from({type:"bytes32",name:t.name})),i.push(!0)):(r.push(t),i.push(!1)):(s.push(t),i.push(!1))}));const a=null!=n?l(this,Jn).decode(r,S(n)):null,o=l(this,Jn).decode(s,e,!0),c=[],u=[];let h=0,f=0;return t.inputs.forEach(((t,e)=>{let n=null;if(t.indexed)if(null==a)n=new Mn(null);else if(i[e])n=new Mn(a[f++]);else try{n=a[f++]}catch(r){n=r}else try{n=o[h++]}catch(r){n=r}c.push(n),u.push(t.name||null)})),rt.fromItems(c,u)}parseTransaction(t){const e=T(t.data,"tx.data"),n=$(null!=t.value?t.value:0,"tx.value"),r=this.getFunction(I(e.slice(0,4)));if(!r)return null;const s=l(this,Jn).decode(r.inputs,e.slice(4));return new $n(r,r.selector,s,n)}parseCallResult(t){throw new Error("@TODO")}parseLog(t){const e=this.getEvent(t.topics[0]);return!e||e.anonymous?null:new jn(e,e.topicHash,this.decodeEventLog(e,t.data,t.topics))}parseError(t){const e=I(t),n=this.getError(_(e,0,4));if(!n)return null;const r=l(this,Jn).decode(n.inputs,_(e,4));return new Dn(n,n.selector,r)}static from(e){return e instanceof t?e:"string"==typeof e?new t(JSON.parse(e)):"function"==typeof e.formatJson?new t(e.formatJson()):"function"==typeof e.format?new t(e.format("json")):new t(e)}};const Qn=BigInt(0);function tr(t){return null==t?null:t.toString()}function er(t){const e={};t.to&&(e.to=t.to),t.from&&(e.from=t.from),t.data&&(e.data=I(t.data));const n="chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);for(const s of n)!(s in t)||null==t[s]||(e[s]=$(t[s],`request.${s}`));const r="type,nonce".split(/,/);for(const s of r)!(s in t)||null==t[s]||(e[s]=V(t[s],`request.${s}`));return t.accessList&&(e.accessList=function(t){if(Array.isArray(t))return t.map(((e,n)=>Array.isArray(e)?(N(2===e.length,"invalid slot set",`value[${n}]`,e),Ue(e[0],e[1])):(N(null!=e&&"object"==typeof e,"invalid address-slot set","value",t),Ue(e.address,e.storageKeys))));N(null!=t&&"object"==typeof t,"invalid access list","value",t);const e=Object.keys(t).map((e=>{const n=t[e].reduce(((t,e)=>(t[e]=!0,t)),{});return Ue(e,Object.keys(n).sort())}));return e.sort(((t,e)=>t.address.localeCompare(e.address))),e}(t.accessList)),"blockTag"in t&&(e.blockTag=t.blockTag),"enableCcipRead"in t&&(e.enableCcipRead=!!t.enableCcipRead),"customData"in t&&(e.customData=t.customData),"blobVersionedHashes"in t&&t.blobVersionedHashes&&(e.blobVersionedHashes=t.blobVersionedHashes.slice()),"kzg"in t&&(e.kzg=t.kzg),"blobs"in t&&t.blobs&&(e.blobs=t.blobs.map((t=>function(t){return R(t,!0)||t instanceof Uint8Array}(t)?I(t):Object.assign({},t)))),e}class nr{constructor(t,e){c(this,"provider"),c(this,"transactionHash"),c(this,"blockHash"),c(this,"blockNumber"),c(this,"removed"),c(this,"address"),c(this,"data"),c(this,"topics"),c(this,"index"),c(this,"transactionIndex"),this.provider=e;const n=Object.freeze(t.topics.slice());y(this,{transactionHash:t.transactionHash,blockHash:t.blockHash,blockNumber:t.blockNumber,removed:t.removed,address:t.address,data:t.data,topics:n,index:t.index,transactionIndex:t.transactionIndex})}toJSON(){const{address:t,blockHash:e,blockNumber:n,data:r,index:s,removed:i,topics:a,transactionHash:o,transactionIndex:c}=this;return{_type:"log",address:t,blockHash:e,blockNumber:n,data:r,index:s,removed:i,topics:a,transactionHash:o,transactionIndex:c}}async getBlock(){const t=await this.provider.getBlock(this.blockHash);return k(!!t,"failed to find transaction","UNKNOWN_ERROR",{}),t}async getTransaction(){const t=await this.provider.getTransaction(this.transactionHash);return k(!!t,"failed to find transaction","UNKNOWN_ERROR",{}),t}async getTransactionReceipt(){const t=await this.provider.getTransactionReceipt(this.transactionHash);return k(!!t,"failed to find transaction receipt","UNKNOWN_ERROR",{}),t}removedEvent(){return{orphan:"drop-log",log:{transactionHash:(t=this).transactionHash,blockHash:t.blockHash,blockNumber:t.blockNumber,address:t.address,data:t.data,topics:Object.freeze(t.topics.slice()),index:t.index}};var t}}var rr,sr;class ir{constructor(t,e){c(this,"provider"),c(this,"to"),c(this,"from"),c(this,"contractAddress"),c(this,"hash"),c(this,"index"),c(this,"blockHash"),c(this,"blockNumber"),c(this,"logsBloom"),c(this,"gasUsed"),c(this,"blobGasUsed"),c(this,"cumulativeGasUsed"),c(this,"gasPrice"),c(this,"blobGasPrice"),c(this,"type"),c(this,"status"),c(this,"root"),h(this,rr,void 0),f(this,rr,Object.freeze(t.logs.map((t=>new nr(t,e)))));let n=Qn;null!=t.effectiveGasPrice?n=t.effectiveGasPrice:null!=t.gasPrice&&(n=t.gasPrice),y(this,{provider:e,to:t.to,from:t.from,contractAddress:t.contractAddress,hash:t.hash,index:t.index,blockHash:t.blockHash,blockNumber:t.blockNumber,logsBloom:t.logsBloom,gasUsed:t.gasUsed,cumulativeGasUsed:t.cumulativeGasUsed,blobGasUsed:t.blobGasUsed,gasPrice:n,blobGasPrice:t.blobGasPrice,type:t.type,status:t.status,root:t.root})}get logs(){return l(this,rr)}toJSON(){const{to:t,from:e,contractAddress:n,hash:r,index:s,blockHash:i,blockNumber:a,logsBloom:o,logs:c,status:u,root:l}=this;return{_type:"TransactionReceipt",blockHash:i,blockNumber:a,contractAddress:n,cumulativeGasUsed:tr(this.cumulativeGasUsed),from:e,gasPrice:tr(this.gasPrice),blobGasUsed:tr(this.blobGasUsed),blobGasPrice:tr(this.blobGasPrice),gasUsed:tr(this.gasUsed),hash:r,index:s,logs:c,logsBloom:o,root:l,status:u,to:t}}get length(){return this.logs.length}[Symbol.iterator](){let t=0;return{next:()=>t<this.length?{value:this.logs[t++],done:!1}:{value:void 0,done:!0}}}get fee(){return this.gasUsed*this.gasPrice}async getBlock(){const t=await this.provider.getBlock(this.blockHash);if(null==t)throw new Error("TODO");return t}async getTransaction(){const t=await this.provider.getTransaction(this.hash);if(null==t)throw new Error("TODO");return t}async getResult(){return await this.provider.getTransactionResult(this.hash)}async confirmations(){return await this.provider.getBlockNumber()-this.blockNumber+1}removedEvent(){return cr(this)}reorderedEvent(t){return k(!t||t.isMined(),"unmined 'other' transction cannot be orphaned","UNSUPPORTED_OPERATION",{operation:"reorderedEvent(other)"}),or(this,t)}}rr=new WeakMap;sr=new WeakMap;let ar=class t{constructor(t,e){c(this,"provider"),c(this,"blockNumber"),c(this,"blockHash"),c(this,"index"),c(this,"hash"),c(this,"type"),c(this,"to"),c(this,"from"),c(this,"nonce"),c(this,"gasLimit"),c(this,"gasPrice"),c(this,"maxPriorityFeePerGas"),c(this,"maxFeePerGas"),c(this,"maxFeePerBlobGas"),c(this,"data"),c(this,"value"),c(this,"chainId"),c(this,"signature"),c(this,"accessList"),c(this,"blobVersionedHashes"),h(this,sr,void 0),this.provider=e,this.blockNumber=null!=t.blockNumber?t.blockNumber:null,this.blockHash=null!=t.blockHash?t.blockHash:null,this.hash=t.hash,this.index=t.index,this.type=t.type,this.from=t.from,this.to=t.to||null,this.gasLimit=t.gasLimit,this.nonce=t.nonce,this.data=t.data,this.value=t.value,this.gasPrice=t.gasPrice,this.maxPriorityFeePerGas=null!=t.maxPriorityFeePerGas?t.maxPriorityFeePerGas:null,this.maxFeePerGas=null!=t.maxFeePerGas?t.maxFeePerGas:null,this.maxFeePerBlobGas=null!=t.maxFeePerBlobGas?t.maxFeePerBlobGas:null,this.chainId=t.chainId,this.signature=t.signature,this.accessList=null!=t.accessList?t.accessList:null,this.blobVersionedHashes=null!=t.blobVersionedHashes?t.blobVersionedHashes:null,f(this,sr,-1)}toJSON(){const{blockNumber:t,blockHash:e,index:n,hash:r,type:s,to:i,from:a,nonce:o,data:c,signature:u,accessList:l,blobVersionedHashes:h}=this;return{_type:"TransactionResponse",accessList:l,blockNumber:t,blockHash:e,blobVersionedHashes:h,chainId:tr(this.chainId),data:c,from:a,gasLimit:tr(this.gasLimit),gasPrice:tr(this.gasPrice),hash:r,maxFeePerGas:tr(this.maxFeePerGas),maxPriorityFeePerGas:tr(this.maxPriorityFeePerGas),maxFeePerBlobGas:tr(this.maxFeePerBlobGas),nonce:o,signature:u,to:i,index:n,type:s,value:tr(this.value)}}async getBlock(){let t=this.blockNumber;if(null==t){const e=await this.getTransaction();e&&(t=e.blockNumber)}if(null==t)return null;const e=this.provider.getBlock(t);if(null==e)throw new Error("TODO");return e}async getTransaction(){return this.provider.getTransaction(this.hash)}async confirmations(){if(null==this.blockNumber){const{tx:t,blockNumber:e}=await m({tx:this.getTransaction(),blockNumber:this.provider.getBlockNumber()});return null==t||null==t.blockNumber?0:e-t.blockNumber+1}return await this.provider.getBlockNumber()-this.blockNumber+1}async wait(t,e){const n=t??1,r=e??0;let s=l(this,sr),i=-1,a=-1===s;const o=async()=>{if(a)return null;const{blockNumber:t,nonce:e}=await m({blockNumber:this.provider.getBlockNumber(),nonce:this.provider.getTransactionCount(this.from)});if(e<this.nonce)return void(s=t);if(a)return null;const r=await this.getTransaction();if(!r||null==r.blockNumber)for(-1===i&&(i=s-3,i<l(this,sr)&&(i=l(this,sr)));i<=t;){if(a)return null;const e=await this.provider.getBlock(i,!0);if(null==e)return;for(const t of e)if(t===this.hash)return;for(let r=0;r<e.length;r++){const i=await e.getTransaction(r);if(i.from===this.from&&i.nonce===this.nonce){if(a)return null;const e=await this.provider.getTransactionReceipt(i.hash);if(null==e||t-e.blockNumber+1<n)return;let r="replaced";i.data===this.data&&i.to===this.to&&i.value===this.value?r="repriced":"0x"===i.data&&i.from===i.to&&i.value===Qn&&(r="cancelled"),k(!1,"transaction was replaced","TRANSACTION_REPLACED",{cancelled:"replaced"===r||"cancelled"===r,reason:r,replacement:i.replaceableTransaction(s),hash:i.hash,receipt:e})}}i++}},c=t=>{if(null==t||0!==t.status)return t;k(!1,"transaction execution reverted","CALL_EXCEPTION",{action:"sendTransaction",data:null,reason:null,invocation:null,revert:null,transaction:{to:t.to,from:t.from,data:""},receipt:t})},u=await this.provider.getTransactionReceipt(this.hash);if(0===n)return c(u);if(u){if(await u.confirmations()>=n)return c(u)}else if(await o(),0===n)return null;return await new Promise(((t,e)=>{const i=[],u=()=>{i.forEach((t=>t()))};if(i.push((()=>{a=!0})),r>0){const t=setTimeout((()=>{u(),e(E("wait for transaction timeout","TIMEOUT"))}),r);i.push((()=>{clearTimeout(t)}))}const l=async r=>{if(await r.confirmations()>=n){u();try{t(c(r))}catch(s){e(s)}}};if(i.push((()=>{this.provider.off(this.hash,l)})),this.provider.on(this.hash,l),s>=0){const t=async()=>{try{await o()}catch(n){if(b(n,"TRANSACTION_REPLACED"))return u(),void e(n)}a||this.provider.once("block",t)};i.push((()=>{this.provider.off("block",t)})),this.provider.once("block",t)}}))}isMined(){return null!=this.blockHash}isLegacy(){return 0===this.type}isBerlin(){return 1===this.type}isLondon(){return 2===this.type}isCancun(){return 3===this.type}removedEvent(){return k(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),cr(this)}reorderedEvent(t){return k(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),k(!t||t.isMined(),"unmined 'other' transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),or(this,t)}replaceableTransaction(e){N(Number.isInteger(e)&&e>=0,"invalid startBlock","startBlock",e);const n=new t(this,this.provider);return f(n,sr,e),n}};function or(t,e){return{orphan:"reorder-transaction",tx:t,other:e}}function cr(t){return{orphan:"drop-transaction",tx:t}}class ur extends nr{constructor(t,e,n){super(t,t.provider),c(this,"interface"),c(this,"fragment"),c(this,"args");y(this,{args:e.decodeEventLog(n,t.data,t.topics),fragment:n,interface:e})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}}class lr extends nr{constructor(t,e){super(t,t.provider),c(this,"error"),y(this,{error:e})}}var hr,fr;class dr extends ir{constructor(t,e,n){super(n,e),h(this,hr,void 0),f(this,hr,t)}get logs(){return super.logs.map((t=>{const e=t.topics.length?l(this,hr).getEvent(t.topics[0]):null;if(e)try{return new ur(t,l(this,hr),e)}catch(n){return new lr(t,n)}return t}))}}hr=new WeakMap;class pr extends ar{constructor(t,e,n){super(n,e),h(this,fr,void 0),f(this,fr,t)}async wait(t,e){const n=await super.wait(t,e);return null==n?null:new dr(l(this,fr),this.provider,n)}}fr=new WeakMap;class gr extends z{constructor(t,e,n,r){super(t,e,n),c(this,"log"),y(this,{log:r})}async getBlock(){return await this.log.getBlock()}async getTransaction(){return await this.log.getTransaction()}async getTransactionReceipt(){return await this.log.getTransactionReceipt()}}class mr extends gr{constructor(t,e,n,r,s){super(t,e,n,new ur(s,t.interface,r));y(this,{args:t.interface.decodeEventLog(r,this.log.data,this.log.topics),fragment:r})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}}const yr=BigInt(0);function wr(t){return t&&"function"==typeof t.call}function br(t){return t&&"function"==typeof t.estimateGas}function vr(t){return t&&"function"==typeof t.resolveName}function Er(t){return t&&"function"==typeof t.sendTransaction}function kr(t){if(null!=t){if(vr(t))return t;if(t.provider)return t.provider}}var Nr;class Or{constructor(t,e,n){if(h(this,Nr,void 0),c(this,"fragment"),y(this,{fragment:e}),e.inputs.length<n.length)throw new Error("too many arguments");const r=Ar(t.runner,"resolveName"),s=vr(r)?r:null;f(this,Nr,async function(){const r=await Promise.all(e.inputs.map(((t,e)=>null==n[e]?null:t.walkAsync(n[e],((t,e)=>"address"===t?Array.isArray(e)?Promise.all(e.map((t=>ie(t,s)))):ie(e,s):e)))));return t.interface.encodeFilterTopics(e,r)}())}getTopicFilter(){return l(this,Nr)}}function Ar(t,e){return null==t?null:"function"==typeof t[e]?t:t.provider&&"function"==typeof t.provider[e]?t.provider:null}function xr(t){return null==t?null:t.provider||null}async function Tr(t,e){const n=he.dereference(t,"overrides");N("object"==typeof n,"invalid overrides parameter","overrides",t);const r=er(n);return N(null==r.to||(e||[]).indexOf("to")>=0,"cannot override to","overrides.to",r.to),N(null==r.data||(e||[]).indexOf("data")>=0,"cannot override data","overrides.data",r.data),r.from&&(r.from=r.from),r}function Pr(t){const e=async function(e){const n=await Tr(e,["data"]);n.to=await t.getAddress(),n.from&&(n.from=await ie(n.from,kr(t.runner)));const r=t.interface,s=$(n.value||yr,"overrides.value")===yr,i="0x"===(n.data||"0x");r.fallback&&!r.fallback.payable&&r.receive&&!i&&!s&&N(!1,"cannot send data to receive or send value to non-payable fallback","overrides",e),N(r.fallback||i,"cannot send data to receive-only contract","overrides.data",n.data);return N(r.receive||r.fallback&&r.fallback.payable||s,"cannot send value to non-payable fallback","overrides.value",n.value),N(r.fallback||i,"cannot send data to receive-only contract","overrides.data",n.data),n},n=async function(n){const r=t.runner;k(Er(r),"contract runner does not support sending transactions","UNSUPPORTED_OPERATION",{operation:"sendTransaction"});const s=await r.sendTransaction(await e(n)),i=xr(t.runner);return new pr(t.interface,i,s)},r=async t=>await n(t);return y(r,{_contract:t,estimateGas:async function(n){const r=Ar(t.runner,"estimateGas");return k(br(r),"contract runner does not support gas estimation","UNSUPPORTED_OPERATION",{operation:"estimateGas"}),await r.estimateGas(await e(n))},populateTransaction:e,send:n,staticCall:async function(n){const r=Ar(t.runner,"call");k(wr(r),"contract runner does not support calling","UNSUPPORTED_OPERATION",{operation:"call"});const s=await e(n);try{return await r.call(s)}catch(i){throw v(i)&&i.data?t.interface.makeError(i.data,s):i}}}),r}function Rr(t,e){const n=function(){for(var n=arguments.length,r=new Array(n),s=0;s<n;s++)r[s]=arguments[s];const i=t.interface.getFunction(e,r);return k(i,"no matching fragment","UNSUPPORTED_OPERATION",{operation:"fragment",info:{key:e,args:r}}),i},r=async function(){for(var e=arguments.length,r=new Array(e),s=0;s<e;s++)r[s]=arguments[s];const i=n(...r);let a={};if(i.inputs.length+1===r.length&&(a=await Tr(r.pop()),a.from&&(a.from=await ie(a.from,kr(t.runner)))),i.inputs.length!==r.length)throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");const o=await async function(t,e,n){const r=Ar(t,"resolveName"),s=vr(r)?r:null;return await Promise.all(e.map(((t,e)=>t.walkAsync(n[e],((t,e)=>(e=he.dereference(e,t),"address"===t?ie(e,s):e))))))}(t.runner,i.inputs,r);return Object.assign({},a,await m({to:t.getAddress(),data:t.interface.encodeFunctionData(i,o)}))},s=async function(){const t=await a(...arguments);return 1===t.length?t[0]:t},i=async function(){const e=t.runner;k(Er(e),"contract runner does not support sending transactions","UNSUPPORTED_OPERATION",{operation:"sendTransaction"});const n=await e.sendTransaction(await r(...arguments)),s=xr(t.runner);return new pr(t.interface,s,n)},a=async function(){const e=Ar(t.runner,"call");k(wr(e),"contract runner does not support calling","UNSUPPORTED_OPERATION",{operation:"call"});const s=await r(...arguments);let i="0x";try{i=await e.call(s)}catch(o){throw v(o)&&o.data?t.interface.makeError(o.data,s):o}const a=n(...arguments);return t.interface.decodeFunctionResult(a,i)},o=async function(){return n(...arguments).constant?await s(...arguments):await i(...arguments)};return y(o,{name:t.interface.getFunctionName(e),_contract:t,_key:e,getFragment:n,estimateGas:async function(){const e=Ar(t.runner,"estimateGas");return k(br(e),"contract runner does not support gas estimation","UNSUPPORTED_OPERATION",{operation:"estimateGas"}),await e.estimateGas(await r(...arguments))},populateTransaction:r,send:i,staticCall:s,staticCallResult:a}),Object.defineProperty(o,"fragment",{configurable:!1,enumerable:!0,get:()=>{const n=t.interface.getFunction(e);return k(n,"no matching fragment","UNSUPPORTED_OPERATION",{operation:"fragment",info:{key:e}}),n}}),o}Nr=new WeakMap;const Ur=Symbol.for("_ethersInternal_contract"),Ir=new WeakMap;function Sr(t){return Ir.get(t[Ur])}async function _r(t,e){let n,r=null;if(Array.isArray(e)){const r=function(e){if(R(e,32))return e;const n=t.interface.getEvent(e);return N(n,"unknown fragment","name",e),n.topicHash};n=e.map((t=>null==t?null:Array.isArray(t)?t.map(r):r(t)))}else"*"===e?n=[null]:"string"==typeof e?R(e,32)?n=[e]:(r=t.interface.getEvent(e),N(r,"unknown fragment","event",e),n=[r.topicHash]):function(t){return t&&"object"==typeof t&&"getTopicFilter"in t&&"function"==typeof t.getTopicFilter&&t.fragment}(e)?n=await e.getTopicFilter():"fragment"in e?(r=e.fragment,n=[r.topicHash]):N(!1,"unknown event name","event",e);n=n.map((t=>{if(null==t)return null;if(Array.isArray(t)){const e=Array.from(new Set(t.map((t=>t.toLowerCase()))).values());return 1===e.length?e[0]:(e.sort(),e)}return t.toLowerCase()}));return{fragment:r,tag:n.map((t=>null==t?"null":Array.isArray(t)?t.join("|"):t)).join("&"),topics:n}}async function Fr(t,e){const{subs:n}=Sr(t);return n.get((await _r(t,e)).tag)||null}async function Cr(t,e,n){const r=xr(t.runner);k(r,"contract runner does not support subscribing","UNSUPPORTED_OPERATION",{operation:e});const{fragment:s,tag:i,topics:a}=await _r(t,n),{addr:o,subs:c}=Sr(t);let u=c.get(i);if(!u){const e={address:o||t,topics:a},l=e=>{let r=s;if(null==r)try{r=t.interface.getEvent(e.topics[0])}catch{}if(r){const i=r,a=s?t.interface.decodeEventLog(s,e.data,e.topics):[];Br(t,n,a,(r=>new mr(t,r,n,i,e)))}else Br(t,n,[],(r=>new gr(t,r,n,e)))};let h=[];u={tag:i,listeners:[],start:()=>{h.length||h.push(r.on(e,l))},stop:async()=>{if(0==h.length)return;let t=h;h=[],await Promise.all(t),r.off(e,l)}},c.set(i,u)}return u}let Lr=Promise.resolve();async function Br(t,e,n,r){try{await Lr}catch{}const s=async function(t,e,n,r){await Lr;const s=await Fr(t,e);if(!s)return!1;const i=s.listeners.length;return s.listeners=s.listeners.filter((e=>{let{listener:s,once:i}=e;const a=Array.from(n);r&&a.push(r(i?null:s));try{s.call(t,...a)}catch{}return!i})),0===s.listeners.length&&(s.stop(),Sr(t).subs.delete(s.tag)),i>0}(t,e,n,r);return Lr=s,await s}const jr=["then"];var $r;$r=Ur;let Dr=class t{constructor(t,e,n,r){c(this,"target"),c(this,"interface"),c(this,"runner"),c(this,"filters"),c(this,$r),c(this,"fallback"),N("string"==typeof t||re(t),"invalid value for Contract target","target",t),null==n&&(n=null);const s=Zn.from(e);y(this,{target:t,runner:n,interface:s}),Object.defineProperty(this,Ur,{value:{}});let i,a=null,o=null;if(r){const t=xr(n);o=new pr(this.interface,t,r)}let u=new Map;if("string"==typeof t)if(R(t))a=t,i=Promise.resolve(t);else{const e=Ar(n,"resolveName");if(!vr(e))throw E("contract runner does not support name resolution","UNSUPPORTED_OPERATION",{operation:"resolveName"});i=e.resolveName(t).then((e=>{if(null==e)throw E("an ENS name used for a contract target must be correctly configured","UNCONFIGURED_NAME",{value:t});return Sr(this).addr=e,e}))}else i=t.getAddress().then((t=>{if(null==t)throw new Error("TODO");return Sr(this).addr=t,t}));!function(t,e){Ir.set(t[Ur],e)}(this,{addrPromise:i,addr:a,deployTx:o,subs:u});return y(this,{filters:new Proxy({},{get:(t,e,n)=>{if("symbol"==typeof e||jr.indexOf(e)>=0)return Reflect.get(t,e,n);try{return this.getEvent(e)}catch(r){if(!b(r,"INVALID_ARGUMENT")||"key"!==r.argument)throw r}},has:(t,e)=>jr.indexOf(e)>=0?Reflect.has(t,e):Reflect.has(t,e)||this.interface.hasEvent(String(e))})}),y(this,{fallback:s.receive||s.fallback?Pr(this):null}),new Proxy(this,{get:(t,e,n)=>{if("symbol"==typeof e||e in t||jr.indexOf(e)>=0)return Reflect.get(t,e,n);try{return t.getFunction(e)}catch(r){if(!b(r,"INVALID_ARGUMENT")||"key"!==r.argument)throw r}},has:(t,e)=>"symbol"==typeof e||e in t||jr.indexOf(e)>=0?Reflect.has(t,e):t.interface.hasFunction(e)})}connect(e){return new t(this.target,this.interface,e)}attach(e){return new t(e,this.interface,this.runner)}async getAddress(){return await Sr(this).addrPromise}async getDeployedCode(){const t=xr(this.runner);k(t,"runner does not support .provider","UNSUPPORTED_OPERATION",{operation:"getDeployedCode"});const e=await t.getCode(await this.getAddress());return"0x"===e?null:e}async waitForDeployment(){const t=this.deploymentTransaction();if(t)return await t.wait(),this;if(null!=await this.getDeployedCode())return this;const e=xr(this.runner);return k(null!=e,"contract runner does not support .provider","UNSUPPORTED_OPERATION",{operation:"waitForDeployment"}),new Promise(((t,n)=>{const r=async()=>{try{if(null!=await this.getDeployedCode())return t(this);e.once("block",r)}catch(s){n(s)}};r()}))}deploymentTransaction(){return Sr(this).deployTx}getFunction(t){return"string"!=typeof t&&(t=t.format()),Rr(this,t)}getEvent(t){return"string"!=typeof t&&(t=t.format()),function(t,e){const n=function(){for(var n=arguments.length,r=new Array(n),s=0;s<n;s++)r[s]=arguments[s];const i=t.interface.getEvent(e,r);return k(i,"no matching fragment","UNSUPPORTED_OPERATION",{operation:"fragment",info:{key:e,args:r}}),i},r=function(){for(var e=arguments.length,r=new Array(e),s=0;s<e;s++)r[s]=arguments[s];return new Or(t,n(...r),r)};return y(r,{name:t.interface.getEventName(e),_contract:t,_key:e,getFragment:n}),Object.defineProperty(r,"fragment",{configurable:!1,enumerable:!0,get:()=>{const n=t.interface.getEvent(e);return k(n,"no matching fragment","UNSUPPORTED_OPERATION",{operation:"fragment",info:{key:e}}),n}}),r}(this,t)}async queryTransaction(t){throw new Error("@TODO")}async queryFilter(t,e,n){null==e&&(e=0),null==n&&(n="latest");const{addr:r,addrPromise:s}=Sr(this),i=r||await s,{fragment:a,topics:o}=await _r(this,t),c={address:i,topics:o,fromBlock:e,toBlock:n},u=xr(this.runner);return k(u,"contract runner does not have a provider","UNSUPPORTED_OPERATION",{operation:"queryFilter"}),(await u.getLogs(c)).map((t=>{let e=a;if(null==e)try{e=this.interface.getEvent(t.topics[0])}catch{}if(e)try{return new ur(t,this.interface,e)}catch(n){return new lr(t,n)}return new nr(t,u)}))}async on(t,e){const n=await Cr(this,"on",t);return n.listeners.push({listener:e,once:!1}),n.start(),this}async once(t,e){const n=await Cr(this,"once",t);return n.listeners.push({listener:e,once:!0}),n.start(),this}async emit(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return await Br(this,t,n,null)}async listenerCount(t){if(t){const e=await Fr(this,t);return e?e.listeners.length:0}const{subs:e}=Sr(this);let n=0;for(const{listeners:r}of e.values())n+=r.length;return n}async listeners(t){if(t){const e=await Fr(this,t);return e?e.listeners.map((t=>{let{listener:e}=t;return e})):[]}const{subs:e}=Sr(this);let n=[];for(const{listeners:r}of e.values())n=n.concat(r.map((t=>{let{listener:e}=t;return e})));return n}async off(t,e){const n=await Fr(this,t);if(!n)return this;if(e){const t=n.listeners.map((t=>{let{listener:e}=t;return e})).indexOf(e);t>=0&&n.listeners.splice(t,1)}return(null==e||0===n.listeners.length)&&(n.stop(),Sr(this).subs.delete(n.tag)),this}async removeAllListeners(t){if(t){const e=await Fr(this,t);if(!e)return this;e.stop(),Sr(this).subs.delete(e.tag)}else{const{subs:t}=Sr(this);for(const{tag:e,stop:n}of t.values())n(),t.delete(e)}return this}async addListener(t,e){return await this.on(t,e)}async removeListener(t,e){return await this.off(t,e)}static buildClass(e){return class extends t{constructor(t){super(t,e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:null)}}}static from(t,e,n){return null==n&&(n=null),new this(t,e,n)}};class Mr extends(function(){return Dr}()){}const Gr=new Zn(["function start((bytes32,address,address,address,address,address,uint256,uint256,uint256,uint256)) returns (address,uint16,uint64)","function receiveMessageAndSwap(bytes)"]),Vr=new Zn(["function quoteExactInputSingle((address,address,uint256,uint24,uint160)) public view returns (uint256,uint160,uint32,uint256)"]),Wr=100;class Hr{static async createOrder(t,e,n,s,i,a,o,c){var u,l;try{const{minAmountStart:u,minAmountFinish:l}=o.swapAmounts,h=(0,r.ch)(n),[f,d]=(0,r.cr)(t,e,s),[p,g]=(0,r.cr)(t,n.chain,a),m=(0,r.ch)(d),y=(0,r.ch)(g),w=r.cs.get(t,e).portico,b=r.cs.get(t,n.chain).portico,v=r.c3.get(t,e),E=r.c3.get(t,n.chain),k={startingChainId:Number(v),startingToken:m.toLowerCase(),destinationChainId:Number(E),destinationToken:y.toLowerCase(),destinationAddress:h,porticoAddress:w,destinationPorticoAddress:b,startingTokenAmount:i.toString(),minAmountStart:u.toString(),minAmountEnd:l.toString(),bridgeNonce:c,relayerFee:o.relayerFee.toString(),feeTierStart:Wr,feeTierEnd:Wr,shouldWrapNative:f,shouldUnwrapNative:p},N=await r.ct.post("https://thermae.fly.dev/api/order/create",k);return this.validateCreateOrderResponse(N.data,k),N.data}catch(h){if(r.ct.isAxiosError(h)){const t=`${null==(u=h.response)?void 0:u.statusText}: ${null==(l=h.response)?void 0:l.data.message}`;throw new Error(`Could not create order: ${t},`)}throw h}}static async quoteRelayer(t,e,n){var s;if((0,r.ax)(e)||(0,r.ax)(n))throw new Error("how did you get here tho?");const i=r.ar.encode(e.toUniversalAddress().toUint8Array(),!1),a=r.ar.encode(n.toUniversalAddress().toUint8Array(),!1),o={targetChain:(0,r.bW)(t),sourceToken:i,targetToken:a};try{const t=await r.ct.post("https://gfx.relayers.xlabs.xyz/api/v1/swap/quote",o);return BigInt(t.data.fee)}catch(c){throw r.ct.isAxiosError(c)?new Error(`Error getting relayer fee: ${null==(s=c.response)?void 0:s.statusText}`):c}}}c(Hr,"validateCreateOrderResponse",((t,e)=>{if(!(0,r.cu)(e.porticoAddress||"",t.transactionTarget))throw new Error("portico address mismatch");const n=Gr.decodeFunctionData("start",t.transactionData);if(1!==n.length||10!==n[0].length)throw new Error("decoded length mismatch");const s=r.ar.decode(n[0][0]);if(32!==s.length)throw new Error("flag set length mismatch");const{recipientChain:i,feeTierStart:a,feeTierFinish:o,flags:c}=r.cv.deserializeFlagSet(s),{shouldWrapNative:u,shouldUnwrapNative:l}=c,[h,f]=(0,r.az)("Evm",BigInt(e.destinationChainId));if(i!==(0,r.bW)(f))throw new Error("recipient chain mismatch");if(a!==e.feeTierStart)throw new Error("fee tier start mismatch");if(o!==e.feeTierEnd)throw new Error("fee tier end mismatch");if(!!u!==e.shouldWrapNative)throw new Error("should wrap native mismatch");if(!!l!==e.shouldUnwrapNative)throw new Error("should unwrap native mismatch");const d=n[0][1];if(!(0,r.cu)(d,e.startingToken))throw new Error("start token address mismatch");const p=n[0][3];if(!(0,r.cu)(p,e.destinationToken))throw new Error("final token address mismatch");const g=n[0][4];if(!(0,r.cu)(g,e.destinationAddress))throw new Error("recipient address mismatch");const m=n[0][5];if(!(0,r.cu)(m,e.destinationPorticoAddress||""))throw new Error("destination portico address mismatch");if(n[0][6].toString()!==e.startingTokenAmount)throw new Error("amount mismatch");if(n[0][7].toString()!==e.minAmountStart)throw new Error("min amount start mismatch");if(n[0][8].toString()!==e.minAmountEnd)throw new Error("min amount finish mismatch");if(n[0][9].toString()!==e.relayerFee)throw new Error("relayer fee mismatch")}));class zr{constructor(t,e,n,i){if(c(this,"network"),c(this,"chain"),c(this,"provider"),c(this,"contracts"),c(this,"chainId"),c(this,"porticoAddress"),c(this,"uniswapAddress"),c(this,"porticoContract"),c(this,"uniswapContract"),c(this,"core"),this.network=t,this.chain=e,this.provider=n,this.contracts=i,!i.portico)throw new Error("Unsupported chain, no contract addresses for: "+e);this.core=new s.E(t,e,n,i);const{portico:a,uniswapQuoterV2:o}=i.portico;this.porticoAddress=a,this.uniswapAddress=o,this.chainId=r.c3.get(t,e),this.porticoContract=new Mr(this.porticoAddress,Gr.fragments,this.provider),this.uniswapContract=new Mr(this.uniswapAddress,Vr.fragments,this.provider)}static async fromRpc(t,e){const[n,r]=await i.E.chainFromRpc(t),s=e[r];if(s.network!==n)throw new Error(`Network mismatch: ${s.network} != ${n}`);return new zr(n,r,t,s.contracts)}async*transfer(t,e,n,s,a,o){const{minAmountStart:c,minAmountFinish:u}=o.swapAmounts;if(0n===c)throw new Error("Invalid min swap amount");if(0n===u)throw new Error("Invalid min swap amount");const l=new i.a(t).toString(),[h,f]=(0,r.cr)(this.network,this.chain,n),[d,p]=(0,r.cr)(this.network,e.chain,a),g=(0,r.ch)(f),m=(0,r.ch)(this.getTransferrableToken(g)),y=(0,r.ch)(e),w=(0,r.ch)(p),b=r.cs.get(this.network,e.chain).portico,v=(new Date).valueOf()%16,E=r.cv.serializeFlagSet({flags:{shouldWrapNative:h,shouldUnwrapNative:d},recipientChain:(0,r.bW)(e.chain),bridgeNonce:v,feeTierStart:Wr,feeTierFinish:Wr,padding:new Uint8Array(19)}),k=Gr.encodeFunctionData("start",[[E,g.toLowerCase(),m,w.toLowerCase(),y,b,s.toString(),c.toString(),u.toString(),o.relayerFee.toString()]]);h||(yield*this.approve(g,l,s,this.porticoAddress));const N=await this.core.getMessageFee(),O={to:this.porticoAddress,data:k,value:N+(h?s:0n)};yield this.createUnsignedTransaction((0,i.b)(O,l),"PorticoBridge.Transfer")}async*redeem(t,e){const n=await this.porticoContract.getFunction("receiveMessageAndSwap").populateTransaction((0,r.cw)(e)),s=new i.a(t).toString();yield this.createUnsignedTransaction((0,i.b)(n,s),"PorticoBridge.Redeem")}async quoteSwap(t,e,n){const[,s]=(0,r.cr)(this.network,this.chain,t),[,i]=(0,r.cr)(this.network,this.chain,e),a=(0,r.ch)(s),o=(0,r.ch)(i);return(0,r.cu)(a,o)?n:(await this.uniswapContract.getFunction("quoteExactInputSingle").staticCall([a,o,n,Wr,0]))[0]}async quoteRelay(t,e){return await Hr.quoteRelayer(this.chain,t,e)}getTransferrableToken(t){var e;if("Ethereum"===this.chain)return r.av.tokenId("Ethereum",t);const n=(0,r.ci)(this.network,this.chain,t);if(!n)throw new Error("Unsupported source token: "+t);const s=null==(e=(0,r.cx)(this.network,this.chain,n.symbol))?void 0:e.find((t=>"Ethereum"===t.original));if(!s)throw new Error(`Unsupported symbol for chain ${n.symbol}: ${this.chain} `);return r.av.tokenId(s.chain,s.address)}async*approve(t,e,n,r){const s=i.E.getTokenImplementation(this.provider,t);if(await s.allowance(e,r)<n){const t=await s.approve.populateTransaction(r,n);yield this.createUnsignedTransaction((0,i.b)(t,e),"PorticoBridge.Approve")}}createUnsignedTransaction(t,e){return new s.a((0,i.c)(t,this.chainId),this.network,this.chain,e,!1)}}(0,a.r)(i._,"PorticoBridge",zr)}}]);
//# sourceMappingURL=590.343a6140.chunk.js.map