"use strict";(self.webpackChunkmultichain_poc=self.webpackChunkmultichain_poc||[]).push([[2706],{9312:(e,t,r)=>{r.d(t,{c:()=>c});var n=r(7126);function o(e,t){switch(e.binary){case"bytes":if("layout"in e){const{custom:r}=e;return void 0===r||"function"!=typeof r.from?s(e.layout,r?r.from:t):t}case"int":case"uint":{const{custom:r}=e;return null!=e&&e.omit?void 0:(0,n.cX)(r)?r:(0,n.cY)(r)?r.to:t}case"array":return Array.isArray(t)?t.map((t=>s(e.layout,t))):void 0;case"switch":{const r=t[e.idTag??"id"],[n,o]=e.layouts.find((e=>{let[t]=e;return(Array.isArray(t)?t[1]:t)==r}));return{[e.idTag??"id"]:r,...s(o,t)}}}}function s(e,t){if(t=t??{},(0,n.cW)(e))return o(e,t);const r={};for(const n of e){const e=o(n,t[n.name]??{});void 0!==e&&(r[n.name]=e)}return r}function a(e,t){return s(e,t)}function i(e){return[...n.c_,(0,n.c$)(e)]}function c(e,t){const[r,o]=(0,n.cZ)(e),s=a(i(e),t);return{protocolName:r,payloadName:o,payloadLiteral:e,...a(n.d0,t),...s,hash:(0,n.cF)((0,n.cT)(i(e),s))}}},2706:(e,t,r)=>{r.r(t),r.d(t,{AptosWormholeCore:()=>h});var n=r(7126),o=r(8944),s=r(9312),a=r(6310),i=Object.defineProperty,c=(e,t,r)=>(((e,t,r)=>{t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r})(e,"symbol"!=typeof t?t+"":t,r),r);class h{constructor(e,t,r,o){c(this,"network"),c(this,"chain"),c(this,"connection"),c(this,"contracts"),c(this,"chainId"),c(this,"coreBridge"),this.network=e,this.chain=t,this.connection=r,this.contracts=o,this.chainId=(0,n.bW)(t);const s=o.coreBridge;if(!s)throw new Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridge=s}getGuardianSet(e){throw new Error("Method not implemented.")}getGuardianSetIndex(){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[r,n]=await o.A.chainFromRpc(e),s=t[n];if(s.network!==r)throw new Error(`Network mismatch: ${s.network} !== ${r}`);return new h(r,n,e,s.contracts)}async*publishMessage(e,t){throw new Error("Method not implemented.")}async*verifyMessage(e,t){throw new Error("Not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map((e=>({chain:e.emitterChain,emitter:e.emitterAddress,sequence:e.sequence})))}async parseMessages(e){const t=await this.connection.getTransactionByHash(e);if("user_transaction"!==t.type)throw new Error(`${e} is not a user_transaction`);const r=t.events.filter((e=>e.type.endsWith("WormholeMessage")));if(!r||0===r.length)throw new Error(`WormholeMessage not found for ${e}`);return r.map((e=>{const t=e.data,r=new n.as(BigInt(t.sender).toString(16).padStart(64,"0"));return(0,s.c)("Uint8Array",{guardianSet:0,emitterChain:this.chain,emitterAddress:r,sequence:BigInt(t.sequence),timestamp:Number(t.timestamp),consistencyLevel:t.consistency_level,nonce:Number(t.nonce),signatures:[],payload:n.ar.decode(t.payload)})}))}}(0,a.r)("Aptos","WormholeCore",h)}}]);
//# sourceMappingURL=2706.5608d2ed.chunk.js.map